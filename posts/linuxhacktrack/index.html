<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='Linux 手册 [toc]
Git 同时下载子模块 如果你想在克隆Git仓库时包括所有子模块，你可以使用 --recursive 参数，例如：
git clone --recursive https://github.com/yourproject.git 这个命令会克隆主项目以及它的所有子模块。
如果你已经克隆了主项目，但是忘记了克隆子模块，你可以在已经克隆的项目中运行以下命令来初始化和更新子模块：
git submodule update --init --recursive 这个命令将会克隆所有子模块，并且检出正确的提交（子模块在主项目中是指定的）。
创建Linux交换区 在Linux上创建一个swap文件作为交换区，你可以按照以下步骤操作：
创建一个空的swap文件：你可以使用dd命令来创建一个空的swap文件。例如，下面的命令会创建一个大小为4G的swap文件： sudo dd if=/dev/zero of=/swapfile bs=1G count=4 这个命令的意思是从/dev/zero设备读取数据，然后写入到/swapfile文件中，每次读写的数据块大小为1G，总共读写4次，所以最后创建的文件大小为4G。
设置swap文件的权限：为了安全，你应该设置swap文件的权限，使得只有root用户可以读写这个文件： sudo chmod 600 /swapfile 格式化swap文件：你需要使用mkswap命令来格式化你刚刚创建的文件，使其可以被用作交换区： sudo mkswap /swapfile 启用swap文件：你可以使用swapon命令来启用你的swap文件： sudo swapon /swapfile 使swap文件在重启后自动启用：你需要将你的swap文件添加到/etc/fstab文件中，这样在系统重启后，这个swap文件会自动启用。你可以使用下面的命令来添加： echo &amp;#39;/swapfile none swap sw 0 0&amp;#39; | sudo tee -a /etc/fstab 以上就是在Linux上创建一个swap文件作为交换区的步骤。你需要使用root权限来执行这些命令，因为操作交换区需要root权限。
sudo免密码 在Linux上，你可以通过编辑sudoers文件来为用户设置无需密码的sudo权限。你可以按照以下步骤操作：
打开sudoers文件：你需要使用visudo命令来编辑sudoers文件。这个命令会打开一个文本编辑器（通常是vi或nano），并加载sudoers文件： sudo visudo 添加无需密码的sudo权限：在sudoers文件中，找到类似于下面的一行： root ALL=(ALL:ALL) ALL 在这一行下面，添加一行新的配置，将root替换为你的用户名，将最后的ALL替换为NOPASSWD: ALL，例如，如果你的用户名是username，那么你应该添加的行应该是：
username ALL=(ALL) NOPASSWD:ALL 这一行的意思是，用户username在任何主机上，作为任何用户，运行任何命令时，都不需要输入密码。'>
<title>LinuxHackTrack</title>

<link rel='canonical' href='http://ahaknow.com/posts/linuxhacktrack/'>

<link rel="stylesheet" href="/scss/style.min.ff300df33b80e2ac49809c825614392ed1c7b27591d65d3c4043602cd162e25f.css"><meta property='og:title' content='LinuxHackTrack'>
<meta property='og:description' content='Linux 手册 [toc]
Git 同时下载子模块 如果你想在克隆Git仓库时包括所有子模块，你可以使用 --recursive 参数，例如：
git clone --recursive https://github.com/yourproject.git 这个命令会克隆主项目以及它的所有子模块。
如果你已经克隆了主项目，但是忘记了克隆子模块，你可以在已经克隆的项目中运行以下命令来初始化和更新子模块：
git submodule update --init --recursive 这个命令将会克隆所有子模块，并且检出正确的提交（子模块在主项目中是指定的）。
创建Linux交换区 在Linux上创建一个swap文件作为交换区，你可以按照以下步骤操作：
创建一个空的swap文件：你可以使用dd命令来创建一个空的swap文件。例如，下面的命令会创建一个大小为4G的swap文件： sudo dd if=/dev/zero of=/swapfile bs=1G count=4 这个命令的意思是从/dev/zero设备读取数据，然后写入到/swapfile文件中，每次读写的数据块大小为1G，总共读写4次，所以最后创建的文件大小为4G。
设置swap文件的权限：为了安全，你应该设置swap文件的权限，使得只有root用户可以读写这个文件： sudo chmod 600 /swapfile 格式化swap文件：你需要使用mkswap命令来格式化你刚刚创建的文件，使其可以被用作交换区： sudo mkswap /swapfile 启用swap文件：你可以使用swapon命令来启用你的swap文件： sudo swapon /swapfile 使swap文件在重启后自动启用：你需要将你的swap文件添加到/etc/fstab文件中，这样在系统重启后，这个swap文件会自动启用。你可以使用下面的命令来添加： echo &amp;#39;/swapfile none swap sw 0 0&amp;#39; | sudo tee -a /etc/fstab 以上就是在Linux上创建一个swap文件作为交换区的步骤。你需要使用root权限来执行这些命令，因为操作交换区需要root权限。
sudo免密码 在Linux上，你可以通过编辑sudoers文件来为用户设置无需密码的sudo权限。你可以按照以下步骤操作：
打开sudoers文件：你需要使用visudo命令来编辑sudoers文件。这个命令会打开一个文本编辑器（通常是vi或nano），并加载sudoers文件： sudo visudo 添加无需密码的sudo权限：在sudoers文件中，找到类似于下面的一行： root ALL=(ALL:ALL) ALL 在这一行下面，添加一行新的配置，将root替换为你的用户名，将最后的ALL替换为NOPASSWD: ALL，例如，如果你的用户名是username，那么你应该添加的行应该是：
username ALL=(ALL) NOPASSWD:ALL 这一行的意思是，用户username在任何主机上，作为任何用户，运行任何命令时，都不需要输入密码。'>
<meta property='og:url' content='http://ahaknow.com/posts/linuxhacktrack/'>
<meta property='og:site_name' content='AhaKnow'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:published_time' content='2023-07-26T01:30:00&#43;08:00'/><meta property='article:modified_time' content='2023-07-26T01:30:00&#43;08:00'/>
<meta name="twitter:title" content="LinuxHackTrack">
<meta name="twitter:description" content="Linux 手册 [toc]
Git 同时下载子模块 如果你想在克隆Git仓库时包括所有子模块，你可以使用 --recursive 参数，例如：
git clone --recursive https://github.com/yourproject.git 这个命令会克隆主项目以及它的所有子模块。
如果你已经克隆了主项目，但是忘记了克隆子模块，你可以在已经克隆的项目中运行以下命令来初始化和更新子模块：
git submodule update --init --recursive 这个命令将会克隆所有子模块，并且检出正确的提交（子模块在主项目中是指定的）。
创建Linux交换区 在Linux上创建一个swap文件作为交换区，你可以按照以下步骤操作：
创建一个空的swap文件：你可以使用dd命令来创建一个空的swap文件。例如，下面的命令会创建一个大小为4G的swap文件： sudo dd if=/dev/zero of=/swapfile bs=1G count=4 这个命令的意思是从/dev/zero设备读取数据，然后写入到/swapfile文件中，每次读写的数据块大小为1G，总共读写4次，所以最后创建的文件大小为4G。
设置swap文件的权限：为了安全，你应该设置swap文件的权限，使得只有root用户可以读写这个文件： sudo chmod 600 /swapfile 格式化swap文件：你需要使用mkswap命令来格式化你刚刚创建的文件，使其可以被用作交换区： sudo mkswap /swapfile 启用swap文件：你可以使用swapon命令来启用你的swap文件： sudo swapon /swapfile 使swap文件在重启后自动启用：你需要将你的swap文件添加到/etc/fstab文件中，这样在系统重启后，这个swap文件会自动启用。你可以使用下面的命令来添加： echo &amp;#39;/swapfile none swap sw 0 0&amp;#39; | sudo tee -a /etc/fstab 以上就是在Linux上创建一个swap文件作为交换区的步骤。你需要使用root权限来执行这些命令，因为操作交换区需要root权限。
sudo免密码 在Linux上，你可以通过编辑sudoers文件来为用户设置无需密码的sudo权限。你可以按照以下步骤操作：
打开sudoers文件：你需要使用visudo命令来编辑sudoers文件。这个命令会打开一个文本编辑器（通常是vi或nano），并加载sudoers文件： sudo visudo 添加无需密码的sudo权限：在sudoers文件中，找到类似于下面的一行： root ALL=(ALL:ALL) ALL 在这一行下面，添加一行新的配置，将root替换为你的用户名，将最后的ALL替换为NOPASSWD: ALL，例如，如果你的用户名是username，那么你应该添加的行应该是：
username ALL=(ALL) NOPASSWD:ALL 这一行的意思是，用户username在任何主机上，作为任何用户，运行任何命令时，都不需要输入密码。">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_huda2458f72ce188392d75c5d51cd8e24e_373_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">AhaKnow</a></h1>
            <h2 class="site-description"></h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>Dark Mode</span>
                </li>
            
        </div>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/posts/linuxhacktrack/">LinuxHackTrack</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jul 26, 2023</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    5 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="linux-手册">Linux 手册</h1>
<p>[toc]</p>
<h2 id="git">Git</h2>
<h3 id="同时下载子模块">同时下载子模块</h3>
<p>如果你想在克隆Git仓库时包括所有子模块，你可以使用 <code>--recursive</code> 参数，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone --recursive https://github.com/yourproject.git
</span></span></code></pre></div><p>这个命令会克隆主项目以及它的所有子模块。</p>
<p>如果你已经克隆了主项目，但是忘记了克隆子模块，你可以在已经克隆的项目中运行以下命令来初始化和更新子模块：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git submodule update --init --recursive
</span></span></code></pre></div><p>这个命令将会克隆所有子模块，并且检出正确的提交（子模块在主项目中是指定的）。</p>
<h2 id="创建linux交换区">创建Linux交换区</h2>
<p>在Linux上创建一个swap文件作为交换区，你可以按照以下步骤操作：</p>
<ol>
<li><strong>创建一个空的swap文件</strong>：你可以使用<code>dd</code>命令来创建一个空的swap文件。例如，下面的命令会创建一个大小为4G的swap文件：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>/dev/zero of<span style="color:#f92672">=</span>/swapfile bs<span style="color:#f92672">=</span>1G count<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>
</span></span></code></pre></div><p>这个命令的意思是从<code>/dev/zero</code>设备读取数据，然后写入到<code>/swapfile</code>文件中，每次读写的数据块大小为1G，总共读写4次，所以最后创建的文件大小为4G。</p>
<ol start="2">
<li><strong>设置swap文件的权限</strong>：为了安全，你应该设置swap文件的权限，使得只有root用户可以读写这个文件：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo chmod <span style="color:#ae81ff">600</span> /swapfile
</span></span></code></pre></div><ol start="3">
<li><strong>格式化swap文件</strong>：你需要使用<code>mkswap</code>命令来格式化你刚刚创建的文件，使其可以被用作交换区：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkswap /swapfile
</span></span></code></pre></div><ol start="4">
<li><strong>启用swap文件</strong>：你可以使用<code>swapon</code>命令来启用你的swap文件：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo swapon /swapfile
</span></span></code></pre></div><ol start="5">
<li><strong>使swap文件在重启后自动启用</strong>：你需要将你的swap文件添加到<code>/etc/fstab</code>文件中，这样在系统重启后，这个swap文件会自动启用。你可以使用下面的命令来添加：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;/swapfile none swap sw 0 0&#39;</span> | sudo tee -a /etc/fstab
</span></span></code></pre></div><p>以上就是在Linux上创建一个swap文件作为交换区的步骤。你需要使用root权限来执行这些命令，因为操作交换区需要root权限。</p>
<h2 id="sudo免密码">sudo免密码</h2>
<p>在Linux上，你可以通过编辑<code>sudoers</code>文件来为用户设置无需密码的sudo权限。你可以按照以下步骤操作：</p>
<ol>
<li><strong>打开sudoers文件</strong>：你需要使用<code>visudo</code>命令来编辑<code>sudoers</code>文件。这个命令会打开一个文本编辑器（通常是<code>vi</code>或<code>nano</code>），并加载<code>sudoers</code>文件：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo visudo
</span></span></code></pre></div><ol start="2">
<li><strong>添加无需密码的sudo权限</strong>：在<code>sudoers</code>文件中，找到类似于下面的一行：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>root    ALL<span style="color:#f92672">=(</span>ALL:ALL<span style="color:#f92672">)</span> ALL
</span></span></code></pre></div><p>在这一行下面，添加一行新的配置，将<code>root</code>替换为你的用户名，将最后的<code>ALL</code>替换为<code>NOPASSWD: ALL</code>，例如，如果你的用户名是<code>username</code>，那么你应该添加的行应该是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>username    ALL<span style="color:#f92672">=(</span>ALL<span style="color:#f92672">)</span> NOPASSWD:ALL
</span></span></code></pre></div><p>这一行的意思是，用户<code>username</code>在任何主机上，作为任何用户，运行任何命令时，都不需要输入密码。</p>
<ol start="3">
<li><strong>保存并退出</strong>：在你完成编辑后，保存并退出编辑器。如果你的编辑器是<code>vi</code>，你可以按<code>Esc</code>键，然后输入<code>:wq</code>，然后按<code>Enter</code>键来保存并退出。如果你的编辑器是<code>nano</code>，你可以按<code>Ctrl+O</code>来保存，然后按<code>Ctrl+X</code>来退出。</li>
</ol>
<p>以上就是在Linux上为用户设置无需密码的sudo权限的步骤。请注意，这种设置可能会带来安全风险，因为任何能够以你的用户身份运行命令的人都可以获得root权限，而不需要知道你的密码。你应该只在你完全信任的环境中使用这种设置。</p>
<h2 id="修改vim为默认编辑器">修改VIM为默认编辑器</h2>
<p>在Linux上，你可以通过更新<code>update-alternatives</code>来更改默认的编辑器。以下是如何将默认编辑器更改为vim的步骤：</p>
<ol>
<li>
<p>打开终端。</p>
</li>
<li>
<p>输入以下命令：</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo update-alternatives --config editor
</span></span></code></pre></div><ol start="3">
<li>
<p>这将显示一个列表，列出了所有可用的文本编辑器，每个编辑器旁边都有一个编号。找到vim对应的编号。</p>
</li>
<li>
<p>输入vim对应的编号，然后按回车。</p>
</li>
</ol>
<p>现在，当你使用<code>sudo visudo</code>或其他需要调用默认编辑器的命令时，将会打开vim。</p>
<p>如果你没有看到vim在列表中，那可能是因为vim还没有被安装。你可以使用以下命令来安装vim：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt-get install vim
</span></span></code></pre></div><p>然后，你可以再次运行<code>sudo update-alternatives --config editor</code>命令来设置vim为默认编辑器。</p>
<h2 id="cuda环境变量">CUDA环境变量</h2>
<p>为了让系统能够找到CUDA编译器<code>nvcc</code>，你需要将CUDA的二进制文件目录添加到<code>PATH</code>环境变量中。这通常可以通过在bash的配置文件（如<code>~/.bashrc</code>或<code>~/.bash_profile</code>）中添加以下行来实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export PATH<span style="color:#f92672">=</span>/usr/local/cuda/bin:$PATH
</span></span></code></pre></div><p>这里，<code>/usr/local/cuda/bin</code>是CUDA的二进制文件目录，你需要根据你的CUDA安装位置进行修改。</p>
<p>在添加了这一行之后，你需要重新加载bash的配置文件，或者重新打开一个终端窗口，这样新的<code>PATH</code>设置才能生效。你可以使用以下命令来重新加载bash的配置文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>source ~/.bashrc
</span></span></code></pre></div><p>或者：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>source ~/.bash_profile
</span></span></code></pre></div><p>然后，你可以通过运行<code>nvcc --version</code>命令来检查<code>nvcc</code>是否可以被正确找到。</p>
<p>此外，一些CUDA的库文件也需要被添加到<code>LD_LIBRARY_PATH</code>环境变量中，你可以通过在bash的配置文件中添加以下行来实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export LD_LIBRARY_PATH<span style="color:#f92672">=</span>/usr/local/cuda/lib64:$LD_LIBRARY_PATH
</span></span></code></pre></div><p>这里，<code>/usr/local/cuda/lib64</code>是CUDA的库文件目录，你需要根据你的CUDA安装位置进行修改。</p>
<h2 id="ssh-key">SSH Key</h2>
<p>在Linux上，你可以使用<code>ssh-keygen</code>命令来生成SSH密钥对，这个密钥对可以用于Git和其他需要SSH认证的服务。以下是生成SSH密钥对的步骤：</p>
<ol>
<li>
<p>打开终端。</p>
</li>
<li>
<p>输入以下命令：</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ssh-keygen -t rsa -b <span style="color:#ae81ff">4096</span> -C <span style="color:#e6db74">&#34;your_email@example.com&#34;</span>
</span></span></code></pre></div><p>这个命令会生成一个类型为RSA，长度为4096位的SSH密钥对。<code>-C</code>选项后面的字符串是一个注释，通常可以填写你的邮箱地址。</p>
<ol start="3">
<li>
<p>当系统提示你输入一个文件来保存密钥时，你可以直接按回车，这样密钥会被保存到默认的位置（通常是<code>~/.ssh/id_rsa</code>）。</p>
</li>
<li>
<p>然后，系统会提示你输入一个密码。这个密码会用于保护你的私钥。你可以选择输入一个密码，也可以直接按回车跳过，这样你的私钥就不会被加密。</p>
</li>
</ol>
<p>现在，你已经生成了一个SSH密钥对。你可以使用<code>cat</code>命令来查看你的公钥：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat ~/.ssh/id_rsa.pub
</span></span></code></pre></div><p>然后，你可以将这个公钥添加到Git或其他需要SSH认证的服务中。</p>
<p>请注意，你的私钥（<code>~/.ssh/id_rsa</code>）是非常敏感的信息，你应该妥善保管，不要泄露给任何人。</p>
<h2 id="关闭conda默认的base">关闭conda默认的base</h2>
<p>当你安装Anaconda或Miniconda时，它会在你的shell配置文件（如<code>~/.bashrc</code>或<code>~/.bash_profile</code>）中添加一行来激活base环境。这就是为什么每次打开新的终端窗口时，base环境都会被自动激活。</p>
<p>如果你不希望每次打开新的终端窗口时自动激活base环境，你可以运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>conda config --set auto_activate_base false
</span></span></code></pre></div><p>这个命令会更改conda的配置，禁止自动激活base环境。</p>
<p>然后，你可以通过运行<code>conda activate base</code>命令来手动激活base环境，或者运行<code>conda activate &lt;环境名&gt;</code>来激活其他的conda环境。</p>
<p>如果你想恢复自动激活base环境，你可以运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>conda config --set auto_activate_base true
</span></span></code></pre></div><h2 id="opencv安装选项">OpenCV安装选项</h2>
<p>在编译OpenCV时，你可以使用<code>-D</code>选项来设置CMake的变量，包括安装路径、是否安装contrib模块、是否安装VTK等。以下是一个示例命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cmake -D CMAKE_BUILD_TYPE<span style="color:#f92672">=</span>RELEASE <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      -D CMAKE_INSTALL_PREFIX<span style="color:#f92672">=</span>/path/to/install <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      -D OPENCV_EXTRA_MODULES_PATH<span style="color:#f92672">=</span>/path/to/opencv_contrib/modules <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      -D WITH_VTK<span style="color:#f92672">=</span>ON <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      /path/to/opencv/source
</span></span></code></pre></div><p>在这个命令中：</p>
<ul>
<li><code>CMAKE_BUILD_TYPE</code>设置了编译类型，通常可以设置为<code>RELEASE</code>或<code>DEBUG</code>。</li>
<li><code>CMAKE_INSTALL_PREFIX</code>设置了安装路径，你需要将<code>/path/to/install</code>替换为你希望安装OpenCV的路径。</li>
<li><code>OPENCV_EXTRA_MODULES_PATH</code>设置了OpenCV contrib模块的路径，你需要将<code>/path/to/opencv_contrib/modules</code>替换为你的OpenCV contrib模块的路径。</li>
<li><code>WITH_VTK</code>设置了是否安装VTK，设置为<code>ON</code>表示安装，设置为<code>OFF</code>表示不安装。</li>
<li><code>/path/to/opencv/source</code>是你的OpenCV源代码的路径，你需要将它替换为你的OpenCV源代码的路径。</li>
</ul>
<p>请注意，你需要先安装VTK和OpenCV contrib模块的依赖库，然后下载OpenCV和OpenCV contrib模块的源代码，然后才能运行这个命令。</p>
<p>在运行了这个命令之后，你可以运行<code>make</code>命令来编译OpenCV，然后运行<code>make install</code>命令来安装OpenCV。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cmake -D CMAKE_BUILD_TYPE<span style="color:#f92672">=</span>RELEASE <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      -D CMAKE_INSTALL_PREFIX<span style="color:#f92672">=</span>/usr/local/opencv3 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      -D OPENCV_EXTRA_MODULES_PATH<span style="color:#f92672">=</span>~/Toolkits/opencv_contrib/modules <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      -D WITH_VTK<span style="color:#f92672">=</span>ON <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      ..
</span></span></code></pre></div><h3 id="关于pkgconfig">关于PKGCONFIG</h3>
<p><code>pkg-config</code>是一个帮助你在编译过程中引用库文件的工具。当你编译一个程序时，你可能需要引用一些库文件，这些库文件可能位于不同的路径，有不同的头文件和链接选项。<code>pkg-config</code>可以帮助你管理这些信息。</p>
<p>在CMake中，你可以设置<code>PKG_CONFIG_EXECUTABLE</code>变量来指定<code>pkg-config</code>的路径，设置<code>PKG_CONFIG_USE_CMAKE_PREFIX_PATH</code>变量来让<code>pkg-config</code>使用CMake的前缀路径。</p>
<p>在编译OpenCV时，你可以设置<code>OPENCV_GENERATE_PKGCONFIG</code>变量来生成一个<code>pkg-config</code>的<code>.pc</code>文件。这个文件包含了使用OpenCV需要的编译和链接选项。你可以在你的<code>Makefile</code>或<code>CMakeLists.txt</code>文件中使用这个<code>.pc</code>文件，来简化你的编译和链接过程。</p>
<p>例如，你可以在编译OpenCV时添加<code>-D OPENCV_GENERATE_PKGCONFIG=ON</code>选项：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cmake -D CMAKE_BUILD_TYPE<span style="color:#f92672">=</span>RELEASE <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      -D CMAKE_INSTALL_PREFIX<span style="color:#f92672">=</span>/path/to/install <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      -D OPENCV_EXTRA_MODULES_PATH<span style="color:#f92672">=</span>/path/to/opencv_contrib/modules <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      -D WITH_VTK<span style="color:#f92672">=</span>ON <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      -D OPENCV_GENERATE_PKGCONFIG<span style="color:#f92672">=</span>ON <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>      /path/to/opencv/source
</span></span></code></pre></div><p>然后，在你的<code>Makefile</code>或<code>CMakeLists.txt</code>文件中，你可以使用<code>pkg-config --cflags opencv4</code>和<code>pkg-config --libs opencv4</code>命令来获取使用OpenCV需要的编译和链接选项。</p>
<h2 id="切换cuda版本的脚本">切换Cuda版本的脚本</h2>
<p>在Linux环境下，你可以使用如下的bash脚本实现对CUDA版本的切换。以下是一个可能的脚本实现，你需要根据自己实际的CUDA安装路径进行调整。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e"># changeCuda.sh</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$#<span style="color:#e6db74">&#34;</span> -ne <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Illegal number of parameters, you need to specify the CUDA version&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CUDA_PATH<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/usr/local/cuda-</span>$1<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -d <span style="color:#e6db74">&#34;</span>$CUDA_PATH<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;CUDA version </span>$1<span style="color:#e6db74"> is not installed at </span>$CUDA_PATH<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Remove existing CUDA in PATH if any</span>
</span></span><span style="display:flex;"><span>export PATH<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo $PATH|sed -e <span style="color:#e6db74">&#39;s?:/usr/local/cuda[^:]*??&#39;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add CUDA to PATH</span>
</span></span><span style="display:flex;"><span>export PATH<span style="color:#f92672">=</span>$CUDA_PATH/bin:$PATH
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add CUDA to LD_LIBRARY_PATH</span>
</span></span><span style="display:flex;"><span>export LD_LIBRARY_PATH<span style="color:#f92672">=</span>$CUDA_PATH/lib64:$LD_LIBRARY_PATH
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a symbolic link</span>
</span></span><span style="display:flex;"><span>sudo rm -rf /usr/local/cuda
</span></span><span style="display:flex;"><span>sudo ln -s $CUDA_PATH /usr/local/cuda
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Switched to:&#34;</span>
</span></span><span style="display:flex;"><span>nvcc --version
</span></span></code></pre></div><p>这个脚本首先会检查你是否已经安装了你希望切换的CUDA版本。然后，它会从你的<code>PATH</code>环境变量中删除当前的CUDA路径，并添加新的CUDA路径。最后，它会更新你的<code>LD_LIBRARY_PATH</code>以便你的系统能找到新CUDA版本的库，并创建一个新的符号链接指向新的CUDA版本。</p>
<p>你可以通过运行 <code>sh changeCuda.sh 11.0</code> 来使用这个脚本。注意，这个脚本需要sudo权限运行，因为它需要修改<code>/usr/local/cuda</code>的符号链接。</p>
<p>这个脚本会影响当前shell环境中的CUDA版本，如果你想让CUDA版本的更改在新的shell环境中也生效，你需要将这些环境变量添加到你的shell启动脚本中，比如<code>~/.bashrc</code> 或者 <code>~/.zshrc</code>中。</p>
<h2 id="自动挂载硬盘">自动挂载硬盘</h2>
<p>在Linux中，你可以通过编辑<code>/etc/fstab</code>文件来设置开机自动挂载硬盘。以下是一个步骤：</p>
<ol>
<li>
<p>打开一个终端。</p>
</li>
<li>
<p>使用<code>sudo</code>命令和你的文本编辑器打开<code>/etc/fstab</code>文件。例如，如果你使用的是<code>nano</code>编辑器，你可以运行以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/fstab
</span></span></code></pre></div></li>
<li>
<p>在<code>/etc/fstab</code>文件的末尾添加一行来设置自动挂载。这一行应该包含以下五个字段，由空格或制表符分隔：</p>
<ul>
<li>文件系统：这应该是你的硬盘设备的路径，例如<code>/dev/sda1</code>。</li>
<li>挂载点：这应该是你想要挂载硬盘的目录的路径。你需要先创建这个目录。</li>
<li>类型：这应该是你的硬盘的文件系统类型，例如<code>ext4</code>、<code>ntfs</code>等。</li>
<li>选项：这应该是一些挂载选项。通常，你可以设置为<code>defaults</code>。</li>
<li>载入顺序：这应该是两个数字。通常，你可以设置为<code>0 0</code>。</li>
</ul>
<p>例如，如果你想要将<code>/dev/sda1</code>挂载到<code>/mnt/mydisk</code>，你可以添加以下一行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/dev/sda1 /mnt/mydisk ext4 defaults <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div></li>
<li>
<p>保存并关闭<code>/etc/fstab</code>文件。</p>
</li>
<li>
<p>你可以运行以下命令来测试你的设置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount -a
</span></span></code></pre></div><p>如果你的设置正确，这个命令应该没有输出，并且你的硬盘应该被挂载到指定的目录。</p>
</li>
</ol>
<p>请注意，你需要根据你的硬盘和系统来修改以上步骤。你需要知道你的硬盘设备的路径、你的硬盘的文件系统类型，以及你想要挂载硬盘的目录的路径。</p>
<h2 id="run文件安装nvidia驱动">run文件安装Nvidia驱动</h2>
<p>如果你使用 <code>.run</code> 文件来安装 Nvidia 驱动，你需要首先退出你的 X 服务器（也就是你的图形用户界面）。这是因为 Nvidia 的 <code>.run</code> 文件会在安装过程中更改一些 X 服务器使用的库文件，如果 X 服务器正在运行，那么这些库文件可能被锁定，导致安装失败。</p>
<p>以下是一般步骤：</p>
<ol>
<li>
<p>首先，你需要关闭你的图形用户界面。在 Ubuntu 上，你可以通过以下命令来做到这一点：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo service lightdm stop
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 如果是GDM</span>
</span></span><span style="display:flex;"><span>sudo systemctl gdm stop
</span></span></code></pre></div><p>请注意，这将立即关闭你的图形用户界面，所以你需要先保存所有的工作。</p>
</li>
<li>
<p>然后，你可以转到 <code>.run</code> 文件所在的目录，然后运行以下命令来安装驱动：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo chmod +x NVIDIA-Linux-x86_64-xxx.xx.run
</span></span><span style="display:flex;"><span>sudo ./NVIDIA-Linux-x86_64-xxx.xx.run
</span></span></code></pre></div><p>在这里，<code>NVIDIA-Linux-x86_64-xxx.xx.run</code> 是你的 Nvidia 驱动的文件名，你需要替换为你的实际文件名。</p>
</li>
<li>
<p>在安装过程中，你需要回答一些问题。一般来说，你应该接受默认的选项，除非你有特殊的需求。</p>
</li>
<li>
<p>安装完成后，你可以通过以下命令重新启动你的图形用户界面：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo service lightdm start
</span></span></code></pre></div></li>
<li>
<p>重启你的电脑。</p>
</li>
</ol>
<p>安装完成后，你可以运行 <code>nvidia-smi</code> 命令来确认驱动是否已经正确安装。</p>
<p>请注意，使用 <code>.run</code> 文件来安装 Nvidia 驱动通常不是推荐的做法，因为这可能会和你的系统的包管理器产生冲突。除非你有特殊的需求，否则你应该优先考虑使用你的系统的包管理器（如 <code>apt</code>）来安装驱动。</p>
<h3 id="安装过程">安装过程</h3>
<blockquote>
<p>Would you like to run the nvidia-xconfig utility to automatically update your X configuration file so that the NVIDIA X driver will be used when you restart X?  Any pre-existing X configuration file will be  backed up.</p>
</blockquote>
<p>对于这个问题，一般来说，如果你不是很确定你的 X 配置文件应该如何设置，那么你应该选择 &ldquo;yes&rdquo;。这将让 <code>nvidia-xconfig</code> 工具自动配置你的 X 配置文件，使得在你重启 X 服务器时能够使用 Nvidia 的 X 驱动。</p>
<p>当你选择 &ldquo;yes&rdquo; 时，<code>nvidia-xconfig</code> 会查找 <code>/etc/X11</code> 目录下的 <code>xorg.conf</code> 文件，如果找到，就将其备份，并生成新的配置文件。如果没有找到 <code>xorg.conf</code> 文件，<code>nvidia-xconfig</code> 就会创建一个新的文件。</p>
<p>如果你选择 &ldquo;no&rdquo;，则 <code>nvidia-xconfig</code> 不会更改你现有的 X 配置文件。这意味着，除非你已经手动配置了 X 服务器以使用 Nvidia 驱动，否则即使你已经安装了 Nvidia 驱动，X 服务器也可能不会使用它。</p>
<p>因此，除非你有特殊的需求，或者你知道你正在做什么，否则你应该让 <code>nvidia-xconfig</code> 来自动配置你的 X 配置文件。</p>
<h2 id="查找指定文件">查找指定文件</h2>
<p>在Linux系统中，我们可以使用<code>find</code>命令来查找指定的文件。基本的使用格式为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>find <span style="color:#f92672">[</span>path<span style="color:#f92672">]</span> -name <span style="color:#f92672">[</span>filename<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>其中，[path]是你希望开始查找的路径，[filename]是你要查找的文件名。</p>
<p>例如，如果你想要在/home/user目录下查找名为file.txt的文件，你可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>find /home/user -name file.txt
</span></span></code></pre></div><p>注意：<code>-name</code>后面的文件名是区分大小写的。如果你不确定文件名的大小写，你可以使用<code>-iname</code>，它是不区分大小写的。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>find /home/user -iname file.txt
</span></span></code></pre></div><p>这条命令将会找出/home/user目录下所有名为file.txt，不论大小写的文件。</p>
<h2 id="修复boot">修复Boot</h2>
<p>首先，需要启动到Ubuntu的Live环境。这可以通过在启动时选择USB或DVD启动（这要求你已经创建了一个包含Ubuntu系统的USB或DVD启动盘）。</p>
<p>在Ubuntu的Live环境中，你可以按以下步骤安装并使用<code>boot-repair</code>工具：</p>
<ol>
<li>
<p>打开一个终端窗口。你可以通过点击屏幕左上角的活动菜单，然后在搜索框中输入&quot;Terminal&quot;并回车来打开终端。</p>
</li>
<li>
<p>在终端中，输入以下命令来添加<code>boot-repair</code>软件源：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo add-apt-repository ppa:yannubuntu/boot-repair
</span></span></code></pre></div></li>
<li>
<p>更新软件源列表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt-get update
</span></span></code></pre></div></li>
<li>
<p>安装<code>boot-repair</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt-get install -y boot-repair
</span></span></code></pre></div></li>
<li>
<p>运行<code>boot-repair</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>boot-repair
</span></span></code></pre></div></li>
</ol>
<p>在<code>boot-repair</code>的图形界面中，你可以点击&quot;Recommended repair&quot;按键。这将尝试自动修复你的启动问题。根据提示完成操作。</p>
<p>如果自动修复没有解决你的问题，你还可以在<code>boot-repair</code>的高级选项中进行更多设置，但是这通常需要对引导加载程序有更深的理解。如果你不确定如何操作，可以查阅更多关于<code>boot-repair</code>的使用文档或者寻求专业人士的帮助。</p>
<h2 id="连接多个网线的选择次序">连接多个网线的选择次序</h2>
<p>在Linux中，如果两个网络接口同时连接，系统默认会使用具有最小Metric值的接口。Metric值是路由选择的一种参数，数值越小，优先级越高。</p>
<p>当你的两个网线同时连接时，可能是因为你相机的网络接口的Metric值更小，所以上网请求都是通过这个接口，导致无法上网。你需要确保用于上网的网络接口的Metric值更小。</p>
<p>你可以通过以下命令查看你的路由表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>route -n
</span></span><span style="display:flex;"><span><span style="color:#75715e"># sudo apt install net-tools</span>
</span></span></code></pre></div><p>这会显示你的路由表，你可以看到每个接口的Metric值。</p>
<p>在Linux中，设置网络接口的metric值，通常使用的命令是<code>ip route</code>命令，而不是<code>ifconfig</code>。如果你想改变接口<code>eno1</code>的metric值，你可以使用以下命令:</p>
<ol>
<li>首先，你需要找出你当前的默认路由和对应的接口。你可以使用<code>ip route</code>命令来查看:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ip route show
</span></span></code></pre></div><p>在输出中，你应该会看到一行开始于&quot;default&quot;的路由，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>default via 192.168.1.1 dev eno1
</span></span></code></pre></div><p>这里，&ldquo;192.168.1.1&quot;是你的默认路由，&ldquo;eno1&quot;是对应的接口。</p>
<ol start="2">
<li>然后，你可以删除这个默认路由:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip route del default via 192.168.1.1
</span></span></code></pre></div><ol start="3">
<li>最后，你可以添加新的默认路由并设置metric值。假设你希望将metric设置为100，你可以使用以下命令：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ip route add default via 192.168.1.1 dev eno1 metric <span style="color:#ae81ff">100</span>
</span></span></code></pre></div><p>这样，接口eno1的metric值就被设置为100了。</p>
<p>注意，上述操作在重启后不会保留，如果希望设置永久生效，需要修改网络配置文件，方法因发行版而异。</p>
<h3 id="修改网络配置文件">修改网络配置文件</h3>
<p>在Ubuntu 20.04上，网络配置通常由<code>Netplan</code>处理，它使用YAML配置文件来描述网络配置。</p>
<p>以下是如何使用<code>Netplan</code>在Ubuntu 20.04上设置网络接口metric的步骤：</p>
<ol>
<li>首先，找到你当前使用的Netplan配置文件，它们通常在<code>/etc/netplan/</code>目录下。可以使用ls命令查看：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls /etc/netplan/
</span></span></code></pre></div><p>可能会看到一些如<code>01-netcfg.yaml</code>, <code>50-cloud-init.yaml</code>等文件。</p>
<ol start="2">
<li>选择一个配置文件进行编辑，比如<code>01-netcfg.yaml</code>，使用<code>sudo</code>权限打开它：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/netplan/01-netcfg.yaml
</span></span></code></pre></div><ol start="3">
<li>在该文件中，找到要修改metric的网络接口，比如<code>eno1</code>，然后在该接口下添加<code>metric: 100</code>。注意缩进要与上下文保持一致。例如：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">network</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">version</span>: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">renderer</span>: <span style="color:#ae81ff">networkd</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ethernets</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">eno1</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">dhcp4</span>: <span style="color:#66d9ef">yes</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">metric</span>: <span style="color:#ae81ff">100</span>
</span></span></code></pre></div><p>在这里，<code>dhcp4: yes</code>表示该接口使用DHCP来获取IPv4地址，<code>metric: 100</code>表示我们设置该接口的metric为100。</p>
<ol start="4">
<li>
<p>保存并退出文件。</p>
</li>
<li>
<p>应用新的网络配置：</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo netplan apply
</span></span></code></pre></div><p>这样就设置了eno1的metric值。如果在设置过程中遇到问题，可以使用<code>sudo netplan --debug apply</code>命令来获取更多关于问题的信息。注意，这种更改在重启后依然有效。</p>
<h2 id="linux-用户更改密码">Linux 用户更改密码</h2>
<p>在 Linux 中，你可以使用 <code>passwd</code> 命令来更改用户的密码。下面是如何更改密码的步骤：</p>
<ol>
<li>
<p>打开终端。</p>
</li>
<li>
<p>如果你想更改当前用户的密码，只需要键入 <code>passwd</code>，然后按回车键。你将被提示输入新的密码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>passwd
</span></span></code></pre></div><p>你将需要输入新密码两次以确认。</p>
</li>
<li>
<p>如果你是管理员（root 用户），你可以更改其他用户的密码。只需键入 <code>passwd</code>，然后空格，然后是你想更改密码的用户名。例如，如果你想更改名为 <code>username</code> 的用户的密码，你将键入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo passwd username
</span></span></code></pre></div><p>你将需要输入新密码两次以确认。</p>
</li>
</ol>
<p>注意，出于安全考虑，当你输入密码时，终端不会显示任何字符（包括像通常那样的星号）。这是正常的。只需输入密码然后按回车键即可。</p>
<p>在某些 Linux 分发版中，普通用户可能无法更改其他用户的密码。在这种情况下，你需要首先使用 <code>su</code> 或 <code>sudo</code> 命令切换到 root 用户，然后再更改密码。</p>
<h2 id="命令行查看ipv6地址">命令行查看ipv6地址</h2>
<p>在 Linux 中，你可以使用 <code>ip</code> 命令来查看机器的网络接口以及它们的 IPv6 地址。在终端输入以下命令即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ip -6 addr show
</span></span></code></pre></div><p>这个命令的输出将会展示所有网络接口的信息，包括 IPv6 地址（如果有的话）。在输出中，<code>inet6</code> 后面跟着的就是 IPv6 地址。</p>
<p>请注意，网络接口的数量和名称可能会因为你的具体环境和配置而有所不同。</p>
<p><code>ip -6 addr show</code> 命令只会展示那些已经配置和启用了的 IPv6 地址。如果你的网络接口并没有配置 IPv6，那么在输出中将不会显示 IPv6 地址。为了启用和配置 IPv6，你可能需要调整你的网络设置或者与你的网络管理员联系。</p>
<p>关于：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>enp92s0: flags<span style="color:#f92672">=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span style="color:#ae81ff">1500</span>
</span></span><span style="display:flex;"><span>        inet 10.10.16.199  netmask 255.255.255.224  broadcast 10.10.16.223
</span></span><span style="display:flex;"><span>        inet6 2401:ec00:21:6:1fa5:521e:df81:518b  prefixlen <span style="color:#ae81ff">64</span>  scopeid 0x0&lt;global&gt;
</span></span><span style="display:flex;"><span>        inet6 2401:ec00:21:6:3a1:dafa:c54:f319  prefixlen <span style="color:#ae81ff">64</span>  scopeid 0x0&lt;global&gt;
</span></span><span style="display:flex;"><span>        inet6 2401:ec00:21:6:d050:ac2a:2b40:6b4b  prefixlen <span style="color:#ae81ff">64</span>  scopeid 0x0&lt;global&gt;
</span></span><span style="display:flex;"><span>        inet6 2401:ec00:21:6:d6f:520d:38a5:1d48  prefixlen <span style="color:#ae81ff">64</span>  scopeid 0x0&lt;global&gt;
</span></span><span style="display:flex;"><span>        inet6 2401:ec00:21:6:d33b:84bf:5056:3511  prefixlen <span style="color:#ae81ff">64</span>  scopeid 0x0&lt;global&gt;
</span></span><span style="display:flex;"><span>        inet6 2401:ec00:21:6:9de6:4542:f3f:9bd  prefixlen <span style="color:#ae81ff">64</span>  scopeid 0x0&lt;global&gt;
</span></span><span style="display:flex;"><span>        inet6 2401:ec00:21:6:2e25:2879:1d55:b8c1  prefixlen <span style="color:#ae81ff">64</span>  scopeid 0x0&lt;global&gt;
</span></span><span style="display:flex;"><span>        inet6 fe80::8cc4:4c8d:c5f0:4e47  prefixlen <span style="color:#ae81ff">64</span>  scopeid 0x20&lt;link&gt;
</span></span><span style="display:flex;"><span>        inet6 2401:ec00:21:6:3408:4230:1f9d:fea8  prefixlen <span style="color:#ae81ff">64</span>  scopeid 0x0&lt;global&gt;
</span></span><span style="display:flex;"><span>        ether 88:a4:c2:9c:bf:06  txqueuelen <span style="color:#ae81ff">1000</span>  <span style="color:#f92672">(</span>Ethernet<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        RX packets <span style="color:#ae81ff">10866504</span>  bytes <span style="color:#ae81ff">4804249496</span> <span style="color:#f92672">(</span>4.8 GB<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        RX errors <span style="color:#ae81ff">0</span>  dropped <span style="color:#ae81ff">0</span>  overruns <span style="color:#ae81ff">0</span>  frame <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        TX packets <span style="color:#ae81ff">3646641</span>  bytes <span style="color:#ae81ff">901494084</span> <span style="color:#f92672">(</span>901.4 MB<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        TX errors <span style="color:#ae81ff">0</span>  dropped <span style="color:#ae81ff">0</span> overruns <span style="color:#ae81ff">0</span>  carrier <span style="color:#ae81ff">0</span>  collisions <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>在你给出的这段网络接口信息中，<code>enp92s0</code> 是你的网络设备名，其后面的各个字段含义如下：</p>
<ul>
<li><code>flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</code>：这是网络设备的状态标识，<code>UP</code> 表示网络接口处于活动状态，<code>BROADCAST</code> 表示它可以发送广播消息，<code>RUNNING</code> 表示它已经准备好接收和发送数据，<code>MULTICAST</code> 表示它可以发送和接收多播消息。</li>
<li><code>mtu 1500</code>：MTU（Maximum Transmission Unit）是网络设备能够处理的最大数据包大小，单位是字节。这里的 MTU 为1500字节。</li>
<li><code>inet 10.10.16.199</code>：这是该网络接口的 IPv4 地址。</li>
<li><code>inet6</code> 后面跟随的是该网络接口的 IPv6 地址。可以看到，这个接口有多个 IPv6 地址。</li>
</ul>
<p>关于这个接口的所有 IPv6 地址，一般来说，这些地址应该都可以被访问，但也有可能受到防火墙或者路由设置的限制。其中以 <code>fe80::</code> 开头的地址是链接本地地址（link-local address），它只在本地网络中有效，不能用于互联网通信。而其他以 <code>2401:ec00:21:6:</code> 开头的地址是全局唯一地址（global unicast address），可以在整个互联网中被访问。</p>
<p>总的来说，具体能否访问，还需要根据网络环境和配置情况进行测试。</p>
<h2 id="挂载硬盘无法自动挂载的情况">挂载硬盘（无法自动挂载的情况）</h2>
<h3 id="手动挂载">手动挂载</h3>
<p>手动挂载硬盘的命令为 <code>mount</code>，你需要指定设备文件和挂载点。以设备文件为 <code>/dev/sda1</code> 且要挂载到 <code>/mnt/mydrive</code> 为例：</p>
<ol>
<li>
<p>首先，创建挂载点目录（如果不存在的话）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkdir -p /mnt/mydrive
</span></span></code></pre></div></li>
<li>
<p>然后，使用 <code>mount</code> 命令挂载硬盘：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount /dev/sda1 /mnt/mydrive
</span></span></code></pre></div></li>
</ol>
<p>这样，硬盘 <code>/dev/sda1</code> 就被挂载到了 <code>/mnt/mydrive</code> 目录下。</p>
<p>请注意，你需要替换上述命令中的 <code>/dev/sda1</code> 和 <code>/mnt/mydrive</code> 为你的实际硬盘设备文件和挂载点路径。</p>
<p>如果你的硬盘文件系统不是 ext4，你可能需要指定文件系统类型，例如，如果是 NTFS，你可以使用以下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount -t ntfs /dev/sda1 /mnt/mydrive
</span></span></code></pre></div><p>另外，这种挂载方式在重启后会失效，如果你希望硬盘在系统启动时自动挂载，需要按照我之前的回答中的步骤修改 <code>/etc/fstab</code> 文件。</p>
<p><strong>不同于GUI的操作</strong>：</p>
<p>对，直接在图形用户界面（GUI）中点击挂载按钮，和在命令行中使用 <code>mount</code> 命令是有区别的。</p>
<p>在GUI中点击挂载，操作系统通常会自动选择一个挂载点，这个挂载点通常在 <code>/media</code> 或者 <code>/mnt</code> 目录下，目录名通常是硬盘的标签或者一串默认的字符串。当你在文件管理器中点击挂载后，你就可以直接通过这个挂载点来访问硬盘中的文件了。</p>
<p>而在命令行中使用 <code>mount</code> 命令时，你需要手动指定挂载点，这样更灵活，可以根据你的需求来选择硬盘挂载的位置。</p>
<p>不过不论是在GUI中点击挂载，还是在命令行中使用 <code>mount</code> 命令，挂载硬盘的基本原理是一样的，都是将硬盘中的文件系统挂载到你的系统的某个目录下，使得你可以通过这个目录来访问硬盘中的文件。</p>
<h3 id="自动挂载">自动挂载</h3>
<p>在 Linux 系统中，硬盘的自动挂载配置是通过 <code>/etc/fstab</code> 文件来完成的。在该文件中，你可以定义哪些硬盘或者分区在系统启动时自动挂载，以及挂载的位置和挂载的选项。</p>
<p>首先，需要确定 <code>/dev/sda</code> 的文件系统类型，这可以通过 <code>sudo fdisk -l /dev/sda</code> 来查看。</p>
<p>然后，在 <code>fstab</code> 文件中添加一行来表示新的挂载设置。使用 <code>sudo nano /etc/fstab</code> 命令打开 <code>fstab</code> 文件，然后在文件末尾添加如下的一行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/dev/sda /media/metoak/CKDisk auto defaults <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>这里，<code>auto</code> 表示文件系统类型自动检测，<code>defaults</code> 表示使用默认的挂载选项，两个 <code>0</code> 分别表示 dump 和 fsck 的参数，通常设置为 <code>0</code>。</p>
<p>保存并退出 nano 编辑器。</p>
<p>完成以上步骤后，下次启动时，系统应该会自动将 <code>/dev/sda</code> 挂载到 <code>/media/metoak/CKDisk</code>。</p>
<p><strong>注意</strong>：编辑 <code>/etc/fstab</code> 文件需要谨慎，如果设置不正确，可能会导致系统无法正常启动。建议在修改前先备份该文件。</p>
<h2 id="解压缩">解压缩</h2>
<p>如果你有一个<code>.tar</code>文件，你可以使用<code>tar</code>命令进行解压。具体的命令和参数会根据文件的具体类型而变化。下面是一些常见的命令：</p>
<ul>
<li>
<p>对于普通的<code>.tar</code>文件，使用：</p>
<pre tabindex="0"><code>tar -xvf file.tar
</code></pre></li>
<li>
<p>对于<code>.tar.gz</code>或<code>.tgz</code>文件，使用：</p>
<pre tabindex="0"><code>tar -xzvf file.tar.gz
</code></pre></li>
<li>
<p>对于<code>.tar.bz2</code>文件，使用：</p>
<pre tabindex="0"><code>tar -xjvf file.tar.bz2
</code></pre></li>
<li>
<p>对于<code>.tar.xz</code>文件，使用：</p>
<pre tabindex="0"><code>tar -xJvf file.tar.xz
</code></pre></li>
</ul>
<p>在上述命令中，参数的含义如下：</p>
<ul>
<li><code>-x</code>: 解压</li>
<li><code>-v</code>: 显示详细信息</li>
<li><code>-f</code>: 指定文件名</li>
<li><code>-z</code>: 用于<code>.gz</code>文件</li>
<li><code>-j</code>: 用于<code>.bz2</code>文件</li>
<li><code>-J</code>: 用于<code>.xz</code>文件</li>
</ul>
<p>注意：你需要将<code>file.tar</code>替换为你的文件名。</p>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2023 AhaKnow
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.17.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
