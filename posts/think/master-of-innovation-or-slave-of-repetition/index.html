<!DOCTYPE html>














<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true
        },
        options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        }
    };

    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function (x) {
            x.parentElement.classList += 'has-jax'
        })
    });
</script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



<html lang="zh" dir="zh-cn">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>创新的主人还是重复的奴隶？ | AhaKnow</title>
<meta name="keywords" content="思考记录">
<meta name="description" content="引子： 做了一个实时展示的小程序，一开始做的比较粗糙，每次呢，也就是每天的早上，都需要手动去执行，然后用鼠标去一点点调整展示窗口的大小和排列，">
<meta name="author" content="CKYoung">
<link rel="canonical" href="https://ahaknow.com/posts/think/master-of-innovation-or-slave-of-repetition/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ahaknow.com/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://ahaknow.com/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://ahaknow.com/Q.gif">
<link rel="apple-touch-icon" href="https://ahaknow.com/Q.gif">
<link rel="mask-icon" href="https://ahaknow.com/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://ahaknow.com/posts/think/master-of-innovation-or-slave-of-repetition/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="创新的主人还是重复的奴隶？" />
<meta property="og:description" content="引子： 做了一个实时展示的小程序，一开始做的比较粗糙，每次呢，也就是每天的早上，都需要手动去执行，然后用鼠标去一点点调整展示窗口的大小和排列，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ahaknow.com/posts/think/master-of-innovation-or-slave-of-repetition/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-19T10:50:57+08:00" />
<meta property="article:modified_time" content="2024-02-19T10:50:57+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="创新的主人还是重复的奴隶？"/>
<meta name="twitter:description" content="引子： 做了一个实时展示的小程序，一开始做的比较粗糙，每次呢，也就是每天的早上，都需要手动去执行，然后用鼠标去一点点调整展示窗口的大小和排列，"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "🚀 天天向上",
      "item": "https://ahaknow.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "💡思考",
      "item": "https://ahaknow.com/posts/think/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "创新的主人还是重复的奴隶？",
      "item": "https://ahaknow.com/posts/think/master-of-innovation-or-slave-of-repetition/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "创新的主人还是重复的奴隶？",
  "name": "创新的主人还是重复的奴隶？",
  "description": "引子： 做了一个实时展示的小程序，一开始做的比较粗糙，每次呢，也就是每天的早上，都需要手动去执行，然后用鼠标去一点点调整展示窗口的大小和排列，",
  "keywords": [
    "思考记录"
  ],
  "articleBody": " 引子：\n做了一个实时展示的小程序，一开始做的比较粗糙，每次呢，也就是每天的早上，都需要手动去执行，然后用鼠标去一点点调整展示窗口的大小和排列，一共三个窗口，一大两小，排列方式是固定的，但是由于每次都是一点点拖动摆放，因此每一次自己都需要对排列后的样子有一个预期，尽可能调整成看上去还不错的样子，尽管如此这般，也很难做到每次的排列都相同。做到这里，虽然没用到多少时间，几分钟吧，但耗费了不少注意力，因为每天都要想着：早上的第一件事是做这个，而且很有可能哪一天就忘了。晚上的话，还要想着去关掉它，手动关闭，费不了多少时间，但同时消耗了不少注意力，原因和早上的一样：一整天的潜意识里都会挂念着，晚上了得把它关掉。如此，一日复一天，天天如此，重复着同样的工作，而且似乎并没有意识到什么问题……\n都2024年了啊！还是个会敲代码的，天天就干这些事？不知道让这个小程序自己打开再自己关掉嘛？时间一直往前走，怎么写代码的意识还不如从前了呢！\n是啊，已经不知不觉陷入了一种“忙忙碌碌，不思进取，每天做着同样的事，为了活着而活着的”行尸走肉之中了。一天，两天，一周，一个月，大半年，就是这么混过来的，有进步嘛？有一点，但仔细瞧瞧只不过是错觉，很可能还是个负方向的。有反思嘛？好像有过，但借口一句没时间啊就过去了，正如此时敲击着键盘，如果现在不写，那么可能又是，一天过去，一周过去，一个月过去，于是乎，2025年2月20日啦。确实很打脸，因为上一次想要写写文字反思的时候，是2023年2月18日，而当下此刻，是2024年2月19日。。。\n什么时候种树都不迟，只要你意识到了就抡起铲子！也许当下的形势让你觉得自己的所学一文不值，那么就立刻开始，多学习点，想学的就去学，从自己的所爱出发，而不是犹豫、惆怅，还徘徊……\n说回来了，原本这一篇记录是想偏向于“自学的总结”，会涉及一些比较“专业”的东西，一些代码啊，一些指令啥的，昨晚借口一句：“困了先睡觉了”，就没写。欺骗自己说早上醒来写，实际上自己心里很清楚，大概率不可能。人的惰性太自然了，躺着多舒服啊，但如果一直躺着，那不如成为一具尸首。\n正篇：意识到了就立刻行动 我知道此前的我，也是成了“每天重复做着同样工作”的讨厌样子了。\n新的一年，那就由此改变吧！\n实时展示的小程序是吧，加一个自动启动和退出的功能咯！怎么做呢？\n我最开始的想法是将这个小程序软件化，也就是使用QT的可视化图形界面来改写，无奈，尝试了大半天，代码编译看着没问题了，但用不起来，这很大原因和自己没有系统学习有关。现在的chatGPT啊，写代码很厉害了，可能目前我的水平还比较低，用不好它，以至于说是让它辅助我改写，实际上我很多时候并不过脑子，直接复制粘贴，那哪行哦！这不就成了工具的奴隶了，连工具都不如了，这不更容易被食物链中的腐食者给吃了嘛。\n于是，我开始想，能不能通过一些技巧来实现我的需求呢？这些技巧背后依赖的功能应该是存在的，但是我不知道，此时我就是可以通过chatGPT协助了。\n现在是三个窗口（此前实现的时候，使用了多线程，因此同时展示的问题是解决的），我能不能把窗口数量减少，比如两个小窗口直接合成成一个？ 之前每次手动打开都需要手动调整窗口大小和位置，能不能直接在代码中实现预先的设置呢？ 自动打开，Linux上似乎有守护进程可以？但是没有在这里尝试过（这个也是很古老的知识了，至少六年前我就用过），想到过，但是没有行动起来！！ 自动关闭呢？之前设置了通过键盘输入q实现程序的退出，能不能让Linux自动模拟键入q呢？ 按照这个思路我就去做了～\n合并窗口：将思维打开，不要局限 一开始，我是用两个窗口来同时显示两个图像的，最简单也是最笨的操作。为啥之前我就没有想到将两个图像放在一个窗口里呢？\n可能是思维惯性，之前怎么做的，就跟着怎么做了。 也可能就是偷懒，从而导致的不动脑子，以及相应会产生的拖延。 认识到自己的思维存在僵化之后，开始改变：\n首先想到，直接拼接两张图像，上下拼接就能完成。但是在显示上不友好，上下拼接后变成一个长方形了，但是由于显示器很大，把窗口拉长之后上下图居中在一起，上下有空白的，显得很丑，从美观的角度来看的话，如果两个拼接的图像在上下位置能够保证对称，比如上方、两图中间、下方各自留出一块空间，这样就看着舒服了。按照这个思路，那就改～\n直接拼接不成，那就先考虑创建一个大的窗口，然后将两张图像分别搁进去，具体操作起来特别像前端的UI设计，要考虑padding的填充。这样的方法可行，然后还需要加入图像的标题，也采用往大窗口里搁置的思路，同样的，还是考虑了要设置padding的填充，使得标题能够局中。之后就是根据实际的情况，不断地调整窗口的尺寸，padding的大小，以达到自认为满意的比例了。至此，合并窗口完成了，现在的小程序只需要两个窗口就能满足了。\n代码备忘录📝 cv::Mat merged_image; if (left_image_color_global \u0026\u0026 !left_image_color_global-\u003eempty() \u0026\u0026 disparity_color_global \u0026\u0026 !disparity_color_global-\u003eempty()) { int space = 25; // 标题和图像之间的空间 int test_height = 50; // 文本标题的高度（大致估计） cv::Scalar textColor(255, 255, 255); // 文本颜色 int font_face = cv::FONT_HERSHEY_SIMPLEX; double font_scale = 1; int thickness = 2; int top_padding = 20; int between_padding = 60; int bottom_padding = 20; int merged_height = left_image_color_global-\u003erows + disparity_color_global-\u003erows + 3 * space + 2 * test_height + top_padding + bottom_padding + between_padding; int merged_width = std::max(left_image_color_global-\u003ecols, disparity_color_global-\u003ecols); merged_image = cv::Mat::zeros(merged_height, merged_width, left_image_color_global-\u003etype()); // 绘制第一个图像和标题 int title1_x = (merged_width - cv::getTextSize(\"Left Image\", font_face, font_scale, thickness, nullptr).width) / 2; cv::putText(merged_image, \"Left Image\", cv::Point(title1_x, test_height), font_face, font_scale, textColor, thickness); left_image_color_global-\u003ecopyTo(merged_image(cv::Rect(0, top_padding + test_height + space, left_image_color_global-\u003ecols, left_image_color_global-\u003erows))); // 绘制第二个图像和标题 int title2_x = (merged_width - cv::getTextSize(\"Dense Disparity\", font_face, font_scale, thickness, nullptr).width) / 2; int merged_mid = left_image_color_global-\u003erows + 2 * space + test_height + top_padding; cv::putText(merged_image, \"Dense Disparity\", cv::Point(title2_x, merged_mid + test_height), font_face, font_scale, textColor, thickness); disparity_color_global-\u003ecopyTo(merged_image(cv::Rect(0, merged_mid + bottom_padding + test_height + space, disparity_color_global-\u003ecols, disparity_color_global-\u003erows))); } 提前设置窗口位置：不知道的不代表没有，以前是搜索，现在是“问” 设置好窗口大小之后，还需要能够实现打开小程序后，两个窗口能够自动“站”到合适的位置。应该是有这样的方法的，只不过是我不知道，在没有chatGPT之前，可以用Google进行搜索，现在有了chatGPT，只要将需求描述清楚，一般互联网上已有的信息就能够获取到。因此我就直接“问”了有没有这样的方法，果然，有的，而且还很简洁。\n忽然想到一点，这个不就是信息差嘛！以前靠信息差吃某一种职位铁饭碗的想法应该在此之后自己消亡了吧？也许不会，因为好逸恶劳，因为懒惰，因为路径依赖？总之，现在自己意识到了还不算迟。\n所以，很可能以后还是很缺“产品经理、项目经理”这种明确知道需求是什么的，能够用精炼的语言将其描述清楚的总揽全局的人，而不缺重复的、低级的、复制粘贴的所谓“程序员”码农。\n代码备忘录📝 cv::namedWindow(\"Color \u0026 Disparity\", cv::WINDOW_NORMAL); cv::resizeWindow(\"Color \u0026 Disparity\", 1548, 2160); cv::moveWindow(\"Color \u0026 Disparity\", 0, 0); // 将窗口移动到左上角 // ---------------------------------------------------------- // 创建点云可视化器 pcl::visualization::PCLVisualizer::Ptr viewer(new pcl::visualization::PCLVisualizer(\"Dense PointCloud Viewer\")); viewer-\u003esetBackgroundColor(0, 0, 0); viewer-\u003eaddPointCloud\u003cpcl::PointXYZRGB\u003e(point_cloud_ptr_global, \"Dense PointCloud\"); viewer-\u003esetPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, \"Dense PointCloud\"); viewer-\u003einitCameraParameters(); viewer-\u003esetCameraPosition( 0, 0, -1.5, // 控制相机的XYZ位置 0, 0.25, 1, 0, 1, 0 // 后面点云转了旋转，这里Y为1 ); viewer-\u003esetSize(2220, 2160); // 因为使用了VTK的窗口 vtkSmartPointer\u003cvtkRenderWindow\u003e renderWindow = viewer-\u003egetRenderWindow(); renderWindow-\u003eSetPosition(1900, 0); 自启动：不懂的就多探究，不要是一个“半瓶水响叮当” 之前知道一种方法是用守护进程：通过crontab -e进行设置，我也用这个方法尝试了，发现不起作用。分析原因得到：\n因为，我启动的小程序需要调用显示窗口，OpenCV提供的简易窗口和VTK提供的可视化窗口，而守护进程启动命令时，是一种“文本”方式，无法唤起显示的窗口。\n**以前在服务器上用crontab自启动一些命令，因为只会有文本输出，比较简易，那会儿使用远程服务器，自然也不会涉及显示，也就忽略了这个问题。**所以，我此前对于守护进程的理解还只是皮毛，今天多了一些使用的经验。但更重要的是从这次的经历中学会一些“遇到问题、分析现象、思考解决”的思维。\n发现这条路走不通，于是，将自己的需求重新整理了一遍：\n“我希望在当前显示器下，当前的命令行终端下，定时地执行某一个命令”\n在这个思路下，找到了一个可行的方式：\n在终端中，持续运行一个判断：获取当前时间，判断是否等于设定的需要自动打开的时间，如果是就执行命令，然后之后一段时间里不再执行。\n在Linux环境下，这个判断可以比较直接的实现：通过Bash脚本的方式。（本质就是Bash脚本自动化）\n这里明白了一点，一条路走不通很可能是这路条本身就不对，因为很多时候对一项事物也是处于一种了解皮毛的状态，所以遇到问题了要学会打破“自以为是”，从整体的层面来进行分析，对于这里的问题就是：“守护进程不行，为啥不行，那我把运行的日志打印出来，然后分析一下错误信息，再考虑这种方法是不是本身就不支持。”\n代码备忘录📝 #!/bin/bash TARGET_TIME=\"09:00\" while true; do CURRENT_TIME=$(date +%H:%M) if [ \"$CURRENT_TIME\" == \"$TARGET_TIME\" ]; then /home/metoak/Projects/RealTimeDensePointCloud/C++/build/tensorrt_inference_one_camera /home/metoak/Projects/RealTimeDensePointCloud/C++/models/model_mobilev2_960_512.trt 960 512 sleep 60 # 避免在目标时间多次执行 fi sleep 30 # 每30秒检查一次时间 done 自关闭：脑子是越用越灵光的，多想想，不要固化，不要陷入路径依赖 在这里遇到的问题和自启动时差不多。在最开始实现时，也想到了要实现手动关闭，所以就设置了一个通过键盘关闭的方法。我在想能不能自动关闭时，也就顺着这个思路走下去了：“能不能用指令来模拟键盘输入，来达到跟手动按下键盘一样的效果呢？\n想法是好的，也通过chatGPT进行“询问”和尝试，是有这种方法的，但是无法应用在这个问题的解决上。原因简单分析如下：\n通过一个指令或者一个程序模拟键盘输入，它所生效的位置是这个指令或者程序运行的空间；而我通过键盘控制关闭时，实际上是做了两件事：一、先选中窗口，二、按下键盘上的q键；模拟键盘输入可以完成第二步，但是完成不了第一步，因此这种方法在这里不起作用。\n至少，我在思考问题上，会多想一步了。但也陷进了路径依赖中！\n想让程序自己关闭的最快捷方式难道不应该是在程序内部实现嘛？而且很方便的只需要一个判断就行了，不然要你编码做何用？\n是啊，我忘记了，整个演示程序的代码都是我写的，那我想控制什么时候关闭，不是很容易嘛！（什么时候开启不太行，但用了上面的持续运行判断是可以的，因为开启需要从外界开启。断电的电脑怎么自动开机呢？但开机的电脑可以设置定时关闭，如此常识，自己之前咋就忘了呢。。。）\n所以，有时候可以让自己适当放空，然后重新梳理，一步一步来分析解决。\n路径依赖，说到底也是因为懒，能不能打破懒，还得看自己够不够狠心和韧性了，愈挫愈勇，这个方法不行，大不了从头来，用新的思路来解决！\n代码备忘录📝 // 获取当前时间 auto now = std::chrono::system_clock::now(); std::time_t now_c = std::chrono::system_clock::to_time_t(now); std::tm now_tm = *std::localtime(\u0026now_c); // 检查时间是否超过19:00 if (now_tm.tm_hour \u003e= 19) { std::cout \u003c\u003c \"Current time is \" \u003c\u003c std::put_time(\u0026now_tm, \"%F %T\") \u003c\u003c \", the machine need to rest, See you tomorrow!\" \u003c\u003c std::endl; running = false; } // 原来的手动关闭操作 int key = cv::waitKey(1); if (key == 'q' || key == 'Q') { running = false; } 结束语：继续坚持，从1到2到3，到100，到一直能坚持 人类最可贵的，不就是会思考嘛，机器智能只会越来越强盛的今后，尤其显得珍贵！\n继续坚持，明天再继续～\n2024年2月19日\n",
  "wordCount" : "4171",
  "inLanguage": "zh",
  "datePublished": "2024-02-19T10:50:57+08:00",
  "dateModified": "2024-02-19T10:50:57+08:00",
  "author":[{
    "@type": "Person",
    "name": "CKYoung"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ahaknow.com/posts/think/master-of-innovation-or-slave-of-repetition/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AhaKnow",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ahaknow.com/Q.gif"
    }
  }
}
</script>
    
    
    
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ahaknow.com/" accesskey="h" title="AhaKnow (Alt + H)">
                <img src="https://ahaknow.com/Q.gif" alt="" aria-label="logo"
                    height="35">AhaKnow</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ahaknow.com/search" title="🪄魔法 (Alt &#43; /)" accesskey=/>
                    <span>🪄魔法</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/" title="🏡主页">
                    <span>🏡主页</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/posts" title="🚀天天向上">
                    <span>🚀天天向上</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/archives" title="⏱️时间线">
                    <span>⏱️时间线</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/tags" title="🏷️标签">
                    <span>🏷️标签</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/categories" title="🖇归档">
                    <span>🖇归档</span>
                </a>
            </li>
            <li>
                <a href="https://ahaknow.com/toolkits" title="🧰医疗箱">
                    <span>🧰医疗箱</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ahaknow.com/">🏡主页</a>&nbsp;»&nbsp;<a href="https://ahaknow.com/posts/">🚀 天天向上</a>&nbsp;»&nbsp;<a href="https://ahaknow.com/posts/think/">💡思考</a></div>
    <h1 class="post-title entry-hint-parent">
      创新的主人还是重复的奴隶？
    </h1>
    <div class="post-meta">

























<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<span class="parent-post-meta">
        <span id="post_meta_style_1">
            <span class="fa fa-calendar-check-o"></span>
            <span>2024-02-19
                &nbsp;&nbsp;
            </span>
        </span>
        <span id="post_meta_style_2">
        <span class="fa fa-calendar-plus-o"></span>
        <span>2024-02-19
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>4171 字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>9 分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>CKYoung
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://ahaknow.com/tags/%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/" style="color: var(--secondary)!important;">思考记录</a>
            </span>
        </span>
    </span>
</span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">📚目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%ad%a3%e7%af%87%e6%84%8f%e8%af%86%e5%88%b0%e4%ba%86%e5%b0%b1%e7%ab%8b%e5%88%bb%e8%a1%8c%e5%8a%a8" aria-label="正篇：意识到了就立刻行动">正篇：意识到了就立刻行动</a></li>
                <li>
                    <a href="#%e5%90%88%e5%b9%b6%e7%aa%97%e5%8f%a3%e5%b0%86%e6%80%9d%e7%bb%b4%e6%89%93%e5%bc%80%e4%b8%8d%e8%a6%81%e5%b1%80%e9%99%90" aria-label="合并窗口：将思维打开，不要局限">合并窗口：将思维打开，不要局限</a><ul>
                        
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%a4%87%e5%bf%98%e5%bd%95" aria-label="代码备忘录📝">代码备忘录📝</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8f%90%e5%89%8d%e8%ae%be%e7%bd%ae%e7%aa%97%e5%8f%a3%e4%bd%8d%e7%bd%ae%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e4%b8%8d%e4%bb%a3%e8%a1%a8%e6%b2%a1%e6%9c%89%e4%bb%a5%e5%89%8d%e6%98%af%e6%90%9c%e7%b4%a2%e7%8e%b0%e5%9c%a8%e6%98%af%e9%97%ae" aria-label="提前设置窗口位置：不知道的不代表没有，以前是搜索，现在是“问”">提前设置窗口位置：不知道的不代表没有，以前是搜索，现在是“问”</a><ul>
                        
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%a4%87%e5%bf%98%e5%bd%95-1" aria-label="代码备忘录📝">代码备忘录📝</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%87%aa%e5%90%af%e5%8a%a8%e4%b8%8d%e6%87%82%e7%9a%84%e5%b0%b1%e5%a4%9a%e6%8e%a2%e7%a9%b6%e4%b8%8d%e8%a6%81%e6%98%af%e4%b8%80%e4%b8%aa%e5%8d%8a%e7%93%b6%e6%b0%b4%e5%93%8d%e5%8f%ae%e5%bd%93" aria-label="自启动：不懂的就多探究，不要是一个“半瓶水响叮当”">自启动：不懂的就多探究，不要是一个“半瓶水响叮当”</a><ul>
                        
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%a4%87%e5%bf%98%e5%bd%95-2" aria-label="代码备忘录📝">代码备忘录📝</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%87%aa%e5%85%b3%e9%97%ad%e8%84%91%e5%ad%90%e6%98%af%e8%b6%8a%e7%94%a8%e8%b6%8a%e7%81%b5%e5%85%89%e7%9a%84%e5%a4%9a%e6%83%b3%e6%83%b3%e4%b8%8d%e8%a6%81%e5%9b%ba%e5%8c%96%e4%b8%8d%e8%a6%81%e9%99%b7%e5%85%a5%e8%b7%af%e5%be%84%e4%be%9d%e8%b5%96" aria-label="自关闭：脑子是越用越灵光的，多想想，不要固化，不要陷入路径依赖">自关闭：脑子是越用越灵光的，多想想，不要固化，不要陷入路径依赖</a><ul>
                        
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%a4%87%e5%bf%98%e5%bd%95-3" aria-label="代码备忘录📝">代码备忘录📝</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bb%93%e6%9d%9f%e8%af%ad%e7%bb%a7%e7%bb%ad%e5%9d%9a%e6%8c%81%e4%bb%8e1%e5%88%b02%e5%88%b03%e5%88%b0100%e5%88%b0%e4%b8%80%e7%9b%b4%e8%83%bd%e5%9d%9a%e6%8c%81" aria-label="结束语：继续坚持，从1到2到3，到100，到一直能坚持">结束语：继续坚持，从1到2到3，到100，到一直能坚持</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
  <div class="post-content"><blockquote>
<p><strong>引子：</strong></p>
<p>做了一个实时展示的小程序，一开始做的比较粗糙，每次呢，也就是每天的早上，都需要手动去执行，然后用鼠标去一点点调整展示窗口的大小和排列，一共三个窗口，一大两小，排列方式是固定的，但是由于每次都是一点点拖动摆放，因此每一次自己都需要对排列后的样子有一个预期，尽可能调整成看上去还不错的样子，尽管如此这般，也很难做到每次的排列都相同。做到这里，虽然没用到多少时间，几分钟吧，但耗费了不少注意力，因为每天都要想着：早上的第一件事是做这个，而且很有可能哪一天就忘了。晚上的话，还要想着去关掉它，手动关闭，费不了多少时间，但同时消耗了不少注意力，原因和早上的一样：一整天的潜意识里都会挂念着，晚上了得把它关掉。如此，一日复一天，天天如此，重复着同样的工作，<strong>而且似乎并没有意识到什么问题……</strong></p>
</blockquote>
<p>都2024年了啊！还是个会敲代码的，天天就干这些事？不知道让这个小程序自己打开再自己关掉嘛？时间一直往前走，怎么写代码的意识还不如从前了呢！</p>
<p>是啊，已经不知不觉陷入了一种“忙忙碌碌，不思进取，每天做着同样的事，为了活着而活着的”行尸走肉之中了。一天，两天，一周，一个月，大半年，就是这么混过来的，有进步嘛？有一点，但仔细瞧瞧只不过是错觉，很可能还是个负方向的。有反思嘛？好像有过，但借口一句没时间啊就过去了，正如此时敲击着键盘，如果现在不写，那么可能又是，一天过去，一周过去，一个月过去，于是乎，2025年2月20日啦。<strong>确实很打脸，因为上一次想要写写文字反思的时候，是2023年2月18日，而当下此刻，是2024年2月19日。。。</strong></p>
<p>什么时候种树都不迟，只要你意识到了就抡起铲子！也许当下的形势让你觉得自己的所学一文不值，那么就立刻开始，多学习点，想学的就去学，从自己的所爱出发，而不是犹豫、惆怅，还徘徊……</p>
<p>说回来了，原本这一篇记录是想偏向于“自学的总结”，会涉及一些比较“专业”的东西，一些代码啊，一些指令啥的，昨晚借口一句：“困了先睡觉了”，就没写。欺骗自己说早上醒来写，实际上自己心里很清楚，大概率不可能。人的惰性太自然了，躺着多舒服啊，但如果一直躺着，那不如成为一具尸首。</p>
<h3 id="正篇意识到了就立刻行动">正篇：意识到了就立刻行动<a hidden class="anchor" aria-hidden="true" href="#正篇意识到了就立刻行动">#</a></h3>
<p>我知道此前的我，也是成了“每天重复做着同样工作”的讨厌样子了。</p>
<p>新的一年，那就由此改变吧！</p>
<p>实时展示的小程序是吧，加一个自动启动和退出的功能咯！怎么做呢？</p>
<p>我最开始的想法是将这个小程序软件化，也就是使用QT的可视化图形界面来改写，无奈，尝试了大半天，代码编译看着没问题了，但用不起来，这很大原因和自己没有系统学习有关。现在的chatGPT啊，写代码很厉害了，可能目前我的水平还比较低，用不好它，以至于说是让它辅助我改写，<strong>实际上我很多时候并不过脑子，直接复制粘贴</strong>，那哪行哦！这不就成了工具的奴隶了，连工具都不如了，这不更容易被食物链中的腐食者给吃了嘛。</p>
<p>于是，我开始想，能不能通过一些技巧来实现我的需求呢？这些技巧背后依赖的功能应该是存在的，但是我不知道，此时我就是可以通过chatGPT协助了。</p>
<ul>
<li>现在是三个窗口（此前实现的时候，使用了多线程，因此同时展示的问题是解决的），我能不能把窗口数量减少，<strong>比如两个小窗口直接合成成一个？</strong></li>
<li>之前每次手动打开都需要手动调整窗口大小和位置，<strong>能不能直接在代码中实现预先的设置呢？</strong></li>
<li>自动打开，Linux上似乎有守护进程可以？但是没有在这里尝试过（这个也是很古老的知识了，至少六年前我就用过），想到过，<strong>但是没有行动起来！！</strong></li>
<li>自动关闭呢？之前设置了通过键盘输入q实现程序的退出，<strong>能不能让Linux自动模拟键入q呢？</strong></li>
</ul>
<p>按照这个思路我就去做了～</p>
<h3 id="合并窗口将思维打开不要局限">合并窗口：将思维打开，不要局限<a hidden class="anchor" aria-hidden="true" href="#合并窗口将思维打开不要局限">#</a></h3>
<p>一开始，我是用两个窗口来同时显示两个图像的，最简单也是最笨的操作。为啥之前我就没有想到将两个图像放在一个窗口里呢？</p>
<ul>
<li>可能是思维惯性，<strong>之前怎么做的，就跟着怎么做了。</strong></li>
<li>也可能就是偷懒，<strong>从而导致的不动脑子，以及相应会产生的拖延。</strong></li>
</ul>
<p>认识到自己的思维存在僵化之后，开始改变：</p>
<p>首先想到，直接拼接两张图像，上下拼接就能完成。但是在显示上不友好，上下拼接后变成一个长方形了，但是由于显示器很大，把窗口拉长之后上下图居中在一起，上下有空白的，显得很丑，从美观的角度来看的话，如果两个拼接的图像在上下位置能够保证对称，比如上方、两图中间、下方各自留出一块空间，这样就看着舒服了。按照这个思路，那就改～</p>
<p>直接拼接不成，那就先考虑创建一个大的窗口，然后将两张图像分别搁进去，具体操作起来特别像前端的UI设计，要考虑padding的填充。这样的方法可行，然后还需要加入图像的标题，也采用往大窗口里搁置的思路，同样的，还是考虑了要设置padding的填充，使得标题能够局中。之后就是根据实际的情况，不断地调整窗口的尺寸，padding的大小，以达到自认为满意的比例了。至此，合并窗口完成了，现在的小程序只需要两个窗口就能满足了。</p>
<h4 id="代码备忘录">代码备忘录📝<a hidden class="anchor" aria-hidden="true" href="#代码备忘录">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">merged_image</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">left_image_color_global</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">left_image_color_global</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">disparity_color_global</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">disparity_color_global</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">space</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>                      <span class="c1">// 标题和图像之间的空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">test_height</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>                <span class="c1">// 文本标题的高度（大致估计）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">textColor</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span> <span class="c1">// 文本颜色
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">font_face</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">FONT_HERSHEY_SIMPLEX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">font_scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">thickness</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">top_padding</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">between_padding</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">bottom_padding</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">merged_height</span> <span class="o">=</span> <span class="n">left_image_color_global</span><span class="o">-&gt;</span><span class="n">rows</span> <span class="o">+</span> <span class="n">disparity_color_global</span><span class="o">-&gt;</span><span class="n">rows</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">space</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">test_height</span> <span class="o">+</span> <span class="n">top_padding</span> <span class="o">+</span> <span class="n">bottom_padding</span> <span class="o">+</span> <span class="n">between_padding</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">merged_width</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">left_image_color_global</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span> <span class="n">disparity_color_global</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">merged_image</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="n">merged_height</span><span class="p">,</span> <span class="n">merged_width</span><span class="p">,</span> <span class="n">left_image_color_global</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绘制第一个图像和标题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">title1_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">merged_width</span> <span class="o">-</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTextSize</span><span class="p">(</span><span class="s">&#34;Left Image&#34;</span><span class="p">,</span> <span class="n">font_face</span><span class="p">,</span> <span class="n">font_scale</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">).</span><span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv</span><span class="o">::</span><span class="n">putText</span><span class="p">(</span><span class="n">merged_image</span><span class="p">,</span> <span class="s">&#34;Left Image&#34;</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">title1_x</span><span class="p">,</span> <span class="n">test_height</span><span class="p">),</span> <span class="n">font_face</span><span class="p">,</span> <span class="n">font_scale</span><span class="p">,</span> <span class="n">textColor</span><span class="p">,</span> <span class="n">thickness</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">left_image_color_global</span><span class="o">-&gt;</span><span class="n">copyTo</span><span class="p">(</span><span class="n">merged_image</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">top_padding</span> <span class="o">+</span> <span class="n">test_height</span> <span class="o">+</span> <span class="n">space</span><span class="p">,</span> <span class="n">left_image_color_global</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span> <span class="n">left_image_color_global</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 绘制第二个图像和标题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">title2_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">merged_width</span> <span class="o">-</span> <span class="n">cv</span><span class="o">::</span><span class="n">getTextSize</span><span class="p">(</span><span class="s">&#34;Dense Disparity&#34;</span><span class="p">,</span> <span class="n">font_face</span><span class="p">,</span> <span class="n">font_scale</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">).</span><span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">merged_mid</span> <span class="o">=</span> <span class="n">left_image_color_global</span><span class="o">-&gt;</span><span class="n">rows</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">space</span> <span class="o">+</span> <span class="n">test_height</span> <span class="o">+</span> <span class="n">top_padding</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cv</span><span class="o">::</span><span class="n">putText</span><span class="p">(</span><span class="n">merged_image</span><span class="p">,</span> <span class="s">&#34;Dense Disparity&#34;</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">title2_x</span><span class="p">,</span> <span class="n">merged_mid</span> <span class="o">+</span> <span class="n">test_height</span><span class="p">),</span> <span class="n">font_face</span><span class="p">,</span> <span class="n">font_scale</span><span class="p">,</span> <span class="n">textColor</span><span class="p">,</span> <span class="n">thickness</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">disparity_color_global</span><span class="o">-&gt;</span><span class="n">copyTo</span><span class="p">(</span><span class="n">merged_image</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">merged_mid</span> <span class="o">+</span> <span class="n">bottom_padding</span> <span class="o">+</span> <span class="n">test_height</span> <span class="o">+</span> <span class="n">space</span><span class="p">,</span> <span class="n">disparity_color_global</span><span class="o">-&gt;</span><span class="n">cols</span><span class="p">,</span> <span class="n">disparity_color_global</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="提前设置窗口位置不知道的不代表没有以前是搜索现在是问">提前设置窗口位置：不知道的不代表没有，以前是搜索，现在是“问”<a hidden class="anchor" aria-hidden="true" href="#提前设置窗口位置不知道的不代表没有以前是搜索现在是问">#</a></h3>
<p>设置好窗口大小之后，还需要能够实现打开小程序后，两个窗口能够自动“站”到合适的位置。<mark>应该是有这样的方法的，只不过是我不知道，在没有chatGPT之前，可以用Google进行搜索，现在有了chatGPT，只要将需求描述清楚，一般互联网上已有的信息就能够获取到。</mark>因此我就直接“问”了有没有这样的方法，果然，有的，而且还很简洁。</p>
<blockquote>
<p><strong>忽然想到一点，这个不就是信息差嘛！以前靠信息差吃某一种职位铁饭碗的想法应该在此之后自己消亡了吧？也许不会，因为好逸恶劳，因为懒惰，因为路径依赖？总之，现在自己意识到了还不算迟。</strong></p>
</blockquote>
<p>所以，很可能以后还是很缺“产品经理、项目经理”这种明确知道需求是什么的，能够用精炼的语言将其描述清楚的总揽全局的人，而不缺重复的、低级的、复制粘贴的所谓“程序员”码农。</p>
<h4 id="代码备忘录-1">代码备忘录📝<a hidden class="anchor" aria-hidden="true" href="#代码备忘录-1">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">cv</span><span class="o">::</span><span class="n">namedWindow</span><span class="p">(</span><span class="s">&#34;Color &amp; Disparity&#34;</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">WINDOW_NORMAL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">cv</span><span class="o">::</span><span class="n">resizeWindow</span><span class="p">(</span><span class="s">&#34;Color &amp; Disparity&#34;</span><span class="p">,</span> <span class="mi">1548</span><span class="p">,</span> <span class="mi">2160</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">cv</span><span class="o">::</span><span class="n">moveWindow</span><span class="p">(</span><span class="s">&#34;Color &amp; Disparity&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 将窗口移动到左上角
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// ----------------------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1">// 创建点云可视化器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">viewer</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span><span class="p">(</span><span class="s">&#34;Dense PointCloud Viewer&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">viewer</span><span class="o">-&gt;</span><span class="n">setBackgroundColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addPointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="o">&gt;</span><span class="p">(</span><span class="n">point_cloud_ptr_global</span><span class="p">,</span> <span class="s">&#34;Dense PointCloud&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">viewer</span><span class="o">-&gt;</span><span class="n">setPointCloudRenderingProperties</span><span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCL_VISUALIZER_POINT_SIZE</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#34;Dense PointCloud&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">viewer</span><span class="o">-&gt;</span><span class="n">initCameraParameters</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">viewer</span><span class="o">-&gt;</span><span class="n">setCameraPosition</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span>         <span class="c1">// 控制相机的XYZ位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="mi">0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">  	<span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> 						<span class="c1">// 后面点云转了旋转，这里Y为1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">viewer</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="mi">2220</span><span class="p">,</span> <span class="mi">2160</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 因为使用了VTK的窗口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vtkSmartPointer</span><span class="o">&lt;</span><span class="n">vtkRenderWindow</span><span class="o">&gt;</span> <span class="n">renderWindow</span> <span class="o">=</span> <span class="n">viewer</span><span class="o">-&gt;</span><span class="n">getRenderWindow</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">renderWindow</span><span class="o">-&gt;</span><span class="n">SetPosition</span><span class="p">(</span><span class="mi">1900</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></div><h3 id="自启动不懂的就多探究不要是一个半瓶水响叮当">自启动：不懂的就多探究，不要是一个“半瓶水响叮当”<a hidden class="anchor" aria-hidden="true" href="#自启动不懂的就多探究不要是一个半瓶水响叮当">#</a></h3>
<p>之前知道一种方法是用守护进程：通过<code>crontab -e</code>进行设置，我也用这个方法尝试了，发现不起作用。分析原因得到：</p>
<blockquote>
<p>因为，我启动的小程序需要调用显示窗口，OpenCV提供的简易窗口和VTK提供的可视化窗口，而守护进程启动命令时，是一种“文本”方式，无法唤起显示的窗口。</p>
<p>**以前在服务器上用crontab自启动一些命令，因为只会有文本输出，比较简易，那会儿使用远程服务器，自然也不会涉及显示，也就忽略了这个问题。**所以，我此前对于守护进程的理解还只是皮毛，今天多了一些使用的经验。但更重要的是从这次的经历中学会一些“遇到问题、分析现象、思考解决”的思维。</p>
</blockquote>
<p>发现这条路走不通，于是，<strong>将自己的需求重新整理了一遍：</strong></p>
<p><strong>“我希望在当前显示器下，当前的命令行终端下，定时地执行某一个命令”</strong></p>
<p>在这个思路下，找到了一个可行的方式：</p>
<p>在终端中，持续运行一个判断：<strong>获取当前时间，判断是否等于设定的需要自动打开的时间，如果是就执行命令，然后之后一段时间里不再执行。</strong></p>
<p>在Linux环境下，这个判断可以比较直接的实现：通过Bash脚本的方式。（本质就是Bash脚本自动化）</p>
<p>这里明白了一点，一条路走不通很可能是这路条本身就不对，因为很多时候对一项事物也是处于一种了解皮毛的状态，所以遇到问题了要学会打破“自以为是”，从整体的层面来进行分析，对于这里的问题就是：“守护进程不行，为啥不行，那我把运行的日志打印出来，然后分析一下错误信息，再考虑这种方法是不是本身就不支持。”</p>
<h4 id="代码备忘录-2">代码备忘录📝<a hidden class="anchor" aria-hidden="true" href="#代码备忘录-2">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="nv">TARGET_TIME</span><span class="o">=</span><span class="s2">&#34;09:00&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span> true<span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="nv">CURRENT_TIME</span><span class="o">=</span><span class="k">$(</span>date +%H:%M<span class="k">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$CURRENT_TIME</span><span class="s2">&#34;</span> <span class="o">==</span> <span class="s2">&#34;</span><span class="nv">$TARGET_TIME</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        /home/metoak/Projects/RealTimeDensePointCloud/C++/build/tensorrt_inference_one_camera /home/metoak/Projects/RealTimeDensePointCloud/C++/models/model_mobilev2_960_512.trt <span class="m">960</span> <span class="m">512</span>
</span></span><span class="line"><span class="cl">        sleep <span class="m">60</span>  <span class="c1"># 避免在目标时间多次执行</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">    sleep <span class="m">30</span>  <span class="c1"># 每30秒检查一次时间</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span></code></pre></div><h3 id="自关闭脑子是越用越灵光的多想想不要固化不要陷入路径依赖">自关闭：脑子是越用越灵光的，多想想，不要固化，不要陷入路径依赖<a hidden class="anchor" aria-hidden="true" href="#自关闭脑子是越用越灵光的多想想不要固化不要陷入路径依赖">#</a></h3>
<p>在这里遇到的问题和自启动时差不多。在最开始实现时，也想到了要实现手动关闭，所以就设置了一个通过键盘关闭的方法。我在想能不能自动关闭时，也就顺着这个思路走下去了：“能不能用指令来模拟键盘输入，来达到跟手动按下键盘一样的效果呢？</p>
<p>想法是好的，也通过chatGPT进行“询问”和尝试，是有这种方法的，但是无法应用在这个问题的解决上。原因简单分析如下：</p>
<blockquote>
<p>通过一个指令或者一个程序模拟键盘输入，它所生效的位置是这个指令或者程序运行的空间；而我通过键盘控制关闭时，实际上是做了两件事：一、先选中窗口，二、按下键盘上的q键；模拟键盘输入可以完成第二步，但是完成不了第一步，因此这种方法在这里不起作用。</p>
</blockquote>
<p>至少，我在思考问题上，会多想一步了。<strong>但也陷进了路径依赖中！</strong></p>
<p><strong>想让程序自己关闭的最快捷方式难道不应该是在程序内部实现嘛？而且很方便的只需要一个判断就行了，不然要你编码做何用？</strong></p>
<p>是啊，我忘记了，整个演示程序的代码都是我写的，<strong>那我想控制什么时候关闭，不是很容易嘛！（什么时候开启不太行，但用了上面的持续运行判断是可以的，因为开启需要从外界开启。断电的电脑怎么自动开机呢？但开机的电脑可以设置定时关闭，如此常识，自己之前咋就忘了呢。。。）</strong></p>
<p>所以，有时候可以让自己适当放空，然后重新梳理，一步一步来分析解决。</p>
<p><strong>路径依赖，说到底也是因为懒，能不能打破懒，还得看自己够不够狠心和韧性了，愈挫愈勇，这个方法不行，大不了从头来，用新的思路来解决！</strong></p>
<h4 id="代码备忘录-3">代码备忘录📝<a hidden class="anchor" aria-hidden="true" href="#代码备忘录-3">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 获取当前时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">time_t</span> <span class="n">now_c</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">tm</span> <span class="n">now_tm</span> <span class="o">=</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now_c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 检查时间是否超过19:00
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">now_tm</span><span class="p">.</span><span class="n">tm_hour</span> <span class="o">&gt;=</span> <span class="mi">19</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Current time is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">put_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now_tm</span><span class="p">,</span> <span class="s">&#34;%F %T&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, the machine need to rest, See you tomorrow!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 原来的手动关闭操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="sc">&#39;q&#39;</span> <span class="o">||</span> <span class="n">key</span> <span class="o">==</span> <span class="sc">&#39;Q&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="结束语继续坚持从1到2到3到100到一直能坚持">结束语：继续坚持，从1到2到3，到100，到一直能坚持<a hidden class="anchor" aria-hidden="true" href="#结束语继续坚持从1到2到3到100到一直能坚持">#</a></h3>
<p>人类最可贵的，不就是会思考嘛，机器智能只会越来越强盛的今后，尤其显得珍贵！</p>
<p>继续坚持，明天再继续～</p>
<p><strong>2024年2月19日</strong></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ahaknow.com/tags/%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/">思考记录</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://ahaknow.com/posts/think/2024-begin-again/">
    <span class="title">« 上一页</span>
    <br>
    <span>折腾博客是为了更好地专注在写作上？</span>
  </a>
  <a class="next" href="https://ahaknow.com/posts/diary/2024_first/">
    <span class="title">下一页 »</span>
    <br>
    <span>2024年的第一篇记录</span>
  </a>
</nav>

  </footer>
</article>
</main>

<footer class="footer">
    <span>&copy; 2024 <a href="https://ahaknow.com/">AhaKnow</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/IHKYoung/CKPaper/" rel="noopener" target="_blank">CKPaper</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '🖨️打印';

        function copyingDone() {
            copybutton.innerHTML = '📋备份';
            setTimeout(() => {
                copybutton.innerHTML = '🖨️打印';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                
                
                let copyText = codeblock.textContent + '\r\n————————————————\r\n' + '版权声明：本文为「'+"AhaKnow"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' + '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(copyText);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        document.querySelectorAll('pre > code[class*="language-"]').forEach(function(codeblock) {
            
            
            let language = codeblock.className.match(/language-(\w+)/)[1] || "code";

            
            let macCodeBlock = document.createElement("div");
            let macButtons = document.createElement("div");
            let buttons = ['close', 'minimize', 'maximize'].map(function(className) {
                let button = document.createElement("div");
                button.setAttribute('class', `mac-button ${className}`);
                return button;
            });
            let languageType = document.createElement("div");
            languageType.innerText = language;
            languageType.setAttribute('class', 'language-type');

            
            macButtons.setAttribute('class', 'mac-buttons');
            buttons.forEach(function(button) {
                macButtons.appendChild(button);
            });
            macCodeBlock.appendChild(macButtons);
            macCodeBlock.appendChild(languageType);
            macCodeBlock.setAttribute('class', 'mac-code-block');

            
            codeblock.parentNode.insertBefore(macCodeBlock, codeblock);
        });
    });
</script>


</body>

</html>
