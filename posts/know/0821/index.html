<!DOCTYPE html>
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\[','\]']],
      }
    });
</script>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>📝0821：Linux随手记📝 | AhaKnow</title>
<meta name="keywords" content="Linux, DeepLearning">
<meta name="description" content="磁盘相关 查看挂载盘的文件格式: 可以使用df命令配合-T选项来查看挂载盘的文件格式。例如： 1 df -T 或者使用lsblk命令配合-f选项： 1 lsblk -f 修改">
<meta name="author" content="YOUNG">
<link rel="canonical" href="http://ahaknow.com/posts/know/0821/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="http://ahaknow.com/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="http://ahaknow.com/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="http://ahaknow.com/Q.gif">
<link rel="apple-touch-icon" href="http://ahaknow.com/Q.gif">
<link rel="mask-icon" href="http://ahaknow.com/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="📝0821：Linux随手记📝" />
<meta property="og:description" content="磁盘相关 查看挂载盘的文件格式: 可以使用df命令配合-T选项来查看挂载盘的文件格式。例如： 1 df -T 或者使用lsblk命令配合-f选项： 1 lsblk -f 修改" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://ahaknow.com/posts/know/0821/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-21T21:05:23+08:00" />
<meta property="article:modified_time" content="2023-08-21T21:05:23+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="📝0821：Linux随手记📝"/>
<meta name="twitter:description" content="磁盘相关 查看挂载盘的文件格式: 可以使用df命令配合-T选项来查看挂载盘的文件格式。例如： 1 df -T 或者使用lsblk命令配合-f选项： 1 lsblk -f 修改"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📚专栏",
      "item": "http://ahaknow.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "🌟知识",
      "item": "http://ahaknow.com/posts/know/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "📝0821：Linux随手记📝",
      "item": "http://ahaknow.com/posts/know/0821/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "📝0821：Linux随手记📝",
  "name": "📝0821：Linux随手记📝",
  "description": "磁盘相关 查看挂载盘的文件格式: 可以使用df命令配合-T选项来查看挂载盘的文件格式。例如： 1 df -T 或者使用lsblk命令配合-f选项： 1 lsblk -f 修改",
  "keywords": [
    "Linux", "DeepLearning"
  ],
  "articleBody": "磁盘相关 查看挂载盘的文件格式: 可以使用df命令配合-T选项来查看挂载盘的文件格式。例如：\n1 df -T 或者使用lsblk命令配合-f选项：\n1 lsblk -f 修改挂载盘的名字: 可以使用e2label命令来修改一个ext2/ext3/ext4文件系统的标签。例如，如果想将/dev/sda1的标签更改为“新名字”，你可以运行：\nbash\n1 sudo e2label /dev/sda1 新名字 如果文件系统不是ext类型，可以使用对应的标签命令，例如对于FAT文件系统，可以使用dosfslabel。\n可以使用exfatlabel命令来更改exFAT文件系统的标签。以下是更改exFAT文件系统标签的命令示例：\n1 sudo exfatlabel /dev/sda1 CKData 确保系统中已安装了支持exFAT文件系统的工具，否则需要首先安装它们\n1 sudo apt-get install exfat-fuse exfat-utils 或\n1 sudo apt install exfatprogs 将挂载盘格式化成ext4: 使用mkfs.ext4命令来格式化挂载盘。请注意，这将删除该分区上的所有数据，因此请确保先备份任何重要数据。假设要格式化的盘符是/dev/sda1，则命令如下：\n1 sudo mkfs.ext4 /dev/sda1 重新格式化为exFAT文件系统：\n以下是格式化分区/dev/sda1为exFAT文件系统的步骤：\n首先，确保已经卸载了要格式化的分区。可以使用umount命令来卸载分区：\n1 sudo umount /dev/sda1 然后，可以使用mkfs.exfat命令来格式化分区。如果需要指定卷标（例如“CKData”），可以使用-n选项：\n1 sudo mkfs.exfat -n \"CKData\" /dev/sda1 如果系统上没有mkfs.exfat命令，需要安装支持exFAT的软件包：\n1 sudo apt-get install exfat-utils 或\n1 sudo apt install exfatprogs 关于磁盘的label和partition 磁盘的分区和标签是计算机存储系统的不同层次和方面\n磁盘：磁盘是物理存储设备，可以包括硬盘驱动器（HDD）、固态硬盘（SSD）等。一个磁盘可以分为多个部分，称为分区。\n分区：分区是磁盘上的连续空间段，它可以被格式化为特定的文件系统，例如ext4、exFAT等。分区允许在同一物理磁盘上运行多个不同的文件系统，或者逻辑上将磁盘划分为不同的部分。\n标签（Label）：标签是给磁盘或分区分配的可选名称，可以使其更容易识别。例如，可以给存储音乐文件的分区命名为“Music”。\nLinux开机自动挂载 可以通过修改/etc/fstab文件来实现。以下是步骤：\n找到分区的UUID：使用以下命令找到分区的UUID（Universally Unique Identifier）：\n1 sudo blkid 寻找要挂载的分区相对应的UUID。\n创建挂载点：选择或创建一个目录作为挂载点。例如，如果要将分区挂载到/media/mydrive，确保该目录存在：\n1 sudo mkdir -p /media/mydrive 编辑/etc/fstab文件：使用文本编辑器（如nano或vi）打开/etc/fstab文件：\n1 sudo nano /etc/fstab 在文件的末尾添加一行，用以下格式：\n1 UUID=your-uuid-here /media/mydrive ext4 defaults 0 0 这里的your-uuid-here是从blkid命令中获取的UUID。将ext4替换为分区使用的文件系统类型。\n挂载分区：保存并关闭文件，然后运行以下命令来挂载分区：\n1 sudo mount -a 现在，该分区应该每次开机时都会自动挂载到指定的挂载点。\n至于挂载点的问题，如果想要将分区自动挂载到/media/下的某个子目录中，可以在/etc/fstab文件中指定挂载点。\n例如，可以在/etc/fstab文件中使用以下条目：\n1 UUID=your-uuid-here /media/your-drive-label ext4 defaults 0 0 需要替换your-uuid-here和your-drive-label为相应的UUID和想要的挂载点名字。\n软连接 软连接，又称符号链接（symbolic link），在Linux和UNIX系统中是一个特殊类型的文件，该文件包含对其他文件或目录的引用。\n软连接可以指向同一文件系统内的文件或目录，也可以指向其他文件系统内的文件或目录。\n以下是软连接的常见用法：\n创建软连接： 使用ln命令，加上-s选项来创建软连接。例如，要创建一个指向/mnt/disk/yck的软连接yck，可以使用以下命令：\n1 ln -s /mnt/disk/yck yck 理解软连接： 软连接类似于Windows中的快捷方式，它只是一个引用，指向实际文件或目录的路径。如果删除软连接，原始文件或目录不会受到影响。但是，如果删除了软连接所指向的原始文件或目录，则软连接将变为\"悬挂\"，即失效的链接。\n删除软连接： 要删除软连接，可以使用rm命令，就像删除普通文件一样。例如，删除上面创建的yck软连接：\n1 rm yck 查看软连接： 使用ls -l命令，可以查看软连接的详细信息，其中会显示软连接指向的原始路径。\n注意，当操作软连接时，大多数命令（例如cat、cd、cp等）都会自动\"跟随\"软连接，即操作软连接背后的实际文件或目录。但是，删除软连接时需要特别小心，确保只删除软连接本身，而不是其背后的实际文件或目录。\n补充：\n软链接可以被视为一个特殊类型的文件，它包含了对目标文件或目录的引用。可以使用普通的文件命令（如ls，cat等）与软链接进行交互。 即使使用rm -rf yck，删除的也只是软连接 由于软链接是一个文件，所以创建时有同名的路径的话，会在路径下创建！ 查看文件占据大小 在Linux终端中，如果想要查看当前目录下文件所占据的大小，可以使用du和ls命令。\n使用du命令: du是\"disk usage\"的缩写，用于估计文件和目录的磁盘使用空间。\n如果想查看当前目录下的每个文件和文件夹的大小，可以使用以下命令：\n1 du -sh * 这里的-s选项表示只显示每个参数的总和，而-h选项则以人类可读的格式显示大小（例如，KB、MB、GB等）。\n使用ls命令: 还可以使用ls命令的-l和-h选项来查看文件大小。\n1 ls -lh 这里的-l选项表示长格式列出信息，-h选项表示以人类可读的格式显示大小。\n上述两个方法的差别在于du可以显示目录的整体大小，而ls主要关注单个文件的大小。\n💡查找指定文件大小的脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/bin/bash if [ \"$#\" -ne 2 ]; then echo \"Usage: $0 \" exit 1 fi directory=$1 file_size=$2 # 创建一个临时文件来保存查找结果 temp_file=$(mktemp) # 使用find命令查找文件，并将结果存储在临时文件中 # -print0和xargs -0一起使用，以便正确处理文件名中包含特殊字符的文件 sudo find \"$directory\" -type f -size +\"$file_size\" -exec ls -lh {} \\; | tee /dev/stderr | sort -rh -k5 \u003e \"$temp_file\" # 打印出分隔行 echo \"-------------======================================================-------------\" # 打印排序后的结果 cat \"$temp_file\" # 删除临时文件 rm \"$temp_file\" 通过网络实现硬盘挂载（NFS） NFS（Network File System）\n这里说的是最简单的形式：本地局域网+硬盘挂载\n基本步骤 服务端设置 首先，在共享磁盘的服务器上，需要安装NFS服务并配置共享目录。以下是基本步骤：\n安装NFS服务：\n1 2 sudo apt-get install nfs-kernel-server # 在Debian/Ubuntu系统中 sudo yum install nfs-utils # 在RedHat/Fedora系统中 编辑配置文件：\n打开/etc/exports文件并添加以下行（将/path/to/shared/directory替换为需要共享的目录路径）：\n1 /path/to/shared/directory *(rw,sync,no_subtree_check) 启动NFS服务：\n1 sudo systemctl restart nfs-kernel-server 如果修改了/etc/exports，可以使用sudo exportfs -ra\n客户端设置 接下来，在想要挂载共享目录的客户端机器上进行以下操作：\n安装NFS客户端工具：\n1 2 sudo apt-get install nfs-common # 在Debian/Ubuntu系统中 sudo yum install nfs-utils # 在RedHat/Fedora系统中 挂载远程目录：\n将共享目录挂载到本地目录（例如/mnt/remote）：\n1 sudo mount -t nfs server_ip:/path/to/shared/directory /mnt/remote 📝细节讨论 参数说明 1 /path/to/shared/directory *(rw,sync,no_subtree_check) rw: 这个选项允许远程客户端对共享目录进行读写操作。如果想让共享目录只能读取，可以使用ro选项。\nsync: 这个选项确保在请求完成之前，所有的文件系统操作都被物理写入磁盘。这样可以确保数据的一致性，但可能会稍微降低性能。如果选择async选项，则操作可能会在数据还未完全写入磁盘时返回，这可能会提高性能，但如果在数据完全写入之前系统崩溃，则可能会丢失数据。\nno_subtree_check: 这个选项禁用子树检查。当文件被移动或删除时，NFS会进行子树检查来确保文件的一致性。禁用此检查可能会提高性能。如果没有这个特定需求，通常建议使用此选项。\n补充：\nno_root_squash: 默认情况下，远程系统上的root用户映射为匿名用户。使用no_root_squash选项允许远程root用户以本地root权限执行操作。 secure: 使用这个选项将强制NFS请求从安全的端口（小于1024）发送。这有助于提高安全性。 all_squash: 这个选项将远程用户的所有操作映射为本地匿名用户，提供了更严格的权限控制。 anonuid 和 anongid: 这些选项允许指定匿名用户和组的UID和GID，通常与all_squash一起使用。 insecure: 允许客户端从大于1024的非安全端口连接。 举例\n在/etc/exports文件中配置NFS共享，可以使用这些选项来控制共享的行为。例如：\n1 /path/to/shared/directory *(rw,sync,no_subtree_check,no_root_squash) 这个例子中，共享目录允许读写、同步写入、禁用子树检查，并允许远程root用户以本地root权限操作。\n强调‼️\nanonuid 和 anongid 这两个选项允许指定服务器端的用户ID（UID）和组ID（GID）。\n当使用 all_squash 选项将所有远程用户的操作映射为本地匿名用户时，可以通过这两个选项设置该匿名用户和组的具体UID和GID。\n例如：\n1 /path/to/shared/directory *(rw,all_squash,anonuid=1003,anongid=1003) 在这个例子中，所有远程用户访问 /path/to/shared/directory 的操作都会被映射为本地服务器上UID和GID都为1003的用户和组。这样可以提供更精确的权限控制，确保远程访问的权限与本地特定用户和组的权限相匹配。\n这样的配置可以确保远程用户不会具有比所指定的本地用户更多的权限，从而增加了系统的安全性。\n也就是说：\n当客户端挂载远程NFS共享时，客户端上的用户权限是由客户端自身的操作系统和配置决定的。然而，当客户端与NFS服务器进行交互时，服务器上的anonuid和anongid设置（与all_squash选项结合使用）会将所有客户端用户的操作映射到指定的本地服务器用户和组上。\n例如，如果NFS共享配置为：\n1 /path/to/shared/directory *(rw,all_squash,anonuid=1003,anongid=1003) 那么无论客户端上的用户是谁，他们通过这个共享访问服务器上的文件时，都会被服务器视为UID为1003和GID为1003的本地用户和组。服务器上的文件权限会按照这个UID和GID来应用。\n因此，通过这种方式，服务器可以精确地控制远程客户端对共享资源的访问权限，而不必依赖于客户端上的用户配置。\nNAF和NAS NFS（Network File System）和NAS（Network Attached Storage）确实在功能和用途上有一些相似之处，但它们在实现和目的方面存在显著的区别。以下是它们之间的主要差异：\nNFS（Network File System）网络文件系统\n定义与功能: NFS是一种分布式文件系统协议，允许客户端通过网络访问服务器上的文件，就像访问本地文件一样。 适用场景: NFS通常用于组织或企业环境中，用于在不同系统之间共享文件和数据。 依赖性: NFS是一种协议，需要在现有的服务器和客户端操作系统上安装和配置。NFS不是一个独立的存储设备。 性能和灵活性: NFS允许灵活的配置和优化，可以根据具体需求调整性能和安全性。 跨平台: NFS支持各种操作系统，允许不同类型的客户端访问共享文件。 NAS（Network Attached Storage）网络连接存储\n定义与功能: NAS是一种独立的存储设备，通过网络提供文件存储和共享服务。NAS不仅包括硬件存储设备，还包括内置的操作系统和文件服务功能。\n适用场景: NAS用于家庭和企业环境中，为多个用户提供集中存储和共享文件的解决方案。NAS通常更易于设置和管理。\n自包含性: NAS是一个完整的存储解决方案，包括硬件、软件和所有必要的接口。用户只需将NAS连接到网络并进行简单配置。\n性能和灵活性: 与NFS相比，NAS可能更关注易用性和可靠性。某些高端NAS设备允许高级配置，但普通消费级NAS可能提供的配置选项较少。\n协议支持: NAS通常支持多种文件共享协议，包括NFS、SMB/CIFS等，因此可以与多种操作系统兼容。\n总结\nNFS是一种协议，用于允许跨网络的文件共享，可以在现有硬件和操作系统上配置。 NAS是一个完整的存储解决方案，包括硬件和软件，用于通过网络提供文件存储和共享服务。 NFS更灵活和高效，适用于对性能和配置有特殊需求的组织。 NAS通常更易于安装和管理，适用于需要集中存储和共享文件的家庭和小型企业。 NAF磁盘的文件系统 有一个观点： “exFAT可能不适合作为NFS共享的文件系统”\n下面，了解一下文件系统的基本常识：\nWindows文件系统 FAT (File Allocation Table)\n文件分配表（FAT）是Microsoft早期的文件系统，适用于简单的存储需求。 结构: FAT使用文件分配表来跟踪磁盘上文件的位置。它是一种简单的结构，没有许多现代文件系统的特性。 碎片: 因为FAT缺乏高级的空间管理，所以文件碎片化是一个问题。\n大小限制: FAT32有4GB的文件大小限制和2TB的卷大小限制。\nexFAT与FAT32的主要区别:\n文件大小限制:\nFAT32: 单个文件最大4GB。 exFAT: 单个文件最大可以达到16EB（百亿兆字节）。 分区大小限制:\nFAT32: 单个分区最大2TB。 exFAT: 没有明显的实际分区大小限制。 性能: exFAT通常在处理大文件和大分区时具有更高的效率，因为它采用了更先进的数据结构。\n兼容性:\nFAT32: 在各种操作系统中的支持更广泛。 exFAT: 主要为现代操作系统设计，不一定适用于较旧的系统。 功能: exFAT添加了一些改进，例如时间戳支持以及更有效的空间利用，但依然没有像EXT4或NTFS那样的先进功能。\nNTFS (New Technology File System)\n新技术文件系统（NTFS）是Windows的主要文件系统。它具有许多现代功能，如文件压缩、加密和详细的权限管理。 日志功能: NTFS使用日志记录文件操作，增加了可靠性和恢复能力。 权限管理: 它支持详细的访问控制列表（ACL）。\n压缩和加密: NTFS支持本地文件压缩和加密。\n元数据: NTFS存储关于文件的大量元数据，包括安全信息、归属和更多。\nexFAT（扩展文件分配表）是为了优化闪存存储，如USB闪存驱动器和SD卡而设计的。它比FAT32现代，可以支持更大的文件和卷。\n不足之处：\n没有日志功能: exFAT没有日志功能，这意味着如果在写操作过程中出现断电或崩溃等情况，可能会导致文件系统损坏。\n没有本地权限管理: exFAT没有本地文件和文件夹级别的权限管理，这在共享环境中可能是一个限制。\n性能问题: exFAT是为闪存驱动器（如SD卡和USB闪存驱动器）优化的文件系统，因此，其性能可能不如专为高速硬盘和网络存储解决方案设计的文件系统。在高负载或需要频繁读写的网络环境下，exFAT可能会遇到性能瓶颈。\n不是原生支持: 尽管exFAT是一种在Windows、macOS和一些Linux发行版之间通用的文件系统，但不是所有的Linux系统都原生支持exFAT\nLinux文件系统 Linux的扩展文件系统。ext3是ext2的一个升级，增加了日志功能。ext4进一步增加了性能和可靠性改进。\next2\n非日志: ext2是Linux的第一个扩展文件系统，没有日志功能。\n块组: 文件和目录在块组中存储，有助于减少碎片化。\n大小限制: 文件大小最多可以达到2TB，卷大小最多可以达到32TB。\next3\n日志功能: 在ext2的基础上增加了日志功能，提高了可靠性。\n兼容性: 与ext2向后兼容。\next4\n子卷: 支持多达64k的子卷。\n预分配: 可以在创建文件之前预分配空间。\n延迟分配: 通过延迟分配磁盘空间，提高了写入性能。\nXFS, Btrfs等\nXFS: 是一种高性能的日志文件系统，特别适合大型文件。\nBtrfs: 提供了卷快照、数据完整性检查和更多现代功能。\n为什么EXT4可能更适合网络硬盘：\n日志功能: EXT4使用日志来记录文件操作，有助于数据恢复和完整性，在系统崩溃或断电时更可靠。\n权限管理: EXT4支持复杂的文件权限和所有权管理，有助于在网络环境中实施合适的访问控制。\n性能: EXT4针对Linux优化，通常在Linux服务器上表现更好，特别是在高负载环境下。\n高级功能: EXT4支持一些高级功能，如数据压缩、加密和快照等。\n成熟与稳定: EXT4是Linux主流的文件系统之一，被广泛用于各种用途，包括网络存储，因此在支持和稳定性方面更有保障。\nmacOS文件系统 HFS+ (Hierarchical File System Plus)\n层次文件系统加（HFS+），苹果早期的文件系统。 碎片化: 有时可能需要碎片整理。 不支持一些现代功能: 例如没有本地压缩和加密支持。 APFS (Apple File System)\n苹果文件系统（APFS）是macOS High Sierra及更高版本的默认文件系统。它针对闪存/SSD存储进行了优化，并增加了加密等现代功能。 优化闪存: 专门针对SSD和闪存驱动器优化。 空间共享: 允许多个卷共享同一个底层存储空间。\n快照: 支持卷和文件系统的快照。\n数据完整性: 通过校验和保护数据的完整性。\nLinux权限问题 先从用户和组的区别来理解：\n用户（User） 在Linux中，每个用户都有一个唯一的用户ID（UID）。有三种主要类型的用户：\nRoot用户: 这是系统的超级用户，有最高权限。UID为0的用户是root用户，可以执行任何操作。 系统用户: 用于运行系统进程和服务的用户。 常规用户: 这些是普通的登录用户，可以是人工创建的账户或通过其他方式（如LDAP）管理的账户。 LDAP\nLDAP代表轻型目录访问协议（Lightweight Directory Access Protocol）。它是一种开放、中立的应用协议，用于访问和维护分布式目录信息服务。目录服务可以用来存储各种对象，如用户、组、密码、邮箱等，以结构化的方式组织。\nLDAP通常用于大型组织，其中用户、组和其他资源需要跨多个系统和应用进行统一管理。\n组（Group） 组是一组用户的集合，用于管理权限。每个组都有一个唯一的组ID（GID）。\nRoot组: 通常包括root用户，有时还包括其他具有高级权限的用户。 系统组: 用于管理系统服务和进程的组。 用户定义组: 管理员或用户可以创建的组，用于共享资源或控制访问权限。 权限 Linux文件系统具有三组权限：\n所有者权限: 文件或目录的所有者的权限。 组权限: 文件或目录的所属组的权限。 其他权限: 除所有者和组成员外，所有其他用户的权限。 每组权限都可以有以下三种设置：\n读（r）: 允许读取文件或目录内容。 写（w）: 允许修改文件或目录内容。 执行（x）: 允许执行文件或在目录中查看内容。 用户和组的区别 用户是独立的实体，拥有登录凭据和个人文件和设置。 组是一组用户的集合，用于方便地控制对资源的访问。 每个用户都属于至少一个组。在大多数系统中，每个用户都有与其用户名相同的主要组。 用户可以属于多个组。 可以这样理解：\nRoot用户具有系统上的最大权限。 Root组通常包括root用户，并可能包括其他具有高权限的用户。 创建其他用户时，通常也会创建一个与其同名的主组。 组可以包括多个用户。 组不包括其他组。 chmod 用户名:组名 权限 文件名 注意是用户:组这个顺序 ",
  "wordCount" : "7415",
  "inLanguage": "zh",
  "datePublished": "2023-08-21T21:05:23+08:00",
  "dateModified": "2023-08-21T21:05:23+08:00",
  "author":[{
    "@type": "Person",
    "name": "YOUNG"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://ahaknow.com/posts/know/0821/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AhaKnow",
    "logo": {
      "@type": "ImageObject",
      "url": "http://ahaknow.com/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://ahaknow.com" accesskey="h" title="AhaKnow (Alt + H)">
                <img src="http://ahaknow.com/Q.gif" alt="" aria-label="logo"
                    height="35">AhaKnow</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://ahaknow.com/" title="🏡主页">
                    <span>🏡主页</span>
                </a>
            </li>
            <li>
                <a href="http://ahaknow.com/posts" title="📚专栏">
                    <span>📚专栏</span>
                </a>
            </li>
            <li>
                <a href="http://ahaknow.com/archives" title="⏱️时间线">
                    <span>⏱️时间线</span>
                </a>
            </li>
            <li>
                <a href="http://ahaknow.com/tags" title="🏷️标签">
                    <span>🏷️标签</span>
                </a>
            </li>
            <li>
                <a href="http://ahaknow.com/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://ahaknow.com">🏡主页</a>&nbsp;»&nbsp;<a href="http://ahaknow.com/posts/">📚专栏</a>&nbsp;»&nbsp;<a href="http://ahaknow.com/posts/know/">🌟知识</a></div>
    <h1 class="post-title">
      📝0821：Linux随手记📝
    </h1>
    <div class="post-meta"><span title='2023-08-21 21:05:23 +0800 CST'>2023-08-21</span>&nbsp;·&nbsp;15 分钟&nbsp;·&nbsp;YOUNG

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#%e7%a3%81%e7%9b%98%e7%9b%b8%e5%85%b3" aria-label="磁盘相关">磁盘相关</a><ul>
                        
                <li>
                    <a href="#%e5%85%b3%e4%ba%8e%e7%a3%81%e7%9b%98%e7%9a%84label%e5%92%8cpartition" aria-label="关于磁盘的label和partition">关于磁盘的label和partition</a></li></ul>
                </li>
                <li>
                    <a href="#linux%e5%bc%80%e6%9c%ba%e8%87%aa%e5%8a%a8%e6%8c%82%e8%bd%bd" aria-label="Linux开机自动挂载">Linux开机自动挂载</a></li>
                <li>
                    <a href="#%e8%bd%af%e8%bf%9e%e6%8e%a5" aria-label="软连接">软连接</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e6%96%87%e4%bb%b6%e5%8d%a0%e6%8d%ae%e5%a4%a7%e5%b0%8f" aria-label="查看文件占据大小">查看文件占据大小</a></li>
                <li>
                    <a href="#%e6%9f%a5%e6%89%be%e6%8c%87%e5%ae%9a%e6%96%87%e4%bb%b6%e5%a4%a7%e5%b0%8f%e7%9a%84%e8%84%9a%e6%9c%ac" aria-label="💡查找指定文件大小的脚本">💡查找指定文件大小的脚本</a></li></ul>
                    
                <li>
                    <a href="#%e9%80%9a%e8%bf%87%e7%bd%91%e7%bb%9c%e5%ae%9e%e7%8e%b0%e7%a1%ac%e7%9b%98%e6%8c%82%e8%bd%bdnfs" aria-label="通过网络实现硬盘挂载（NFS）">通过网络实现硬盘挂载（NFS）</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%ad%a5%e9%aa%a4" aria-label="基本步骤">基本步骤</a><ul>
                        
                <li>
                    <a href="#%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%ae%be%e7%bd%ae" aria-label="服务端设置">服务端设置</a></li>
                <li>
                    <a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e8%ae%be%e7%bd%ae" aria-label="客户端设置">客户端设置</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bb%86%e8%8a%82%e8%ae%a8%e8%ae%ba" aria-label="📝细节讨论">📝细节讨论</a><ul>
                        
                <li>
                    <a href="#%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e" aria-label="参数说明">参数说明</a></li>
                <li>
                    <a href="#naf%e5%92%8cnas" aria-label="NAF和NAS">NAF和NAS</a></li>
                <li>
                    <a href="#naf%e7%a3%81%e7%9b%98%e7%9a%84%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" aria-label="NAF磁盘的文件系统">NAF磁盘的文件系统</a><ul>
                        
                <li>
                    <a href="#windows%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" aria-label="Windows文件系统">Windows文件系统</a></li>
                <li>
                    <a href="#linux%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" aria-label="Linux文件系统">Linux文件系统</a></li>
                <li>
                    <a href="#macos%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" aria-label="macOS文件系统">macOS文件系统</a></li></ul>
                </li>
                <li>
                    <a href="#linux%e6%9d%83%e9%99%90%e9%97%ae%e9%a2%98" aria-label="Linux权限问题">Linux权限问题</a><ul>
                        
                <li>
                    <a href="#%e7%94%a8%e6%88%b7user" aria-label="用户（User）">用户（User）</a></li>
                <li>
                    <a href="#%e7%bb%84group" aria-label="组（Group）">组（Group）</a></li>
                <li>
                    <a href="#%e6%9d%83%e9%99%90" aria-label="权限">权限</a></li>
                <li>
                    <a href="#%e7%94%a8%e6%88%b7%e5%92%8c%e7%bb%84%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="用户和组的区别">用户和组的区别</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>

  <div class="post-content"><h3 id="磁盘相关">磁盘相关<a hidden class="anchor" aria-hidden="true" href="#磁盘相关">#</a></h3>
<ol>
<li>
<p><strong>查看挂载盘的文件格式</strong>: 可以使用<code>df</code>命令配合<code>-T</code>选项来查看挂载盘的文件格式。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">df -T
</span></span></code></pre></td></tr></table>
</div>
</div><p>或者使用<code>lsblk</code>命令配合<code>-f</code>选项：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">lsblk -f
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>修改挂载盘的名字</strong>: 可以使用<code>e2label</code>命令来修改一个ext2/ext3/ext4文件系统的标签。例如，如果想将<code>/dev/sda1</code>的标签更改为“新名字”，你可以运行：</p>
<p>bash</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo e2label /dev/sda1 新名字
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果文件系统不是ext类型，可以使用对应的标签命令，例如对于FAT文件系统，可以使用<code>dosfslabel</code>。</p>
<blockquote>
<p>可以使用<code>exfatlabel</code>命令来更改exFAT文件系统的标签。以下是更改exFAT文件系统标签的命令示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo exfatlabel /dev/sda1 CKData
</span></span></code></pre></td></tr></table>
</div>
</div><p>确保系统中已安装了支持exFAT文件系统的工具，否则需要首先安装它们</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt-get install exfat-fuse exfat-utils
</span></span></code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt install exfatprogs
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
</li>
<li>
<p><strong>将挂载盘格式化成ext4</strong>: 使用<code>mkfs.ext4</code>命令来格式化挂载盘。请注意，这将删除该分区上的所有数据，因此请确保先备份任何重要数据。假设要格式化的盘符是<code>/dev/sda1</code>，则命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo mkfs.ext4 /dev/sda1
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>重新格式化为exFAT文件系统：</strong></p>
<p>以下是格式化分区<code>/dev/sda1</code>为exFAT文件系统的步骤：</p>
<ol>
<li>
<p>首先，确保已经卸载了要格式化的分区。可以使用<code>umount</code>命令来卸载分区：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo umount /dev/sda1
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>然后，可以使用<code>mkfs.exfat</code>命令来格式化分区。如果需要指定卷标（例如“CKData”），可以使用<code>-n</code>选项：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo mkfs.exfat -n <span class="s2">&#34;CKData&#34;</span> /dev/sda1
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>如果系统上没有<code>mkfs.exfat</code>命令，需要安装支持exFAT的软件包：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt-get install exfat-utils
</span></span></code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt install exfatprogs
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h4 id="关于磁盘的label和partition">关于磁盘的label和partition<a hidden class="anchor" aria-hidden="true" href="#关于磁盘的label和partition">#</a></h4>
<blockquote>
<p>磁盘的分区和标签是计算机存储系统的不同层次和方面</p>
<ol>
<li>
<p><strong>磁盘</strong>：磁盘是物理存储设备，可以包括硬盘驱动器（HDD）、固态硬盘（SSD）等。一个磁盘可以分为多个部分，称为分区。</p>
</li>
<li>
<p><strong>分区</strong>：分区是磁盘上的连续空间段，它可以被格式化为特定的文件系统，例如ext4、exFAT等。分区允许在同一物理磁盘上运行多个不同的文件系统，或者逻辑上将磁盘划分为不同的部分。</p>
</li>
<li>
<p><strong>标签（Label）</strong>：标签是给<strong>磁盘或分区</strong>分配的可选名称，可以使其更容易识别。例如，可以给存储音乐文件的分区命名为“Music”。</p>
</li>
</ol>
</blockquote>
<h3 id="linux开机自动挂载">Linux开机自动挂载<a hidden class="anchor" aria-hidden="true" href="#linux开机自动挂载">#</a></h3>
<p>可以通过修改<code>/etc/fstab</code>文件来实现。以下是步骤：</p>
<ol>
<li>
<p><strong>找到分区的UUID</strong>：使用以下命令找到分区的UUID（Universally Unique Identifier）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo blkid
</span></span></code></pre></td></tr></table>
</div>
</div><p>寻找要挂载的分区相对应的UUID。</p>
</li>
<li>
<p><strong>创建挂载点</strong>：选择或创建一个目录作为挂载点。例如，如果要将分区挂载到<code>/media/mydrive</code>，确保该目录存在：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo mkdir -p /media/mydrive
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>编辑<code>/etc/fstab</code>文件</strong>：使用文本编辑器（如nano或vi）打开<code>/etc/fstab</code>文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo nano /etc/fstab
</span></span></code></pre></td></tr></table>
</div>
</div><p>在文件的末尾添加一行，用以下格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">UUID=your-uuid-here /media/mydrive ext4 defaults 0 0
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的<code>your-uuid-here</code>是从<code>blkid</code>命令中获取的UUID。将<code>ext4</code>替换为分区使用的文件系统类型。</p>
</li>
<li>
<p><strong>挂载分区</strong>：保存并关闭文件，然后运行以下命令来挂载分区：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo mount -a
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>现在，该分区应该每次开机时都会自动挂载到指定的挂载点。</p>
<blockquote>
<p>至于挂载点的问题，如果想要将分区自动挂载到<code>/media/</code>下的某个子目录中，可以在<code>/etc/fstab</code>文件中指定挂载点。</p>
<p>例如，可以在<code>/etc/fstab</code>文件中使用以下条目：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">UUID=your-uuid-here /media/your-drive-label ext4 defaults 0 0
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要替换<code>your-uuid-here</code>和<code>your-drive-label</code>为相应的UUID和想要的挂载点名字。</p>
</blockquote>
<h3 id="软连接">软连接<a hidden class="anchor" aria-hidden="true" href="#软连接">#</a></h3>
<blockquote>
<p>软连接，又称符号链接（symbolic link），在Linux和UNIX系统中是一个特殊类型的文件，该文件包含对其他文件或目录的引用。</p>
<p>软连接可以指向同一文件系统内的文件或目录，也可以指向其他文件系统内的文件或目录。</p>
</blockquote>
<p>以下是软连接的常见用法：</p>
<ol>
<li>
<p><strong>创建软连接</strong>： 使用<code>ln</code>命令，加上<code>-s</code>选项来创建软连接。例如，要创建一个指向<code>/mnt/disk/yck</code>的软连接<code>yck</code>，可以使用以下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ln -s /mnt/disk/yck yck
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>理解软连接</strong>： 软连接类似于Windows中的快捷方式，它只是一个引用，指向实际文件或目录的路径。如果删除软连接，原始文件或目录不会受到影响。但是，如果删除了软连接所指向的原始文件或目录，<mark>则软连接将变为&quot;悬挂&quot;，即失效的链接。</mark></p>
</li>
<li>
<p><strong>删除软连接</strong>： 要删除软连接，可以使用<code>rm</code>命令，就像删除普通文件一样。例如，删除上面创建的<code>yck</code>软连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">rm yck
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>查看软连接</strong>： 使用<code>ls -l</code>命令，可以查看软连接的详细信息，其中会显示软连接指向的原始路径。</p>
</li>
</ol>
<p>注意，当操作软连接时，大多数命令（例如<code>cat</code>、<code>cd</code>、<code>cp</code>等）都会自动&quot;跟随&quot;软连接，即操作软连接背后的实际文件或目录。<strong>但是，删除软连接时需要特别小心，确保只删除软连接本身，而不是其背后的实际文件或目录。</strong></p>
<blockquote>
<p>补充：</p>
<ol>
<li>软链接可以被视为一个<strong>特殊类型的文件</strong>，它包含了对目标文件或目录的引用。可以使用普通的文件命令（如<code>ls</code>，<code>cat</code>等）与软链接进行交互。</li>
<li>即使使用<code>rm -rf yck</code>，删除的也只是软连接</li>
<li><strong>由于软链接是一个文件，所以创建时有同名的路径的话，会在路径下创建！</strong></li>
</ol>
</blockquote>
<h3 id="查看文件占据大小">查看文件占据大小<a hidden class="anchor" aria-hidden="true" href="#查看文件占据大小">#</a></h3>
<p>在Linux终端中，如果想要查看当前目录下文件所占据的大小，可以使用<code>du</code>和<code>ls</code>命令。</p>
<ol>
<li>
<p><strong>使用<code>du</code>命令</strong>: <code>du</code>是&quot;disk usage&quot;的缩写，用于估计文件和目录的磁盘使用空间。</p>
<p>如果想查看当前目录下的每个文件和文件夹的大小，可以使用以下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">du -sh *
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的<code>-s</code>选项表示只显示每个参数的总和，而<code>-h</code>选项则以人类可读的格式显示大小（例如，KB、MB、GB等）。</p>
</li>
<li>
<p><strong>使用<code>ls</code>命令</strong>: 还可以使用<code>ls</code>命令的<code>-l</code>和<code>-h</code>选项来查看文件大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ls -lh
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的<code>-l</code>选项表示长格式列出信息，<code>-h</code>选项表示以人类可读的格式显示大小。</p>
</li>
</ol>
<p>上述两个方法的差别在于<code>du</code>可以显示目录的整体大小，而<code>ls</code>主要关注单个文件的大小。</p>
<h3 id="查找指定文件大小的脚本">💡查找指定文件大小的脚本<a hidden class="anchor" aria-hidden="true" href="#查找指定文件大小的脚本">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$#</span><span class="s2">&#34;</span> -ne <span class="m">2</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;Usage: </span><span class="nv">$0</span><span class="s2"> &lt;directory&gt; &lt;file_size&gt;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">exit</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">directory</span><span class="o">=</span><span class="nv">$1</span>
</span></span><span class="line"><span class="cl"><span class="nv">file_size</span><span class="o">=</span><span class="nv">$2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 创建一个临时文件来保存查找结果</span>
</span></span><span class="line"><span class="cl"><span class="nv">temp_file</span><span class="o">=</span><span class="k">$(</span>mktemp<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用find命令查找文件，并将结果存储在临时文件中</span>
</span></span><span class="line"><span class="cl"><span class="c1"># -print0和xargs -0一起使用，以便正确处理文件名中包含特殊字符的文件</span>
</span></span><span class="line"><span class="cl">sudo find <span class="s2">&#34;</span><span class="nv">$directory</span><span class="s2">&#34;</span> -type f -size +<span class="s2">&#34;</span><span class="nv">$file_size</span><span class="s2">&#34;</span> -exec ls -lh <span class="o">{}</span> <span class="se">\;</span> <span class="p">|</span> tee /dev/stderr <span class="p">|</span> sort -rh -k5 &gt; <span class="s2">&#34;</span><span class="nv">$temp_file</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 打印出分隔行</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;-------------======================================================-------------&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 打印排序后的结果</span>
</span></span><span class="line"><span class="cl">cat <span class="s2">&#34;</span><span class="nv">$temp_file</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 删除临时文件</span>
</span></span><span class="line"><span class="cl">rm <span class="s2">&#34;</span><span class="nv">$temp_file</span><span class="s2">&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="通过网络实现硬盘挂载nfs">通过网络实现硬盘挂载（NFS）<a hidden class="anchor" aria-hidden="true" href="#通过网络实现硬盘挂载nfs">#</a></h2>
<blockquote>
<p>NFS（Network File System）</p>
<p>这里说的是最简单的形式：本地局域网+硬盘挂载</p>
</blockquote>
<h3 id="基本步骤">基本步骤<a hidden class="anchor" aria-hidden="true" href="#基本步骤">#</a></h3>
<h4 id="服务端设置">服务端设置<a hidden class="anchor" aria-hidden="true" href="#服务端设置">#</a></h4>
<p>首先，在共享磁盘的服务器上，需要安装NFS服务并配置共享目录。以下是基本步骤：</p>
<ol>
<li>
<p><strong>安装NFS服务：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt-get install nfs-kernel-server <span class="c1"># 在Debian/Ubuntu系统中</span>
</span></span><span class="line"><span class="cl">sudo yum install nfs-utils             <span class="c1"># 在RedHat/Fedora系统中</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>编辑配置文件：</strong></p>
<p>打开<code>/etc/exports</code>文件并添加以下行（将<code>/path/to/shared/directory</code>替换为需要共享的目录路径）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">/path/to/shared/directory *<span class="o">(</span>rw,sync,no_subtree_check<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>启动NFS服务：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo systemctl restart nfs-kernel-server
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<blockquote>
<p>如果修改了<code>/etc/exports</code>，可以使用<code>sudo exportfs -ra</code></p>
</blockquote>
<h4 id="客户端设置">客户端设置<a hidden class="anchor" aria-hidden="true" href="#客户端设置">#</a></h4>
<p>接下来，在想要挂载共享目录的客户端机器上进行以下操作：</p>
<ol>
<li>
<p><strong>安装NFS客户端工具：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt-get install nfs-common <span class="c1"># 在Debian/Ubuntu系统中</span>
</span></span><span class="line"><span class="cl">sudo yum install nfs-utils      <span class="c1"># 在RedHat/Fedora系统中</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>挂载远程目录：</strong></p>
<p>将共享目录挂载到本地目录（例如<code>/mnt/remote</code>）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo mount -t nfs server_ip:/path/to/shared/directory /mnt/remote
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h3 id="细节讨论">📝细节讨论<a hidden class="anchor" aria-hidden="true" href="#细节讨论">#</a></h3>
<h4 id="参数说明">参数说明<a hidden class="anchor" aria-hidden="true" href="#参数说明">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">/path/to/shared/directory *<span class="o">(</span>rw,sync,no_subtree_check<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p><strong><code>rw</code></strong>: 这个选项允许远程客户端对共享目录进行读写操作。如果想让共享目录只能读取，可以使用<code>ro</code>选项。</p>
</li>
<li>
<p><strong><code>sync</code></strong>: 这个选项确保在请求完成之前，所有的文件系统操作都被物理写入磁盘。这样可以确保数据的一致性，但可能会稍微降低性能。<strong>如果选择<code>async</code>选项，则操作可能会在数据还未完全写入磁盘时返回，这可能会提高性能，但如果在数据完全写入之前系统崩溃，则可能会丢失数据。</strong></p>
</li>
<li>
<p><strong><code>no_subtree_check</code></strong>: 这个选项禁用子树检查。当文件被移动或删除时，NFS会进行子树检查来确保文件的一致性。禁用此检查可能会提高性能。如果没有这个特定需求，通常建议使用此选项。</p>
</li>
</ol>
<p><strong>补充：</strong></p>
<ul>
<li><strong><code>no_root_squash</code></strong>: 默认情况下，远程系统上的root用户映射为匿名用户。<strong>使用<code>no_root_squash</code>选项允许远程root用户以本地root权限执行操作。</strong></li>
<li><strong><code>secure</code></strong>: 使用这个选项将强制NFS请求从安全的端口（小于1024）发送。这有助于提高安全性。</li>
<li><strong><code>all_squash</code></strong>: 这个选项将<strong>远程用户</strong>的所有操作映射为本地匿名用户，提供了更严格的权限控制。</li>
<li><strong><code>anonuid</code> 和 <code>anongid</code></strong>: 这些选项允许指定匿名用户和组的UID和GID，通常与<code>all_squash</code>一起使用。</li>
<li><strong><code>insecure</code></strong>: 允许客户端从大于1024的非安全端口连接。</li>
</ul>
<blockquote>
<p><strong>举例</strong></p>
<p>在<code>/etc/exports</code>文件中配置NFS共享，可以使用这些选项来控制共享的行为。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">/path/to/shared/directory *<span class="o">(</span>rw,sync,no_subtree_check,no_root_squash<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个例子中，共享目录允许读写、同步写入、禁用子树检查，并允许远程root用户以本地root权限操作。</p>
<p><strong>强调‼️</strong></p>
<p><code>anonuid</code> 和 <code>anongid</code> 这两个选项允许<strong>指定服务器端的用户ID（UID）和组ID（GID）</strong>。</p>
<p>当使用 <code>all_squash</code> 选项将所有远程用户的操作映射为本地匿名用户时，可以通过这两个选项设置该匿名用户和组的具体UID和GID。</p>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">/path/to/shared/directory *<span class="o">(</span>rw,all_squash,anonuid<span class="o">=</span>1003,anongid<span class="o">=</span>1003<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，所有远程用户访问 <code>/path/to/shared/directory</code> 的操作都会被映射为本地服务器上UID和GID都为1003的用户和组。这样可以提供更精确的权限控制，确保远程访问的权限与本地特定用户和组的权限相匹配。</p>
<p>这样的配置可以确保远程用户不会具有比所指定的本地用户更多的权限，从而增加了系统的安全性。</p>
<p><strong>也就是说：</strong></p>
<p>当客户端挂载远程NFS共享时，客户端上的用户权限是由客户端自身的操作系统和配置决定的。然而，当客户端与NFS服务器进行交互时，服务器上的<code>anonuid</code>和<code>anongid</code>设置（<strong>与<code>all_squash</code>选项结合使用</strong>）会将所有客户端用户的操作映射到指定的本地服务器用户和组上。</p>
<p>例如，如果NFS共享配置为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">/path/to/shared/directory *<span class="o">(</span>rw,all_squash,anonuid<span class="o">=</span>1003,anongid<span class="o">=</span>1003<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么无论客户端上的用户是谁，他们通过这个共享访问服务器上的文件时，都会被服务器视为UID为1003和GID为1003的本地用户和组。服务器上的文件权限会按照这个UID和GID来应用。</p>
<p>因此，通过这种方式，服务器可以精确地控制远程客户端对共享资源的访问权限，而不必依赖于客户端上的用户配置。</p>
</blockquote>
<h4 id="naf和nas">NAF和NAS<a hidden class="anchor" aria-hidden="true" href="#naf和nas">#</a></h4>
<p>NFS（Network File System）和NAS（Network Attached Storage）确实在功能和用途上有一些相似之处，但它们在实现和目的方面存在显著的区别。以下是它们之间的主要差异：</p>
<ul>
<li>
<p>NFS（Network File System）网络文件系统</p>
<ul>
<li><strong>定义与功能</strong>: NFS是一种分布式文件系统协议，允许客户端通过网络访问服务器上的文件，就像访问本地文件一样。</li>
<li><strong>适用场景</strong>: NFS通常用于组织或企业环境中，用于在不同系统之间共享文件和数据。</li>
<li><strong>依赖性</strong>: NFS是一种协议，需要在现有的服务器和客户端操作系统上安装和配置。<strong>NFS不是一个独立的存储设备。</strong></li>
<li><strong>性能和灵活性</strong>: NFS允许灵活的配置和优化，可以根据具体需求调整性能和安全性。</li>
<li><strong>跨平台</strong>: NFS支持各种操作系统，允许不同类型的客户端访问共享文件。</li>
</ul>
</li>
<li>
<p>NAS（Network Attached Storage）网络连接存储</p>
</li>
<li>
<p><strong>定义与功能</strong>: NAS是一种独立的存储设备，通过网络提供文件存储和共享服务。NAS不仅包括硬件存储设备，<strong>还包括内置的操作系统和文件服务功能。</strong></p>
</li>
<li>
<p><strong>适用场景</strong>: NAS用于家庭和企业环境中，为多个用户提供集中存储和共享文件的解决方案。NAS通常更易于设置和管理。</p>
</li>
<li>
<p><strong>自包含性</strong>: NAS是一个完整的存储解决方案，包括硬件、软件和所有必要的接口。用户只需将NAS连接到网络并进行简单配置。</p>
</li>
<li>
<p><strong>性能和灵活性</strong>: 与NFS相比，NAS可能更关注易用性和可靠性。某些高端NAS设备允许高级配置，但普通消费级NAS可能提供的配置选项较少。</p>
</li>
<li>
<p><strong>协议支持</strong>: NAS通常支持多种文件共享协议，包括NFS、SMB/CIFS等，因此可以与多种操作系统兼容。</p>
</li>
<li>
<p>总结</p>
<ul>
<li><strong>NFS是一种协议</strong>，用于允许跨网络的文件共享，可以在现有硬件和操作系统上配置。</li>
<li>NAS是一个完整的存储解决方案，包括硬件和软件，用于通过网络提供文件存储和共享服务。</li>
<li>NFS更灵活和高效，适用于对性能和配置有特殊需求的组织。</li>
<li>NAS通常更易于安装和管理，适用于需要集中存储和共享文件的家庭和小型企业。</li>
</ul>
</li>
</ul>
<h4 id="naf磁盘的文件系统">NAF磁盘的文件系统<a hidden class="anchor" aria-hidden="true" href="#naf磁盘的文件系统">#</a></h4>
<blockquote>
<p>有一个观点：
“exFAT可能不适合作为NFS共享的文件系统”</p>
</blockquote>
<p>下面，了解一下文件系统的基本常识：</p>
<h5 id="windows文件系统">Windows文件系统<a hidden class="anchor" aria-hidden="true" href="#windows文件系统">#</a></h5>
<ul>
<li>
<p><strong>FAT (File Allocation Table)</strong></p>
<ul>
<li>文件分配表（FAT）是Microsoft早期的文件系统，适用于简单的存储需求。</li>
<li><strong>结构</strong>: FAT使用文件分配表来跟踪磁盘上文件的位置。它是一种简单的结构，没有许多现代文件系统的特性。</li>
</ul>
<ul>
<li>
<p><strong>碎片</strong>: 因为FAT缺乏高级的空间管理，所以文件碎片化是一个问题。</p>
</li>
<li>
<p><strong>大小限制</strong>: FAT32有4GB的文件大小限制和2TB的卷大小限制。</p>
</li>
</ul>
<blockquote>
<p><strong>exFAT与FAT32的主要区别:</strong></p>
<ol>
<li>
<p><strong>文件大小限制</strong>:</p>
<ul>
<li>FAT32: 单个文件最大4GB。</li>
<li>exFAT: 单个文件最大可以达到16EB（百亿兆字节）。</li>
</ul>
</li>
<li>
<p><strong>分区大小限制</strong>:</p>
<ul>
<li>FAT32: 单个分区最大2TB。</li>
<li>exFAT: 没有明显的实际分区大小限制。</li>
</ul>
</li>
<li>
<p><strong>性能</strong>: exFAT通常在处理大文件和大分区时具有更高的效率，因为它采用了更先进的数据结构。</p>
</li>
<li>
<p><strong>兼容性</strong>:</p>
<ul>
<li>FAT32: 在各种操作系统中的支持更广泛。</li>
<li>exFAT: 主要为现代操作系统设计，不一定适用于较旧的系统。</li>
</ul>
</li>
<li>
<p><strong>功能</strong>: exFAT添加了一些改进，例如时间戳支持以及更有效的空间利用，但依然没有像EXT4或NTFS那样的先进功能。</p>
</li>
</ol>
</blockquote>
</li>
<li>
<p><strong>NTFS (New Technology File System)</strong></p>
<ul>
<li>新技术文件系统（NTFS）是Windows的主要文件系统。它具有许多现代功能，如文件压缩、加密和详细的权限管理。</li>
<li><strong>日志功能</strong>: NTFS使用日志记录文件操作，增加了可靠性和恢复能力。</li>
</ul>
<ul>
<li>
<p><strong>权限管理</strong>: 它支持详细的访问控制列表（ACL）。</p>
</li>
<li>
<p><strong>压缩和加密</strong>: NTFS支持本地文件压缩和加密。</p>
</li>
<li>
<p><strong>元数据</strong>: NTFS存储关于文件的大量元数据，包括安全信息、归属和更多。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>exFAT</code>（扩展文件分配表）是为了优化闪存存储，如USB闪存驱动器和SD卡而设计的。它比FAT32现代，可以支持更大的文件和卷。</p>
<p><strong>不足之处：</strong></p>
<ul>
<li>
<p><strong>没有日志功能</strong>: <code>exFAT</code>没有日志功能，这意味着如果在写操作过程中出现断电或崩溃等情况，可能会导致文件系统损坏。</p>
</li>
<li>
<p><strong>没有本地权限管理</strong>: <code>exFAT</code>没有本地文件和文件夹级别的权限管理，这在共享环境中可能是一个限制。</p>
</li>
<li>
<p><strong>性能问题</strong>: <code>exFAT</code>是为闪存驱动器（如SD卡和USB闪存驱动器）优化的文件系统，因此，其性能可能不如专为高速硬盘和网络存储解决方案设计的文件系统。在高负载或需要频繁读写的网络环境下，exFAT可能会遇到性能瓶颈。</p>
</li>
<li>
<p><strong>不是原生支持</strong>: 尽管<code>exFAT</code>是一种在Windows、macOS和一些Linux发行版之间通用的文件系统，但不是所有的Linux系统都原生支持<code>exFAT</code></p>
</li>
</ul>
</blockquote>
<h5 id="linux文件系统">Linux文件系统<a hidden class="anchor" aria-hidden="true" href="#linux文件系统">#</a></h5>
<blockquote>
<p>Linux的扩展文件系统。<code>ext3</code>是<code>ext2</code>的一个升级，增加了日志功能。<code>ext4</code>进一步增加了性能和可靠性改进。</p>
</blockquote>
<ul>
<li>
<p><strong>ext2</strong></p>
<ul>
<li>
<p><strong>非日志</strong>: ext2是Linux的第一个扩展文件系统，没有日志功能。</p>
</li>
<li>
<p><strong>块组</strong>: 文件和目录在块组中存储，有助于减少碎片化。</p>
</li>
<li>
<p><strong>大小限制</strong>: 文件大小最多可以达到2TB，卷大小最多可以达到32TB。</p>
</li>
</ul>
</li>
<li>
<p><strong>ext3</strong></p>
<ul>
<li>
<p><strong>日志功能</strong>: 在ext2的基础上增加了日志功能，提高了可靠性。</p>
</li>
<li>
<p><strong>兼容性</strong>: 与ext2向后兼容。</p>
</li>
</ul>
</li>
<li>
<p><strong>ext4</strong></p>
<ul>
<li>
<p><strong>子卷</strong>: 支持多达64k的子卷。</p>
</li>
<li>
<p><strong>预分配</strong>: 可以在创建文件之前预分配空间。</p>
</li>
<li>
<p><strong>延迟分配</strong>: 通过延迟分配磁盘空间，提高了写入性能。</p>
</li>
</ul>
</li>
<li>
<p><strong>XFS, Btrfs等</strong></p>
<ul>
<li>
<p><strong>XFS</strong>: 是一种高性能的日志文件系统，特别适合大型文件。</p>
</li>
<li>
<p><strong>Btrfs</strong>: 提供了卷快照、数据完整性检查和更多现代功能。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>为什么EXT4可能更适合网络硬盘：</strong></p>
<ol>
<li>
<p><strong>日志功能</strong>: EXT4使用日志来记录文件操作，有助于数据恢复和完整性，在系统崩溃或断电时更可靠。</p>
</li>
<li>
<p><strong>权限管理</strong>: EXT4支持复杂的文件权限和所有权管理，有助于在网络环境中实施合适的访问控制。</p>
</li>
<li>
<p><strong>性能</strong>: EXT4针对Linux优化，通常在Linux服务器上表现更好，特别是在高负载环境下。</p>
</li>
<li>
<p><strong>高级功能</strong>: EXT4支持一些高级功能，如数据压缩、加密和快照等。</p>
</li>
<li>
<p><strong>成熟与稳定</strong>: EXT4是Linux主流的文件系统之一，被广泛用于各种用途，包括网络存储，因此在支持和稳定性方面更有保障。</p>
</li>
</ol>
</blockquote>
<h5 id="macos文件系统">macOS文件系统<a hidden class="anchor" aria-hidden="true" href="#macos文件系统">#</a></h5>
<ul>
<li>
<p><strong>HFS+ (Hierarchical File System Plus)</strong></p>
<ul>
<li>层次文件系统加（HFS+），苹果早期的文件系统。</li>
<li><strong>碎片化</strong>: 有时可能需要碎片整理。</li>
</ul>
<ul>
<li><strong>不支持一些现代功能</strong>: 例如没有本地压缩和加密支持。</li>
</ul>
</li>
<li>
<p><strong>APFS (Apple File System)</strong></p>
<ul>
<li>苹果文件系统（APFS）是macOS High Sierra及更高版本的默认文件系统。它针对闪存/SSD存储进行了优化，并增加了加密等现代功能。</li>
<li><strong>优化闪存</strong>: 专门针对SSD和闪存驱动器优化。</li>
</ul>
<ul>
<li>
<p><strong>空间共享</strong>: 允许多个卷共享同一个底层存储空间。</p>
</li>
<li>
<p><strong>快照</strong>: 支持卷和文件系统的快照。</p>
</li>
<li>
<p><strong>数据完整性</strong>: 通过校验和保护数据的完整性。</p>
</li>
</ul>
</li>
</ul>
<h4 id="linux权限问题">Linux权限问题<a hidden class="anchor" aria-hidden="true" href="#linux权限问题">#</a></h4>
<p>先从用户和组的区别来理解：</p>
<h5 id="用户user">用户（User）<a hidden class="anchor" aria-hidden="true" href="#用户user">#</a></h5>
<p>在Linux中，每个用户都有一个唯一的用户ID（UID）。有三种主要类型的用户：</p>
<ol>
<li><strong>Root用户</strong>: 这是系统的超级用户，有最高权限。UID为0的用户是root用户，可以执行任何操作。</li>
<li><strong>系统用户</strong>: 用于运行系统进程和服务的用户。</li>
<li><strong>常规用户</strong>: 这些是普通的登录用户，可以是人工创建的账户或通过其他方式（如LDAP）管理的账户。</li>
</ol>
<blockquote>
<p><strong>LDAP</strong></p>
<p>LDAP代表轻型目录访问协议（Lightweight Directory Access Protocol）。它是一种开放、中立的应用协议，用于访问和维护分布式目录信息服务。目录服务可以用来存储各种对象，如用户、组、密码、邮箱等，以结构化的方式组织。</p>
<p>LDAP通常用于大型组织，其中用户、组和其他资源需要跨多个系统和应用进行统一管理。</p>
</blockquote>
<h5 id="组group">组（Group）<a hidden class="anchor" aria-hidden="true" href="#组group">#</a></h5>
<p>组是一组用户的集合，用于管理权限。每个组都有一个唯一的组ID（GID）。</p>
<ol>
<li><strong>Root组</strong>: 通常包括root用户，有时还包括其他具有高级权限的用户。</li>
<li><strong>系统组</strong>: 用于管理系统服务和进程的组。</li>
<li><strong>用户定义组</strong>: 管理员或用户可以创建的组，用于共享资源或控制访问权限。</li>
</ol>
<h5 id="权限">权限<a hidden class="anchor" aria-hidden="true" href="#权限">#</a></h5>
<p>Linux文件系统具有三组权限：</p>
<ol>
<li><strong>所有者权限</strong>: 文件或目录的所有者的权限。</li>
<li><strong>组权限</strong>: 文件或目录的所属组的权限。</li>
<li><strong>其他权限</strong>: 除所有者和组成员外，所有其他用户的权限。</li>
</ol>
<p>每组权限都可以有以下三种设置：</p>
<ul>
<li><strong>读（r）</strong>: 允许读取文件或目录内容。</li>
<li><strong>写（w）</strong>: 允许修改文件或目录内容。</li>
<li><strong>执行（x）</strong>: 允许执行文件或在目录中查看内容。</li>
</ul>
<h5 id="用户和组的区别">用户和组的区别<a hidden class="anchor" aria-hidden="true" href="#用户和组的区别">#</a></h5>
<ul>
<li><strong>用户</strong>是独立的实体，拥有登录凭据和个人文件和设置。</li>
<li><strong>组</strong>是一组用户的集合，用于方便地控制对资源的访问。</li>
<li>每个用户都属于至少一个组。在大多数系统中，每个用户都有与其用户名相同的主要组。</li>
<li>用户可以属于多个组。</li>
</ul>
<blockquote>
<p><strong>可以这样理解：</strong></p>
<ul>
<li><strong>Root用户</strong>具有系统上的最大权限。</li>
<li><strong>Root组</strong>通常包括root用户，并可能包括其他具有高权限的用户。</li>
<li>创建<strong>其他用户</strong>时，通常也会创建一个与其同名的主组。</li>
<li><strong>组</strong>可以包括多个用户。</li>
<li>组<strong>不包括其他组</strong>。</li>
<li><code>chmod 用户名:组名 权限 文件名</code> 注意是<code>用户:组</code>这个顺序</li>
</ul>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://ahaknow.com/tags/linux/">Linux</a></li>
      <li><a href="http://ahaknow.com/tags/deeplearning/">DeepLearning</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://ahaknow.com/posts/think/0904%E4%B9%A0%E6%83%AF%E4%B8%8E%E6%89%93%E7%A0%B4%E4%B9%A0%E6%83%AF/">
    <span class="title">« 上一页</span>
    <br>
    <span>0904 习惯与打破习惯</span>
  </a>
  <a class="next" href="http://ahaknow.com/posts/think/0712%E5%81%9C%E6%BB%9E%E5%AD%A6%E4%B9%A0/">
    <span class="title">下一页 »</span>
    <br>
    <span>0712 停滞学习</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://ahaknow.com">AhaKnow</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/IHKYoung/CKPaper.git/" rel="noopener" target="_blank">CKPaper</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '🖨️拷贝';

        function copyingDone() {
            copybutton.innerHTML = '📋已拷贝';
            setTimeout(() => {
                copybutton.innerHTML = '🖨️拷贝';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
