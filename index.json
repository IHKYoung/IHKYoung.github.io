[{"content":"毕业记录 范数 范数是一种衡量向量大小的量度，具有广泛的应用，包括线性代数、机器学习和数据分析。以下是一些常见范数的详细说明：\n1. L1范数 L1范数也称为“曼哈顿距离”或“绝对值范数”。对于向量$\\mathbf{x} = (x_1, x_2, \\ldots, x_n)$，其L1范数定义为向量元素的绝对值之和：\n$$ ||\\mathbf{x}||_1 = |x_1| + |x_2| + \\ldots + |x_n| $$\nL1范数常用于某些稀疏解优化问题，因为它倾向于产生许多零元素。\n2. L2范数 L2范数也称为“欧几里得距离”或“2-范数”。对于向量$ \\mathbf{x} $，其L2范数定义为向量元素平方和的平方根：\n$$ ||\\mathbf{x}||_2 = \\sqrt{x_1^2 + x_2^2 + \\ldots + x_n^2} $$\nL2范数在许多情况下都很有用，特别是当我们希望衡量两点之间的直线距离时。\n数学表达和计算含义 L1范数对应于两点之间的“曼哈顿距离”，即沿着坐标轴测量的距离。它反映了向量中每个元素大小的总体影响。 L2范数对应于两点之间的“欧几里得距离”，即直线距离。它对于大的元素更敏感，并强调向量中最大元素的影响。 与线性代数的关系 范数是线性代数的一部分，并与空间中的距离和大小有关。通过范数，我们可以衡量向量之间的距离、向量的长度以及矩阵的大小。在矩阵分解和特征值问题等线性代数任务中，范数具有关键作用。\n其他范数 除了L1和L2范数外，还有许多其他类型的范数，例如无穷范数、Lp范数等。它们都有各自的数学定义和应用背景，可以根据具体情况选择使用。\n总体来说，范数是衡量向量和矩阵大小的一种强有力的数学工具，具有广泛的应用和丰富的解释。\nC++模版 模板（Template）是C++的一项功能，用于实现泛型编程。泛型编程的目的是使代码更灵活和可重用，允许函数、类或结构体对多种类型进行操作，而不需要重新编写代码。\n以你提供的代码为例：\n1 2 3 4 5 6 7 template \u0026lt;typename Func\u0026gt; std::chrono::milliseconds StereoScene::measure_running_time(Func \u0026amp;\u0026amp;running_task) { auto start_time = std::chrono::high_resolution_clock::now(); running_task(); auto end_time = std::chrono::high_resolution_clock::now(); return std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(end_time - start_time); } 这是一个成员函数模板的例子，用于测量给定函数或可调用对象（例如另一个函数、lambda表达式或具有operator()成员的类实例）的运行时间。这里的模板允许你将任何可以调用的对象传递给measure_running_time函数。\n模板的组成部分 template \u0026lt;typename Func\u0026gt;：这是模板参数的声明。它告诉编译器，Func是一个类型名，可以用实际类型替换。在实例化模板时，编译器会用具体的类型替换Func。\nFunc \u0026amp;\u0026amp;running_task：这是一个右值引用，用于接受传递给measure_running_time函数的可调用对象。这可以是函数指针、函数对象、lambda表达式等。\n模板的用法 你可以通过以下方式调用此模板函数：\n1 2 3 4 5 6 7 8 auto duration = measure_running_time([]() { // 这里可以放置你想要测量的代码 }); #比如 auto inference_duration = measure_inference_time([\u0026amp;]() { cv::Mat disparity = tensorrt_runner_.inference(left_img, right_img); // ... 其他推理代码 }); [\u0026amp;]: 这是C++中lambda表达式的捕获子句的一部分。[\u0026amp;]表示lambda表达式应捕获其所在作用域中的所有变量，并通过引用访问它们。这意味着lambda内部对这些变量的修改将影响其所在作用域中的相应变量。\n另一方面，如果使用[=]，则lambda将通过值捕获其所在作用域中的所有变量。在这种情况下，lambda内部对这些变量的修改不会影响其所在作用域中的相应变量。\n还可以通过明确指定要捕获的变量来混合使用按值和按引用捕获，例如[a, \u0026amp;b]表示捕获变量a的副本并通过引用捕获变量b。\n当你调用measure_running_time时，编译器会根据你传递的具体类型自动生成一个特化的函数版本。在这个例子中，它会为你传递的lambda表达式生成一个特定的函数版本。\n总结 模板的主要好处是代码重用和灵活性。通过使用模板，你可以编写通用的代码来处理多种类型，而不必为每种类型编写单独的函数或类。在上述示例中，measure_running_time函数可以用于测量任何可调用对象的执行时间，使其具有很高的灵活性和可重用性。\nLambda Lambda表达式是C++11引入的一个功能，允许在代码中定义匿名函数。Lambda表达式可以捕获其所在作用域中的变量，并可用作一等公民，例如作为参数传递给其他函数或返回值。\n下面是一些Lambda表达式的例子：\n例1：简单Lambda 1 2 auto add = [](int a, int b) { return a + b; }; int sum = add(3, 4); // sum的值为7 这个Lambda表达式定义了一个接受两个整数参数并返回它们的和的函数。Lambda赋值给了名为add的变量，然后调用了这个Lambda函数。\n例2：捕获变量 1 2 3 int factor = 2; auto multiplyByFactor = [factor](int a) { return a * factor; }; int result = multiplyByFactor(5); // result的值为10 在这个例子中，Lambda表达式捕获了其外部作用域中的变量factor，并在其定义中使用了该变量。\n例3：按引用捕获 1 2 3 4 int factor = 2; auto multiplyByFactor = [\u0026amp;factor](int a) { factor *= 2; return a * factor; }; int result = multiplyByFactor(5); // result的值为20 // factor的值现在是4，因为Lambda通过引用捕获了它并修改了它的值 在这个例子中，Lambda表达式通过引用捕获了变量factor，所以在Lambda内部对factor的修改影响了外部的factor变量。\nLambda表达式提供了一种在不创建全新命名函数的情况下编写紧凑和灵活的代码的方式。它们在使用标准库算法、自定义排序、并行处理等方面特别有用。\nHugo基本流程 使用Hugo创建和管理博客涉及许多步骤。以下是通常的工作流程，可以帮助你创建、修改和发布博客。\n1. 安装Hugo 首先，你需要在你的机器上安装Hugo。安装说明可以在Hugo的官方文档中找到。\n2. 创建新站点 一旦安装了Hugo，你可以使用以下命令创建一个新站点：\n1 hugo new site myblog 这将创建一个名为myblog的新站点目录。\n3. 添加主题 Hugo有许多可用的主题。你可以选择一个并将其添加到你的站点。一般的命令可能如下：\n1 2 3 cd myblog git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke echo \u0026#39;theme = \u0026#34;ananke\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml 4. 创建新博文 要创建新博文，你可以使用以下命令：\n1 hugo new posts/my-first-post.md 这将在content/posts目录下创建一个新的Markdown文件。\n5. 编辑博文 使用文本编辑器打开新创建的Markdown文件并编辑内容。\n6. 本地预览 在本地预览你的站点，以确保一切看起来都正常：\n1 hugo server 然后在浏览器中访问 http://localhost:1313。\n7. 构建站点 要构建站点，运行：\n1 hugo 这将生成一个名为public的目录，其中包含站点的所有静态文件。\n8. 部署到GitHub 你可以使用git将你的站点推送到GitHub。首先，初始化git仓库并添加所有文件：\n1 2 3 git init git add . git commit -m \u0026#34;Initial commit\u0026#34; 然后，将其推送到GitHub仓库。你可能还希望使用GitHub Pages或其他服务来托管你的站点。\n9. 更新和删除博文 你可以通过编辑对应的Markdown文件来更新博文，或者简单地从文件系统中删除它们来删除博文。\n10. 其他自定义 Hugo提供了许多其他自定义选项，包括添加自定义页面、更改布局等。你可以查看Hugo的文档以了解更多。\n这个流程概述了使用Hugo创建和管理博客的基本步骤。Hugo是一个非常灵活和强大的工具，因此你可能会发现还有许多其他可用的特性和选项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;NvInfer.h\u0026gt; #include \u0026lt;cuda_runtime.h\u0026gt; #include \u0026lt;cudnn.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { // 检查CUDA是否安装 int cudaVersion; cudaError_t cudaStatus = cudaRuntimeGetVersion(\u0026amp;cudaVersion); cudaError_t cudaStatus = cudaRuntimeGetVersion(\u0026amp;cudaVersion); if (cudaStatus != cudaSuccess) { std::cerr \u0026lt;\u0026lt; \u0026#34;CUDA not found!\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } std::cout \u0026lt;\u0026lt; \u0026#34;CUDA version: \u0026#34; \u0026lt;\u0026lt; cudaVersion \u0026lt;\u0026lt; std::endl; // 检查cuDNN是否安装 size_t cudnnVersion = cudnnGetVersion(); if (cudnnVersion \u0026lt; CUDNN_VERSION) { std::cerr \u0026lt;\u0026lt; \u0026#34;cuDNN not found!\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } std::cout \u0026lt;\u0026lt; \u0026#34;cuDNN version: \u0026#34; \u0026lt;\u0026lt; cudnnVersion \u0026lt;\u0026lt; std::endl; // 检查TensorRT是否安装 int tensorRTVersion = getInferLibVersion(); if (tensorRTVersion \u0026lt; NV_TENSORRT_VERSION) { std::cerr \u0026lt;\u0026lt; \u0026#34;TensorRT not found!\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } std::cout \u0026lt;\u0026lt; \u0026#34;TensorRT version: \u0026#34; \u0026lt;\u0026lt; tensorRTVersion \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;All libraries found successfully!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ","permalink":"http://ahaknow.com/posts/think/%E6%96%87%E6%9C%AC%E6%B5%8B%E8%AF%95/","summary":"毕业记录 范数 范数是一种衡量向量大小的量度，具有广泛的应用，包括线性代数、机器学习和数据分析。以下是一些常见范数的详细说明： 1. L1范数 L1范数","title":"文本测试"},{"content":"","permalink":"http://ahaknow.com/posts/know/0818/","summary":"","title":""}]