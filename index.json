[{"content":"Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\nExample 1:\nInput: nums = [3,2,3] Output: 3 Example 2:\nInput: nums = [2,2,1,1,1,2,2] Output: 2 Constraints:\nn == nums.length 1 \u0026lt;= n \u0026lt;= 5 * 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 Follow-up: Could you solve the problem in linear time and in O(1) space?\n给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例 1：\n输入：nums = [3,2,3] 输出：3 示例 2：\n输入：nums = [2,2,1,1,1,2,2] 输出：2 提示：\nn == nums.length 1 \u0026lt;= n \u0026lt;= 5 * 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 进阶： 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。\n第一反应是分别计数，这种方法显然有点笨。。。\n因为题目想找出现次数最多的数字（这种题目要求大于一半数量，说明肯定有大于一半数量存在的），其实可以这样，不用分别计数，而是按照顺序依次“增减”计数，比如：\n1 1 2 2 1 1\n最开始遇到1，遇到1就计数+1，遇到不是1就计数-1，如果这个数字大于一半数量，那么增增减减之后，一定也还是大于零\n🌽上菜 在这个问题中，需要找到一个出现次数超过 ⌊n/2⌋ 次的多数元素。对于这种问题，有一种非常高效的解决方法，称为 Boyer-Moore 投票算法。这种算法可以在 O(n) 时间复杂度内找到多数元素，并且其空间复杂度为 O(1)。\nBoyer-Moore 投票算法 其核心思想是通过一种巧妙的方式取消掉非多数元素的计数，来找到多数元素。具体步骤如下：\n初始化：设置两个变量，candidate（候选人）初始化为任意值，count（计数）初始化为 0。 第一遍遍历：遍历数组 nums。 如果 count 为 0，设当前元素为 candidate。 如果当前元素等于 candidate，增加 count。 否则减少 count。 第二遍遍历：验证 candidate 是否为多数元素（这一步在题目中可以省略，因为题目保证了总是存在多数元素）。 计算 candidate 的出现次数。 如果出现次数大于 ⌊n/2⌋，返回 candidate。 直觉的理解：\n每次在找到两个不同的元素时就将它们“抵消”。如果一个元素的数量超过总数的一半，那么即使它与其他所有不同的元素进行抵消，最后仍然会剩余该元素，因为它的数量多于其他所有元素的总和。\n但是要注意这个算法成立的关键前提：数组中存在一个多数元素，其出现次数严格大于数组长度的一半。\n实现代码（C++） // 169. Majority Element #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int candidate; int count = 0; for (int num : nums) { // 说明增增减减之后又回到零 if (count == 0) { candidate = num; } count += (candidate == num) ? 1 : -1; } // 由于题目限制，下面的判断可以省略（但其实很必要） // count = 0; // for (int num : nums) { // if (num == candidate) { // count++; // } // } // if (count \u0026gt; nums.size() / 2) return candidate; return candidate; } }; ","permalink":"https://ahaknow.com/posts/know/leetcode-169-majority-element/","summary":"Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array. Example 1: Input: nums = [3,2,3] Output: 3 Example 2: Input: nums = [2,2,1,1,1,2,2] Output: 2 Constraints: n == nums.length 1 \u0026lt;= n \u0026lt;= 5 * 104 -109 \u0026lt;= nums[i] \u0026lt;=","title":"Leetcode 169 Majority Element"},{"content":"Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,_,_] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums is sorted in non-decreasing order. 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n说明：\n为什么返回数值是整数，但输出的答案是数组呢？\n请注意，输入数组是以 「引用」 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例 1：\n输入：nums = [1,1,1,2,2,3] 输出：5, nums = [1,1,2,2,3] 解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。 示例 2：\n输入：nums = [0,0,1,1,1,1,2,3,3] 输出：7, nums = [0,0,1,1,2,3,3] 解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按升序排列 这和上一题的区别就是重复的元素只出现两次\n其实解题的本质和上一题是一样的，还是使用双指针，但是实现逻辑上稍有不同，需要注意‼️\n不管是只出现两次还是n次，\n因为是升序排列，只能出现一次是比较一次，那么只能出现两次那就判断两次\n但比较一次可以简化为比较不同，比较两次则要保证不受到原地替换的影响，在逻辑上有巧妙之处。\n🥬上菜 这个问题是前一个问题的一个变体，不同之处在于需要保留每个元素最多两次，而不是一次。因此，仍然可以采用双指针的方法来解决这个问题，只是需要对比较逻辑做一些调整，以确保每个元素最多出现两次。\n解题思路：\n使用两个指针 slow 和 fast。其中 slow 指针用来指示处理后的数组的末尾位置，而 fast 指针用来遍历整个数组。 需要确保 slow 指向的新数组中，每个元素最多出现两次。这可以通过比较 nums[fast] 与 nums[slow-2]（而不是 nums[slow-1]）来实现，因为这次是允许每个元素出现两次。 当 fast 指针指向的元素与 slow-2 指针指向的元素不同，或者 slow 小于2（意味着还没有填充两个元素）时，将 nums[fast] 的值复制到 nums[slow]，然后递增 slow。 需要特别注意： if (nums[fast] != nums[slow - 2])，与之前的写法不同！\n具体代码实现（C++）如下：\n#include \u0026lt;vector\u0026gt; using namespace std; int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() \u0026lt;= 2) return nums.size(); int slow = 2; // 因为允许元素最多出现两次，所以从索引2开始检查 for (int fast = 2; fast \u0026lt; nums.size(); ++fast) { if (nums[fast] != nums[slow - 2]) { nums[slow++] = nums[fast]; } } return slow; } 这段代码有效地在原地修改了数组，同时只使用了 O(1) 的额外空间。时间复杂度为 O(n)，因为只需要需要遍历一次数组。空间复杂度为 O(1)，因为没有使用额外的存储空间，只是在原数组上进行了操作。\n💣特别注意 在处理有序数组中删除重复元素，并保留最多两个重复元素的情景中，使用 if (nums[fast] != nums[slow - 2]) 和使用 if (nums[fast - 2] != nums[fast]) 进行判断有本质的不同，主要因为这两种判断方式所依赖的逻辑和数组的修改方式不同。\nif (nums[fast] != nums[slow - 2]) 这种判断方式是在原地修改数组，通过保持一个 slow 指针来跟踪应该写入的位置。这个条件检查的是当前正在遍历的元素（由 fast 指针指示）是否与 slow - 2 位置的元素不同。这样可以确保每个元素最多出现两次。当数组中前两个元素已经存在时，这种方法可以保证不会超过两个相同的元素被连续保留。\n优点：\n它允许在已经有两个元素的情况下继续放置新元素，只要新元素与 slow - 2 的元素不同。 if (nums[fast - 2] != nums[fast]) 这种方法的关键在于比较当前元素与它前面第二个元素是否不同。这种方法适用于检查整个数组并判断哪些元素应该被保留，不适合在使用 slow 和 fast 指针原地修改数组的情境。在初始数组中，如果用这种判断方法，那么从第三个元素开始，每个元素都要与它前面的第二个元素比较，如果相同，则说明它是第三次或更多次重复出现。\n问题：\n这种方法假设每个元素的前两个元素已经确定并且正确地处理过，这在初始化阶段并不总是成立。 在使用双指针进行原地操作时，这种判断不能正确地更新 slow 指针的位置，因为它基于遍历过程中之前的元素的状态，而在 slow 和 fast 指针操作中，我们需要基于动态更新的数组状态进行判断。 if (nums[fast] != nums[slow - 2]) 是针对双指针原地修改数组设计的，能有效处理只保留最多两个重复元素的要求，而 if (nums[fast - 2] != nums[fast]) 更多的是一种检查方式，用于理解和分析，但不适合直接用于双指针原地修改数组的具体实现。\n举例说明 如果是if (nums[fast - 2] != nums[fast]):\n1 1 1 2 2 3 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针相同，快指针继续循环，慢指针位置不变 1 1 1 2 2 3 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 2 3 ⬆慢 1 1 2 2 2 3 注意由于慢指针的替换，导致此时原始数组发生变化 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针相同，快指针继续循环，慢指针位置不变 1 1 2 2 2 3 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 3 2 3 ⬆慢 结果错误❌ 如果是if (nums[fast] != nums[slow - 2])：\n1 1 1 2 2 3 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针相同，快指针继续循环，慢指针位置不变 1 1 1 2 2 3 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 2 3 ⬆慢 1 1 2 2 2 3 注意由于慢指针的替换，导致此时原始数组发生变化 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 2 3 ⬆慢 1 1 2 2 2 3 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 3 3 ⬆慢 快指针到头，循环结束 结果正确✅ 🌟与上一题的区别 对于上一题，即移除所有重复的元素使每个元素只出现一次的情况，使用 if (nums[fast] != nums[fast - 1]) 对结果没有影响，分析如下：\n原地操作 在数组操作中，“原地”意味着不需要额外的空间来存储输出，仅允许使用常数级别的额外空间。在使用 if (nums[fast] != nums[fast - 1]) 的双指针策略中，直接在输入数组 nums 上进行修改，不需要额外的存储空间（除了几个指针变量）。这是一种原地操作，因为它直接在原数组上进行元素的重写和覆盖，没有使用新的数组结构来存储结果。\n使用 if (nums[fast] != nums[fast - 1])也可以的原因 这个条件是用来检查当前快指针 fast 指向的元素是否与它前一个元素相同。这里的关键是理解我们的目标是保证数组中每个元素只出现一次。由于数组是有序的，所有的重复元素都会连续出现。因此，只需要检查当前元素是否与前一个元素不同：\n如果 不同，则表示当前元素是一个新的元素，应该被保留。这时你就将当前 fast 指向的元素复制到 slow 指针的位置，然后递增 slow。 如果 相同，则快指针 fast 继续向前移动，直到找到一个不同的元素。 如果是 if (nums[fast] != nums[slow - 1]) 效果也一样。\n在只允许每个元素出现一次的问题中，关注的是确保不复制相同的元素到 slow 指向的位置。而在允许每个元素出现两次的问题中，关注点则是允许至多两个重复元素。\nslow - 2的关键在于：保证slow-2到slow之间是相同的元素，并且用fast指针进行比较时，是有一个比较参考，而不是自己和自己比（有点需要意会的意思，慢慢品）\n","permalink":"https://ahaknow.com/posts/know/leetcode-80-remove-duplicates-from-sorted-array-ii/","summary":"Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements","title":"Leetcode：80. 删除有序数组中的重复项 II"},{"content":" 我发现我的思维特别容易发散，就是干这一件事，脑海中突然有了其他灵感，此前的做法是“直接插队的优先队列”，就是放下手中活，把突然想到去办了，其实这种方法有时候并不好，容易“本末倒置”，原本的事到最后没做好。\n所以，再次把一写博客的灵感记录下来，然后一件一件事情按部就班完成了再来处理这里。\n在此之前已经实现了很多想法，比如一些美化操作（哼，徒有外表，华而不实！！），就不记录了；之后新产生的，在此记录。\n文章元数据显示等美化 时间线按照最近更新时间排序 Hugo里面时间计算的原理需要优化（公式优化） Hugo的模版页面自定义 ","permalink":"https://ahaknow.com/posts/know/blog-todo/","summary":"我发现我的思维特别容易发散，就是干这一件事，脑海中突然有了其他灵感，此前的做法是“直接插队的优先队列”，就是放下手中活，把突然想到去办了，其","title":"Blog：奇思妙想待办项"},{"content":" 记录一些实用Hugo写博客的小技巧。\n—— 因为如果当时不记录，那么日后肯定不会再记录的！（懒！）\n使用Archetype预设模版 在使用 hugo new 命令创建新内容时，你可以指定使用特定的 archetype。Archetype 是 Hugo 中的模板文件，用于预设新内容文件的元数据和结构。默认情况下，Hugo 会使用名为 default.md 的 archetype，但可以创建和指定其他 archetype 来满足不同类型内容的需求。\n创建自定义 Archetype 在 Hugo 站点的根目录中，archetypes 目录用于存放 archetype 文件。\n可以在这个目录下创建新的 archetype 文件。例如，创建一个名为 blog.md 的文件，用于博客帖子：\narchetypes/blog.md 编辑 blog.md 文件，定义你想要预置的内容和 Front Matter，例如：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] --- 在这里写博客内容... 使用自定义 Archetype 创建内容 当创建新内容时，可以通过指定 archetype 的名称来使用它。格式如下：\nhugo new \u0026lt;路径\u0026gt;/\u0026lt;文件名\u0026gt;.\u0026lt;扩展名\u0026gt; --kind \u0026lt;archetype名称\u0026gt; 或者，如果创建的内容直接位于 archetypes 下的同名目录中，你只需指定路径，Hugo 会自动寻找匹配的 archetype。例如，如果有一个名为 blog.md 的 archetype，就可以这样创建新的博客帖子：\nhugo new blog/我的新博客帖子.md 这里，Hugo 会在 archetypes 目录下寻找名为 blog.md 的文件，并使用它作为新内容文件的模板。\n如果想显式地使用特定的 archetype 而不依赖于目录结构，可以使用 --kind 参数，像这样：\nhugo new posts/我的新博客帖子.md --kind blog 这命令会创建一个新的内容文件 posts/我的新博客帖子.md，并使用 archetypes/blog.md 作为模板。\n在文章内链接导航其他文章 在Hugo中创建文章间的超链接，最佳实践是使用相对URL或者Hugo的内置函数来生成URL。这样做的好处是可以保持链接的持久性，即使你的站点URL发生变化，链接也不会断裂。以下是几种在Hugo中链接到另一个本地文章的方法：\n1. 使用相对URL 如果知道目标文章的路径，可以直接在Markdown文件中使用相对URL创建链接。例如，如果想从位于 /content/posts/my-first-post.md 的文章链接到 /content/posts/my-second-post.md，可以这样写：\n请查看我的[第二篇文章](../my-second-post/) 这里使用的是相对于当前文件的路径。注意，链接的路径部分应该与目标Markdown文件的位置相对应，且通常情况下，不包括文件扩展名.md。\n2. 使用Hugo的ref和relref短代码 Hugo提供了ref和relref短代码，这两个短代码可以生成到站点内任何页面的永久链接。这是一种更健壮的链接方法，因为它不依赖于站点的部署路径。这两个短代码的区别在于ref可以用于任何站点（得到绝对路径）页面，而relref仅用于相同语言（得到相对路径）的页面。\n假设想链接到位于/content/posts/know/blog-tips.md的文章，可以在任何Markdown文件中这样写：\n请查看我的[第二篇文章](两个{\u0026lt; relref \u0026#34;/posts/know/blog-mac-style-code.md\u0026#34; \u0026gt;两个}) 实际效果就是这样的：\n请查看我的[第二篇文章](/posts/know/blog-mac-style-code/) 或者\n请查看我的[第二篇文章](两个{\u0026lt; ref \u0026#34;/posts/know/blog-mac-style-code.md\u0026#34; \u0026gt;两个}) 实际效果如下：\n请查看我的[第二篇文章](https://ahaknow.com/posts/know/blog-mac-style-code/) 使用ref或relref短代码时，需要指定目标文件的路径从content目录的下一个目录开始（也就是hugo new时使用的路径文件名）。\n当使用ref和relref短代码时，确保路径是从content文件夹开始的相对路径，并且包括文件的扩展名.md。 如果站点支持多语言，relref是链接到当前语言下的相对内容，而ref可用于链接到任何语言的内容（因为hugo的不同语言通过url区分）。 使用ref和relref的另一个好处是，如果目标链接不存在，Hugo在构建站点时会报错，这有助于你及时发现并修正死链（所以上述使用的是真实存在的文件路径）。 ","permalink":"https://ahaknow.com/posts/know/blog-tips/","summary":"记录一些实用Hugo写博客的小技巧。 —— 因为如果当时不记录，那么日后肯定不会再记录的！（懒！） 使用Archetype预设模版 在使用 hugo new 命令创","title":"Blog：Hugo写作小技巧 "},{"content":"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -100 \u0026lt;= nums[i] \u0026lt;= 100 nums is sorted in non-decreasing order. 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 判题标准:\n系统会用下面的代码来测试你的题解:\nint[] nums = [...]; // 输入数组 int[] expectedNums = [...]; // 长度正确的期望答案 int k = removeDuplicates(nums); // 调用 assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } 如果所有断言都通过，那么您的题解将被 通过。\n示例 1：\n输入：nums = [1,1,2] 输出：2, nums = [1,2,_] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：\n输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按 非严格递增 排列 “非严格递增”的意思是指：序列已经按照从小到大排序了，只不过有些元素重复了，所以是非严格递增；\n有序数列的问题，还是用双指针，只不过指针的用处稍微不同。\n快指针用来判断前后元素是否相同，慢指针用来按照需求保留。\n🥬上菜 这个问题可以使用类似于LeetCode26的解决方案，即使用双指针法。这次也是使用快慢指针，但是有一点不同：当快指针指向的元素与慢指针指向的元素相同时，只移动快指针，以跳过重复的元素；当快慢指针指向的元素不同，将快指针的元素复制到慢指针的下一个位置，然后同时移动快慢指针。\n这样处理后，数组的前 k 个元素就是唯一的元素，并且保持了它们最初的相对顺序，其中 k 是返回的数组长度。\n下面是具体步骤：\n如果数组的长度 n 小于等于1，则直接返回 n（因为没有重复元素需要删除）。 初始化两个指针 slow = 1 和 fast = 1。 当 fast 小于数组长度时，比较 nums[fast] 和 nums[fast - 1]： 如果 nums[fast] 不等于 nums[fast - 1]，说明遇到了一个新的元素，就将 nums[fast] 的值复制到 nums[slow]，然后 slow 增加1。 否则，快指针 fast 继续前进，直到找到一个不同的元素。 当数组遍历完成后，slow 指针的位置就是新数组的长度。 下面是用C++实现的代码示例：\n// 26. Remove Duplicates from Sorted Array #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() \u0026lt;= 1) return nums.size(); int slow = 1; for (int fast = 1; fast \u0026lt; nums.size(); fast++) { if (nums[fast - 1] != nums[fast]) { nums[slow++] = nums[fast]; } } return slow; } }; // 这道题也可以直接使用vector的earse()和unique() // nums.erase(unique(nums.begin(), nums.end()), nums.end()); 这段代码通过双指针法高效地实现了原地删除数组中的重复项，且只使用了 O(1) 的额外空间。由于 nums 是非严格递增排列的，可以确保所有的重复项都是连续出现的，这让问题变得更加简单。\n","permalink":"https://ahaknow.com/posts/know/leetcode-26-remove-duplicates-from-sorted-array/","summary":"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things: Change the array nums such that the first","title":"Leetcode：26删除有序数组中的重复项"},{"content":"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i \u0026lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例 1：\n输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2：\n输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,3,0,4] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示：\n0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100 这道题的用意是指，不能用额外空间。\n不能用额外空间，那就用两个指针。快慢指针，这种设计很巧妙，快指针遍历，慢指针覆盖，因为有筛选，所以原始数组的大小够用\n🥬上菜上菜 可以使用双指针法来实现原地算法。具体来说，可以采用快慢指针的策略：快指针（fast）遍历数组，慢指针（slow）指向更新数组的下一个位置。当遇到与 val 相等的元素时，快指针继续前进，跳过这些元素；当遇到不等于 val 的元素时，将其复制到慢指针的位置，然后慢指针前进。这样，所有不等于 val 的元素都被移动到数组的前面，且不需要使用额外的空间。\n下面是具体的步骤：\n初始化两个指针：fast = 0, slow = 0。 遍历数组，fast 作为遍历的指针，slow 指向下一个可能存放非 val 元素的位置。 如果 nums[fast] 不等于 val，就将 nums[fast] 的值复制到 nums[slow]，然后 slow 前进一位。 fast 指针每次循环都前进一位。 当 fast 遍历完整个数组后，slow 的位置即为新数组的长度。 这种方法之所以高效，是因为它避免了对 val 元素的重复检查和不必要的元素移动。\n下面是用C++实现的代码示例：\n// 27. Remove Element #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 快慢指针 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { // 快指针遍历数组，慢指针按需替换 int slow = 0; for (int fast = 0; fast \u0026lt; nums.size(); fast++) { if (nums[fast] != val) { nums[slow++] = nums[fast]; } } return slow; } }; // 当返回slow后，之后nums[]里有多少个元素，同时nums[]slow位置及以前的都已经按要求替换好，slow位置以后的不管了 这段代码中，fast 和 slow 两个指针分别扮演了遍历数组和更新数组的角色。通过这种方式，可以实现原地修改数组，同时只使用 O(1) 的额外空间。\n","permalink":"https://ahaknow.com/posts/know/leetcode-27-remove-element/","summary":"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things: Change the array nums such that","title":"Leetcode：27移除元素"},{"content":" LeetCode上“最简单”的一道题了吧？\n长时间没有写过题，面试的时候竟然不会写了，奇耻大辱的一件事！\nYou are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints:\nnums1.length == m + n nums2.length == n 0 \u0026lt;= m, n \u0026lt;= 200 1 \u0026lt;= m + n \u0026lt;= 200 -109 \u0026lt;= nums1[i], nums2[j] \u0026lt;= 109 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意: 最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n示例 1：\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2：\n输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3：\n输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示：\nnums1.length == m + n nums2.length == n 0 \u0026lt;= m, n \u0026lt;= 200 1 \u0026lt;= m + n \u0026lt;= 200 -109 \u0026lt;= nums1[i], nums2[j] \u0026lt;= 109 直接使用“双指针”的写法！\n（你还记得你多年未写算法题，想到了双指针，结果一上来写了两个for的蠢事嘛🤣）\n🥬直接上菜 从两个数组的末尾开始，每次取两者之中较大的数，放到 nums1 的合适位置。这样，当 nums2 被完全复制到 nums1 后，合并就完成了，因为 nums1 和 nums2 本来就是有序的。\n下面是详细的步骤：\n初始化两个指针 p1 和 p2 分别指向 nums1 和 nums2 的有数值的末尾，即 p1 = m - 1, p2 = n - 1。同时，初始化 p 指向 nums1 的末尾，即 p = m + n - 1。 比较 p1 和 p2 指向的值，将较大的值放在 p 位置上，并移动指针 p 和被选中的 p1 或 p2。 如果 p2 \u0026gt;= 0 而 p1 \u0026lt; 0，意味着 nums1 已经被遍历完，但 nums2 还有元素未被复制过去，此时直接将 nums2 的剩余元素复制到 nums1 的前面。 如果 p1 \u0026gt;= 0 而 p2 \u0026lt; 0，意味着 nums2 已经被遍历完，nums1 的剩余元素已经在正确的位置，不需要做任何操作。 下面是用C++实现的代码示例：\n// 88. Merge Sorted Array #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 逆向双指针 class Solution { public: void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums1, int m, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int n) { // 确定终点指针 // 合并后留下nums1数组 int p1 = m - 1, p2 = n - 1, p = m + n - 1; // 因为已经排序，逆向考虑就是从大往小 while (p1 \u0026gt;= 0 \u0026amp;\u0026amp; p2 \u0026gt;= 0) { if (nums1[p1] \u0026gt; nums2[p2]) { // 从后往前，先安排大的 nums1[p--] = nums1[p1--]; } else { nums1[p--] = nums2[p2--]; } } // //这时候再看p1和p2谁大于零 // 其实只要看p2是不是大于零就行，因为是从nums2合并到nums1 while (p2 \u0026gt;= 0) { nums1[p--] = nums2[p2--]; } } }; // 这道题可以直接把两个vector加起来，然后一个sort()解决 这段代码通过从后向前遍历 nums1 和 nums2，避免了合并时覆盖 nums1 中未被检查的元素，同时减少了需要移动元素的次数。\n时间复杂度为 O(m+n)，空间复杂度为 O(1)，因为它不需要额外的存储空间。\n","permalink":"https://ahaknow.com/posts/know/leetcode-88-merge-sorted-array/","summary":"LeetCode上“最简单”的一道题了吧？ 长时间没有写过题，面试的时候竟然不会写了，奇耻大辱的一件事！ You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n,","title":"Leetcode：88合并两个有序数组"},{"content":" 我想重命名一个文件（手动操作是不可能的，懒！）\n将“清晰易懂的的线性代数，国立阳明交通大学周志成，国语版mit线性代数Gilbert Strang LA_1-3”改成“LA_1-3”\n所以，就想到了正则匹配咯～\n🍲直接上代码 import os import re # 指定你想要处理文件的目录 directory = \u0026#39;./\u0026#39; # 正则表达式匹配模式 pattern = re.compile(r\u0026#39;LA[_\\-\\d\\w\\s]+.*?\\.mp4$\u0026#39;) # 遍历指定目录下的所有文件 for filename in os.listdir(directory): if filename.endswith(\u0026#34;.mp4\u0026#34;): # 只处理扩展名为.mp4的文件 match = pattern.search(filename) # 在文件名中搜索匹配的部分 if match: new_filename = match.group() # 如果找到匹配，使用匹配的字符串作为新文件名 old_path = os.path.join(directory, filename) new_path = os.path.join(directory, new_filename) # 重命名文件 # os.rename(old_path, new_path) print(f\u0026#39;Renamed \u0026#34;{filename}\u0026#34; to \u0026#34;{new_filename}\u0026#34;\u0026#39;) 正则表达的解释 正则表达式r'(LA[_\\-\\d\\s]+[\\w\\s]*\\.mp4)$'：\nr''：在字符串前面加上r表示这是一个原始字符串，这样做可以确保字符串中的反斜杠不会被当作转义字符处理。在Python中编写正则表达式时，通常推荐这么做。\nLA[_\\-\\d\\w\\s]+.*?\\.mp4$：这个表达式从左到右的意思是：\n(和)：捕获组，这意味着匹配到的这部分表达式会被作为一个整体处理，可以从匹配结果中单独提取出来。\nLA：匹配字面量字符串\u0026quot;LA\u0026quot;。\n[_\\-\\d\\w\\s]+：这是一个字符集合，它可以匹配下划线_、短横线-、任何数字\\d和任何空白字符\\s。+表示前面的字符集合中的字符至少出现一次。\n_：匹配下划线字符。\n\\-：匹配短横线字符。在字符集中，短横线通常用来表示范围（如a-z），所以当我们想要匹配短横线本身时，需要对它进行转义。\n\\d：匹配任何数字字符。\n\\w：匹配任何单词字符（包括字母、数字和下划线）。\n\\s：匹配任何空白字符（包括空格、制表符、换行符等）。\n.*?：以非贪婪方式匹配零个或多个任意字符（除换行符外）。\n\\.mp4：匹配字面量字符串\u0026quot;.mp4\u0026quot;。点.在正则表达式中通常表示匹配任意字符，所以当我们想要匹配点字符本身时，需要对它进行转义\\.。\n$：这表示行结束符，确保字符串以我们指定的模式结尾。\n这个正则表达式用于匹配以\u0026quot;LA\u0026quot;开头，后面跟随至少一个下划线、短横线、数字或字母数字字符，然后是任意数量的任意字符（.*?表示非贪婪匹配），最后以\u0026quot;.mp4\u0026quot;结尾的字符串。\n主要是抛砖引玉，触类旁通，下次再遇到类似的，就可以自己修改啦\n正则表达式（Regular Expression，简称Regex），其核心思想是模式匹配，通过定义一个搜索模式来匹配字符串中的特定序列，这种模式可以用来进行字符串搜索、替换、分割等操作。\n🌟基本用法和常用元字符 1. 字符匹配 .：匹配任意单个字符，除了换行符。 \\d：匹配任意一个数字（0-9）。 \\w：匹配任意一个字母、数字或下划线。 \\s：匹配任意一个空白字符（空格、制表符等）。 2. 位置匹配 ^：匹配字符串的开始位置。 $：匹配字符串的结束位置。 3. 量词 *：匹配前面的字符零次或多次。 +：匹配前面的字符一次或多次。 ?：匹配前面的字符零次或一次。 {n}：匹配前面的字符n次。 {n,}：匹配前面的字符至少n次。 {n,m}：匹配前面的字符至少n次，但不超过m次。 4. 字符类 [abc]：匹配任意一个在括号内的字符（a、b或c）。 [^abc]：匹配任意一个不在括号内的字符。 5. 分组和引用 ()：将括号内的字符视为一个单独的分组。可以对整个组应用量词，也可以通过编号或名称引用组内的匹配。 |：逻辑“或”操作符，匹配左边或右边的表达式。 6. 转义 \\：转义特殊字符，使之成为字面量意义上的字符，如\\.表示点字符本身，而不是任意字符的匹配。 正则表达式示例：匹配邮箱 这是一种比较简单的写法：\n[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,} [a-zA-Z0-9._%+-]+：这部分匹配电子邮件地址的本地部分，允许字母（无论大小写）、数字、点、下划线、百分号、加号和减号。它假设这些字符可以出现一次或多次。\n@：匹配电子邮件地址中的\u0026quot;@\u0026ldquo;符号。\n[a-zA-Z0-9.-]+：这部分匹配电子邮件地址的域名部分，允许字母（无论大小写）、数字、点和减号。它假设这些字符可以出现一次或多次。\n\\.[a-zA-Z]{2,}：匹配电子邮件地址中的顶级域名，开始于一个点，后面跟着至少两个字母（无论大小写）。这里假设所有的顶级域名至少有两个字符长。\n","permalink":"https://ahaknow.com/posts/know/tech-a-regex-example/","summary":"我想重命名一个文件（手动操作是不可能的，懒！） 将“清晰易懂的的线性代数，国立阳明交通大学周志成，国语版mit线性代数Gilbert Strang LA_1","title":"技术：一个正则表达式的小例子"},{"content":" 又干了一件：“为了一碟醋，包了一锅饺子”的事。。。\n就是重新开始学习Strang老爷子的线性代数课了，然后下载了之前国内字幕组的版本（多年不好好学，英语水平明显下降了！！！），这个版本的老问题一直存在，就是某些视频音轨缺失，只有右耳机有声音（这对于一个常年降噪耳机离耳只是为了补充电量的人来说，简直不能忍。。。）\n于是……\n都是4202年了，有什么问题是写个代码解决不了的呢？\n于是Python闪亮登场✨\n废话不多说，直接上代码：\nfrom moviepy.editor import VideoFileClip, AudioFileClip from pydub import AudioSegment # 加载视频文件 video_clip = VideoFileClip(\u0026#34;./麻省理工-线性代数/[P01]Lec01_方程组的几何解释.mp4\u0026#34;) # 提取音频并保存为临时文件 temp_audio_path = \u0026#34;temp_audio.mp3\u0026#34; video_clip.audio.write_audiofile(temp_audio_path) # 使用pydub处理音频 audio_segment = AudioSegment.from_file(temp_audio_path) # 如果原始音频是立体声，分割为单声道；否则直接复制为左右两个声道 if audio_segment.channels \u0026gt; 1: mono_channels = audio_segment.split_to_mono() right_channel = mono_channels[1] # 右声道 else: right_channel = audio_segment stereo_audio = AudioSegment.from_mono_audiosegments(right_channel, right_channel) # 将处理后的音频保存为另一个临时文件 stereo_audio_path = \u0026#34;temp_stereo_audio.mp3\u0026#34; stereo_audio.export(stereo_audio_path, format=\u0026#34;mp3\u0026#34;) # 使用moviepy将新音频设置回视频 new_audio_clip = AudioFileClip(stereo_audio_path) video_clip.audio = new_audio_clip # 输出处理后的视频文件 video_clip.write_videofile(\u0026#34;./麻省理工-线性代数/[P01]Lec01_方程组的几何解释（修复）.mp4\u0026#34;) # 清理临时文件 import os os.remove(temp_audio_path) os.remove(stereo_audio_path) 这里用到两个Python的工具：pydub、moviepy，直接安装就好。\nmoviepy可以同时处理视频和音频；pydub`主要处理音频部分，这个库提供了更灵活的音频处理功能，包括声道的操作。\npip install moviepy pip install pydub 同时确保系统中也安装了ffmpeg，因为pydub依赖于ffmpeg来处理音频文件：\nbrew install ffmpeg ","permalink":"https://ahaknow.com/posts/know/tech-mp4-audio-track-repair/","summary":"又干了一件：“为了一碟醋，包了一锅饺子”的事。。。 就是重新开始学习Strang老爷子的线性代数课了，然后下载了之前国内字幕组的版本（多年不好","title":"技术：MP4的音轨修复"},{"content":" 博客里使用了自定义的字体，最开始直接采用ttf文件加载的方式，因为博客内容全部是静态存在Github上的，这种直接加载多少有点慢，所以想了一些策略。\n压缩字体 先显示后加载 压缩字体 TrueType Font (TTF) 常见的字体文件格式，由Apple和Microsoft在上世纪80年代末共同开发。TTF使用二次贝塞尔曲线来描述字符形状，这种曲线可以精确地表示复杂形状，并且在放大时保持平滑。\nWeb Open Font Format (WOFF) WOFF是专门为Web设计的字体格式，2009年成为W3C的推荐标准。WOFF是基于TTF和OpenType字体格式的，但提供了更好的压缩和额外的元数据支持。WOFF存在两个版本：WOFF 1.0和WOFF 2.0。WOFF 2.0使用了更高效的压缩算法，文件大小比WOFF 1.0更小。\n总结 TTF是一种通用的字体格式，广泛用于各种操作系统和设备，提供了高质量的矢量字体展示。而WOFF是为Web设计的字体格式，它优化了文件大小和加载性能，特别适合在线使用。选择哪种格式取决于你的具体需求：如果你需要确保字体在各种环境中的广泛兼容性，TTF可能是更好的选择；如果你主要关注网页性能和加载速度，WOFF将是更优的选择。\n在MacOS上直接本地转换ttf字体。\n安装woff2工具：\nbrew install woff2 使用以下命令将TTF字体文件转换为WOFF2格式：\nwoff2_compress path/to/your/font.ttf 这会生成一个与原始TTF文件同名，但扩展名为.woff2的文件。例如，如果源文件名为font.ttf，输出文件将会是font.woff2。\n先显示后加载 这里主要是CSS的工作：\n在CSS文件中使用@font-face规则引入转换后的WOFF2字体文件，并通过font-display: swap;属性设置字体显示策略。这样做可以确保文本在字体文件下载完成之前使用回退字体显示，从而提升页面的可用性和性能。\n@font-face { font-family: \u0026#39;MyCustomFont\u0026#39;; src: url(\u0026#39;MyFont.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;); font-display: swap; /* 使用回退字体直到自定义字体加载完毕 */ } 这里，font-display: swap;指示浏览器在自定义字体加载期间使用回退字体，一旦自定义字体加载完毕立即切换。这有助于改善首次内容渲染时间（FCP）和最大内容绘制（LCP）等性能指标。\n也可以使用Web Font Loader，这里就是JavaScript的工作了：\nWeb Font Loader允许添加事件回调和控制字体加载的行为，简单的使用方式如下（需要配合CSS中的@font-face）：\n\u0026lt;script src=\u0026#34;https://ajax.googleapis.com/ajax/libs/webfont/1.6.28/webfont.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; WebFont.load({ custom: { families: [\u0026#39;MyCustomFont\u0026#39;], urls: [\u0026#39;path/to/your/css/file.css\u0026#39;] // CSS文件的路径（可以不特别设置） } }); \u0026lt;/script\u0026gt; ","permalink":"https://ahaknow.com/posts/know/blog-font-display-acceleration/","summary":"博客里使用了自定义的字体，最开始直接采用ttf文件加载的方式，因为博客内容全部是静态存在Github上的，这种直接加载多少有点慢，所以想了一","title":"博客优化：自定义字体加速显示"},{"content":" 记不清第一次读《SLAM十四讲》是什么感受了（那会是第一次接触SLAM这个东西），可能似懂非懂，也可能不懂装懂，总之就是没懂。\n这次，时隔两年（我滴个乖，你这两年就这样荒废啦？你都学了个啥😠）重新来读，一点一点，一步一步读懂、理解透，之前可能广度优先浅尝则止了，这次是深度优先刨根问底！\n视觉SLAM概览 视觉SLAM研究和解决的到底是一个什么问题呢？\n一种感性的理解 视觉SLAM所应用的场景是通过图像数据来完成 SLAM(Simultaneous Localization and Mapping) 同时定位与建图任务。而图像是将三维空间的世界和场景“拍扁”成了一张二维平面，因此三维空间中的距离感（深度信息）在二维图像中就消失了，而且这是一种在自然情况不可逆的过程，即不通过其他手段是无法直接从图像中恢复出原有的深度信息。因此SLAM想要实现对自身的定位和对周围环境的建图，那么首先要做的就是得到图像的深度信息。\n对于图像的深度信息，根据相机软硬件的区别有不同的获取策略，通过硬件设备直接测量当然是最准的，比如RGB-D相机，具体有飞行时间原理（Time of Flight，TOF）和结构光原理（Structured Light）两种，不不过这也会有误差。\n而只有图像的情况，如果是已知相对位置关系的两张图像或者多张图像，那么问题还好些，是双目或者多目的立体匹配问题，涉及到多视图几何的知识（Multiple View Geometry，这本书已买，要读起来了！）；如果只是单张图像的话，想要恢复深度就会复杂很多，首先得是多张图像，也就是让相机动起来去模拟两个或者多个相机的情况，比如水平移动或者竖直移动，如果是随意的移动，那问题就更复杂了，因为还得知道相机运动的每一个位置之间的相对关系，这又涉及到后面要提到的问题：视觉里程计（Visual Odometry, VO），用来估计相邻图像所对应相机的运动，并且如果没有绝对物理尺寸作为参考，这种相对的比例放大或者缩小都不会对结果产生实际性的影响，因此这里的尺度（Scale）是不确定的。这里做一个引子，下一篇学习用来介绍如何通过图像估计出深度。\n假设现在能够获取到图像的深度，从图像像素位置能够恢复出其在空间中的三维坐标，这里需要用到相机模型和投影关系的知识，这也需要在后面的学习中补充。\nSLAM想要做的同时定位和建图，这两者都需要知道自身是怎么运动，也就是相机的位置变换是怎么样的，这时候就需要用到视觉里程计的理论：**相邻图像中如果确定同一个点（从像素点对应到三维空间的一点），然后这个点对应的空间点与相机之间的几何关系，从这个几何关系中估计相邻图像对应相机的位置变换。**这一块也是后面学习的重点。\n假设能够实现相邻图像间位置变换关系的计算了，下一步是将一系列这样的相邻对一起计算，得到一个完整的位姿（位置和姿态）序列，由于传感器的噪声也是很难完全去除的，估计的误差也就不可避免，两个两个进行简单计算时可能误差很小，但是这些很小的误差累积起来就会让结果偏差很大，因此只是完成了单纯的视觉里程计还不够，还需要能够把偏差纠正回来。\n**完整的SLAM还需要对位姿估计进行优化，降低系统噪声的影响，同时对于累积的误差可能产生的质变差异，也就是累积漂移（Accumulating Drift），比如实际是起点终点一致，但估计出来终点和起点直接劈叉了，这就需要通过“回环检测”的策论纠正过来。**两者具体实现起来都比较复杂，这也是后面学习需要突破的。\n简单小结一下：\n如果将SLAM按照“外在表现”和“内在服务”这种思路来划分，视觉里程计可以归为“前端”，并且其中所涉及的理论主要与计算机视觉相关。而对于提取的空间点和估计的位姿进行的优化则可以归为后端，因为这些需要优化的数据涉及各种复杂的几何关系，本身就不是线性的，所以后端常用的是一些滤波和非线性优化的算法（……写到这，其实对于滤波在干啥竟然没有直观的感觉，说明此前的学习真的很拉垮！）最后的回环检测同样也会涉及到计算机视觉的理论，比如图像的相似性，由于回环检测的结果会使得整个位姿估计的结果发生整体的纠正，因此可以看作是SLAM前后端之间的纽带。（……好吧，其实写到这，对于怎么进行回环的，也是一脑子懵逼。。。）\n最后的一部分是建图，SLAM讲究的建图需要从两方面来看。\n同时定位的目的是为了构建出地图，根据需要可以构建不同类型的地图，且这个地图能在之后被使用，比如导航，路径规划，重定位等； 建图的本质是通过相机的位姿将相机看到的场景再“拼接”成一个完整的空间，这时如果只选取场景中的代表特征，比如角点、边缘，一般称之为路标（Landmark），那么构建就是一种稀疏的地图；而如果是将整张图像的每一个点（都知道相应的深度）都拿来建图，那么就会得到一个较为稠密的地图，这种地图一般也为点云地图。 到此，SLAM到底是在干啥算了有一个初步的感性认识了，下面还有内容一些需要补充说明。\n关于稠密与稀疏的讨论 这里对地图的稀疏和稠密程度，是一种相对而言的概念，有这样一个观点：\n你看点云地图，即使它再稠密，将这个点云放大来看，那么点与点之间也是有空隙的，这算稠密嘛？\n在讨论点云地图是否稠密时，我们通常不是指点与点之间完全没有空隙，而是相对于感知系统的分辨率和所需的应用精度来说，数据点的密度足够高。\n稠密地图在SLAM和机器视觉中通常是相对定义的。例如，对于某些应用，如导航或障碍物避让，一个地图可能不需要细致到毫米级别的每一个细节，只要能够较为准确地表示出环境的主要结构和障碍物位置，这样的地图就可以被视为是“稠密”的。\n然而，如果应用需要更高精度的环境建模，例如在精密工业应用中，那么即使是通常意义上的稠密点云地图也可能被视为不够稠密。这是因为在放大观察时，点与点之间的空隙可能导致精度不足，这个时候可能就需要网格化（meshing）的操作。\n补充知识 以下为本次学习中发散思维想到的一些知识点的理解和补充。\nSLAM地图的类型及其适用场景 稀疏地图 特点：包含关键的特征点或路标。 应用场景：适用于需要快速、实时响应的场合，如在资源受限的设备上进行基本导航和避障。 稠密地图 特点：提供环境的详尽几何描述。 应用场景：用于需要高度精确的任务，如在复杂环境中进行精细操作的机器人，或者那些需要高精度视觉信息来进行详细分析的应用。 语义地图 特点：不仅记录物理形状，还标注物体的类别信息（如椅子、桌子、门等）。 应用场景：适用于高级交互、辅助机器人和增强现实应用。例如，辅助机器人利用语义地图识别并与特定物体交互，如抓取物品或开关门。 2D地图和3D地图 2D地图：主要用于平面环境，如家庭或仓库中的地面机器人导航。 3D地图：提供环境的三维结构，适用于复杂或多层环境，如多层建筑内的导航或飞行机器人。 点云网格化 网格化是一种将散乱的点云数据转化为连续三维表面的技术。通过这种方式，可以用三角形网格来近似表示物体的表面，从而提高模型的视觉和计算效果。这不仅可以填补点与点之间的空隙，还能提供更平滑、更详细的表面模型，有助于进行更精确的计算和可视化。\n点云网格化的常见方法 Delaunay 三角剖分：\n这是一种常用的方法，可以生成三角网格，通常用于2D和3D空间中。它尝试保证在三角形网格的每个三角形的圆周上没有其他点存在，这有助于最大化最小角，从而避免生成细长的三角形。 泊松表面重建：\n泊松方法是一种流行的3D重建技术，用于从点云中推导出一个平滑的曲面。它基于假设一个隐式表面可以通过点云定位，然后通过求解一个泊松方程来找到最佳的表面。 Marching Cubes 算法：\n这是一个用于提取等值面并创建三角网格的算法。在医学成像和科学可视化中尤其常见。它通过逐个检查数据体积的立方体（或“体素”）的网格，根据边界上的点来构造表面。 Greedy Projection Triangulation：\n这种方法适用于较大的点集，它依赖于贪婪策略来逐步构建三角网格。它通常从一个点开始，逐步向外扩展，直到覆盖所有点。 ","permalink":"https://ahaknow.com/posts/know/slam14-ch2/","summary":"记不清第一次读《SLAM十四讲》是什么感受了（那会是第一次接触SLAM这个东西），可能似懂非懂，也可能不懂装懂，总之就是没懂。 这次，时隔两年","title":"SLAM十四讲第二讲：初识SLAM"},{"content":"第一讲里没有具体需要好好理解的部分，不过自测题目题目值得过一遍。\n1.线性方程Ax=b的求解 有线性方程$Ax=b$，若已知$A,b$，需要求解$x$，该如何求解？这对$A$和$b$有哪些要求？\n（提示：从$A$的维度和秩的角度来分析）\n这个问题很简单，但是值得全面地分析和理解：\n首先假设$A$是一个$m \\times n$矩阵，$x$是一个$n \\times 1$的列向量，$b$是一个$m \\times 1$的列向量。这里的$m$表示方程的数量，$n$表示未知数的数量。\n先从矩阵的秩出发来理解，以列的角度看，矩阵的秩表示了所有列向量线性组合所能达到的空间范围，对于方程$Ax=b$，如果向量$b$在矩阵$A$的列空间中（$b$可以被$A$的列向量线性表示），那么存在至少一个解$x$使得$Ax=b$，因此就有了下面的判断性质（比较矩阵$A$和增广矩阵$A|b$秩的关系）：\n$rank(A) = rank(A|b)$：表明向量$b$在矩阵$A$的列空间中，因此至少存在一个解$x$使得$Ax=b$。 $rank(A) \u0026lt; rank(A|b)$：表明$b$不在$A$的列空间中，因此没有解。 然后再分析$rank(A)$来确定解的情况，是有唯一解还是存在多个解：\n如果$rank(A)=n$（未知数的数量，也就是列的数量），则$A$的所有列向量都是线性独立的，意味着对于给定的$b$，存在唯一的$x$满足$Ax=b$。 如果$rank(A)\u0026lt;n$，则$A$中的某些列向量是其他列向量的线性组合，意味着给定的$b$时，这些可以被其他列向量表示的向量不参与线性组合出$b$，也就可以有任意值作为系数，导致存在无限多个解。 线性方程$Ax=b$的求解方法 ‼️以下的回答来自GPT，自己还不是很理解，需要重新系统学习线性代数的知识后再进行自己的消化吸收！\n超定系统：$m \u0026gt; n$，方程数量多于未知数。 欠定系统：$m \u0026lt; n$，方程数量少于未知数。 适定系统：$m = n$，方程数量等于未知数。 LU分解 原理：将矩阵$A$分解为两个特殊的矩阵乘积，一个下三角矩阵$L$和一个上三角矩阵$U$，即$A=LU$。这样，原始问题$Ax=b$变为求解两个更简单的线性方程组$L(Ux)=b$。 求解过程：首先解$L\\mathbf{y}=b$找到$\\mathbf{y}$，然后解$Ux=\\mathbf{y}$找到$x$。 适用性：特别适用于适定系统，也可用于某些类型的超定和欠定系统，假设$A$可以进行有效的LU分解。 QR分解 原理：将矩阵$A$分解为一个正交矩阵$Q$和一个上三角矩阵$R$，即$A=QR$。正交矩阵具有性质$Q^TQ=I$（$I$是单位矩阵）。 求解过程：利用$Q$的正交性质，原方程$Ax=b$变为$QRx=b$，进一步化简为$Rx=Q^Tb$，然后可以通过回代求解上三角方程组$Rx=Q^Tb$来找到$x$。 适用性：适用于所有类型的系统，尤其是超定系统，因为QR分解提供了一种求解最小二乘问题的自然方法。 奇异值分解（SVD） 原理：SVD将矩阵$A$分解为三个矩阵的乘积，即$A=U\\Sigma V^T$，其中$U$和$V$是正交矩阵，$\\Sigma$是对角矩阵，对角线上的元素是所谓的奇异值。 求解过程：对于方程$Ax=b$，可以转换为$\\Sigma y=U^Tb$（这里$y=V^Tx$），然后通过求解$\\Sigma y=U^Tb$来找到$y$，进一步求得$x=Vy$。 适用性：SVD是一种非常强大的方法，特别是对于奇异矩阵或矩阵秩不满的情况，因为它允许计算伪逆矩阵$A^+$，即使在$A$不可逆的情况下也能找到最小二乘解或最小范数解。 迭代方法求解 原理：迭代方法是从一个初始估计开始，通过重复应用迭代公式来逐步逼近方程的解。常见的迭代方法包括雅可比方法、高斯-赛德尔方法和共轭梯度法等。 求解过程：根据具体的迭代公式，每一步都基于前一步的结果来更新解的估计值，直至满足某个终止条件（如解的变化小于某个阈值）。 适用性：迭代方法特别适用于大规模稀疏矩阵的系统，因为它们通常不需要矩阵分解，而矩阵分解在大规模问题上可能非常昂贵。 2.高斯分布 高斯分布是什么？它的一维形式是什么样子？它的高维形式是什么样子？\n高斯分布，也称为正态分布，高斯分布可以被视为描述自然和人为现象中随机误差的理想模型，其普遍性来源于中心极限定理（Central Limit Theorem, CLT），这个定理说明了许多小效应的累积可以产生高斯分布的现象，具体而言就是：“大量相互独立且分布相同的随机变量之和趋向于服从正态分布，无论原始随机变量的分布如何。”\n高斯分布的一维形式 一维高斯分布（或简称为正态分布）的数学表达式为：\n$$ f(x | \\mu, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right) $$\n其中，$\\mu$是分布的均值，$\\sigma^2$是方差，$\\sigma$是标准差。这个公式描述了在给定均值$\\mu$和方差$\\sigma^2$的情况下，随机变量$X$取特定值$x$的概率密度。图形上，一维高斯分布是一个对称的钟形曲线，其中心位于均值$\\mu$，曲线的宽度由标准差$\\sigma$决定。\n高斯分布的高维形式 高维高斯分布，或多变量高斯分布，是一维高斯分布在多维空间中的推广。其数学表达式为：\n$$ f(\\mathbf{x} | \\boldsymbol{\\mu}, \\Sigma) = \\frac{1}{\\sqrt{(2\\pi)^k |\\Sigma|}} \\exp\\left(-\\frac{1}{2}(\\mathbf{x}-\\boldsymbol{\\mu})^T \\Sigma^{-1} (\\mathbf{x}-\\boldsymbol{\\mu})\\right) $$\n其中，$\\mathbf{x}$是一个$k$维随机向量，$\\boldsymbol{\\mu}$是均值向量，$\\Sigma$是协方差矩阵，$|\\Sigma|$是协方差矩阵的行列式。高维高斯分布的图形是在多维空间中的一个“山峰”，其中心位于均值向量$\\boldsymbol{\\mu}$，“山峰”的形状和方向由协方差矩阵$\\Sigma$决定。\n协方差是衡量两个随机变量联合变化趋势的度量。如果两个变量的增减趋势相同（即一个变量增加时，另一个也增加），则它们的协方差为正；如果一个变量增加时另一个减少，则协方差为负。\n对于两个随机变量$X$和$Y$，协方差定义为$Cov(X, Y) = E[(X - \\mu_X)(Y - \\mu_Y)]$，其中$\\mu_X$和$\\mu_Y$分别是$X$和$Y$的均值，$E$表示期望值操作。\n3.C++基本知识 C++中的类是什么？STL是什么？模版又是什么？\n（将基本常用的举例出来进行说明）\nC++11的新特性以及其他标准\n对于C和C++，我觉得需要系统的课程来学习补充，边用边学是持续的，先打好基础，边学边成长才更好\n以下只是对这个回答的简要回答（举例说明）\n类（Class） 类是C++中用于数据封装和面向对象编程的基本构建块。它定义了一种数据类型的蓝图，包括数据成员（属性）和成员函数（方法），用于操作这些数据。\nclass Car { public: Car(int y, const std::string\u0026amp; m) : year(y), model(m) {} void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;Year: \u0026#34; \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#34;, Model: \u0026#34; \u0026lt;\u0026lt; model \u0026lt;\u0026lt; std::endl; } private: int year; std::string model; }; 标准模板库（STL） STL是一组模板化的通用类和函数的集合，提供了常见的数据结构（如向量、列表、队列等）和算法（如排序、搜索等）。STL的核心组成部分包括：\n容器：存储数据的数据结构。例如std::vector、std::list、std::map等。 算法：操作数据的函数，例如std::sort、std::find。 迭代器：提供对容器中元素的访问方式。 #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {4, 1, 3, 5, 2}; std::sort(vec.begin(), vec.end()); for(int i : vec) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } 模板（Template） 模板允许在不指定具体类型的情况下编写代码。它们使得可以创建泛型类和函数，使代码更加灵活和可重用。\ntemplate \u0026lt;typename T\u0026gt; T add(T a, T b) { return a + b; } // 使用模板函数 int result = add\u0026lt;int\u0026gt;(1, 2); C++11/14/17的新特性举例 C++11 自动类型推断（auto）：让编译器自动推断变量的类型。 基于范围的for循环：简化了集合的遍历。 智能指针：如std::shared_ptr和std::unique_ptr，管理动态分配的内存。 Lambda表达式：允许定义匿名函数。 C++14 泛型Lambda：Lambda表达式中使用自动类型推断。 返回类型推断：函数的返回类型可以被自动推断。 C++17 结构化绑定：允许从数组或元组中一次性解包多个值。 内联变量：对于头文件中的全局变量，允许多个源文件中包含同一个变量而不会引起重定义错误。 std::optional：表示一个可能不存在的值。 4.Linux必备的操作 Linux必备知识 基本命令行操作: 理解如何使用命令行界面（CLI）进行文件系统的导航（如cd, ls, pwd）、文件操作（如cp, mv, rm, mkdir）和文本文件查看与编辑（如cat, nano, vi/vim）。\n软件安装与管理: 熟悉所用发行版的包管理器，如Ubuntu的apt, CentOS的yum或Fedora的dnf，用于安装、更新和管理软件包。\n权限和用户管理: 了解文件权限（chmod, chown）和用户管理命令（useradd, usermod, groupadd），以及如何使用sudo来执行需要超级用户权限的命令。\n进程管理: 学会如何使用ps, top, htop, kill, 和systemctl来查看和管理运行中的进程和服务。\n网络配置和故障排除: 掌握使用ifconfig/ipconfig, ping, netstat, ss, traceroute等命令进行网络配置和故障排查。\nShell脚本编写: 学习基本的Shell脚本编写，以自动化日常任务。\n文件系统管理: 了解不同的文件系统类型，磁盘分区（fdisk, parted），以及如何挂载和卸载文件系统（mount, umount）。\n安全和防火墙: 基本的系统安全知识，如使用iptables或ufw管理防火墙规则，以及使用ssh进行安全远程登录。\nLinux的一些“术” 使用man命令: 几乎所有Linux命令都有手册页，通过man \u0026lt;命令名\u0026gt;可以查看详细的使用说明和选项。 命令行自动完成: 通过按Tab键自动完成命令名称或参数，这不仅可以加快命令输入速度，还可以帮助记忆命令。 使用apropos命令: 如果不确定使用哪个命令，可以通过apropos \u0026lt;关键词\u0026gt;来搜索相关的命令。 建立个人命令备忘录: 当学习新命令时，将它们记录在笔记中，随时查阅。 Linux安装软件 在使用apt（或apt-get）在Ubuntu或基于Debian的系统中安装软件时，软件包通常会被安装到系统的标准目录下，这遵循了Linux的文件系统层次结构标准（FHS）。大部分可执行文件会放置在/usr/bin/或/usr/local/bin/目录下，库文件通常位于/usr/lib/或/usr/local/lib/，而配置文件大多数在/etc/下。文档和示例文件可能位于/usr/share/doc/。\n如何安装软件 如果你只是模糊知道某个软件包的名字，可以使用apt提供的搜索功能来查找正确的软件包名。以下是步骤和示例，以Eigen这个数学库为例：\n更新软件包列表：首先，最好更新本地软件包列表，以确保搜索和安装的是最新版本的软件。在终端中运行：\nsudo apt update 搜索软件包：如果不确定软件包的确切名称，可以使用apt-cache search命令进行搜索。例如，如果要搜索Eigen，可以运行：\napt-cache search eigen 这将列出所有与“eigen”相关的软件包。在结果中，会看到很多与Eigen相关的包，其中可能包括实际的Eigen库包和其他相关包。\n安装软件包：一旦你找到了想要安装的确切软件包名称，就可以使用apt-get install命令进行安装。如果结果显示Eigen的开发包是libeigen3-dev（这是一个常见的包名，用于包含Eigen库的开发文件），就可以运行：\nsudo apt-get install libeigen3-dev 这条命令会安装Eigen库及其所有依赖项。\n如何找到安装的软件 如果想知道apt安装的软件具体放在哪里，可以使用dpkg -L命令来列出软件包安装的所有文件的位置。例如，要找到libeigen3-dev安装的所有文件，可以运行：\ndpkg -L libeigen3-dev 这将列出所有由该软件包安装的文件和目录的路径，包括库文件、头文件、文档等。\n✨Linux的文件系统 Linux的文件系统层次结构标准（FHS, Filesystem Hierarchy Standard）定义了操作系统中目录和目录内容的标准布局。这种标准化设计使得开发者和用户能够预测在任何基于Linux的系统上找到特定类型文件的位置。以下是一些主要目录及其用途的简要说明：\n根目录 / 在Linux中，所有的文件和目录都从根目录开始。这是整个文件系统的起点。\n/bin 这个目录包含执行文件（二进制文件），这些文件是系统启动和运行所必需的，同时也存放了用户常用的命令（如ls, cp等）所依赖的执行文件。\n用例：存放基本的命令，如grep, echo, sleep。这些命令在单用户模式下或紧急恢复时也必须可用。\n/boot 包含启动Linux系统所需的文件，比如Linux内核（vmlinuz），引导加载程序（GRUB或LILO）的配置文件等。\n/dev 这个目录下包含设备文件。Linux将设备视为文件，这些设备文件代表系统中的硬件组件。\n/etc 包含系统配置文件。这些文件只能被根用户或具有适当权限的用户修改。这里包括系统启动脚本、网络配置文件等。\n用例：包含如/etc/passwd（用户账户信息）和/etc/fstab（文件系统挂载的静态信息）等关键配置文件。\n/home 用户的个人目录位于此处。每个用户都有一个与其用户名对应的目录，用于存储个人文件、配置等。\n/lib 包含系统最基本的共享库和内核模块。这些库支持位于/bin和/sbin目录中的二进制文件。\n用例：存放动态链接库（如libc.so.6），它们是执行/bin和/sbin下命令所必需的。\n/media和/mnt /media通常用于挂载可移动媒体设备，如CD-ROMs、USB驱动器等，而/mnt则用作临时挂载文件系统的目的。\n/opt 用于安装“可选”的软件应用。这些是非基本系统软件，通常作为整个应用程序安装在这里。\n用例：第三方应用程序如Google Chrome或某些商业软件可能会安装在这里，每个应用通常有其自己的子目录。\n/proc 这是一个虚拟文件系统，提供对内核和进程信息的接口。它并不占用磁盘空间，而是在内存中动态生成。\n/root 这是系统管理员，也就是root用户的家目录。这与/home目录分开，为了安全性和管理方便。\n/sbin 包含系统管理和维护的必需的执行文件，这些命令通常由root用户运行，如fdisk, ifconfig, swapon等。\n/tmp 一个临时文件存储区域。系统和用户可以在这里创建临时文件。通常，此目录在系统重启时会被清空。\n/usr 包含用户程序和数据。它是Unix System Resources的缩写。随着时间的推移，/usr目录已经成为存储共享系统资源的主要目录。\n/usr/bin：包含用户安装的非系统必需的执行文件。 /usr/lib：类似/lib，但是为/usr/bin下的程序提供库支持。 /usr/local：用于系统管理员安装本地软件，保持与由包管理器安装的软件的分离。 用例：/usr/bin下可能会有如python, gcc等用户级程序。 /var 包含经常变化的文件，如日志文件、打印队列、邮件等。\n/var/log：存放系统日志文件，如/var/log/syslog或/var/log/apache2。 /var/mail：存储用户的邮件。 /var/cache：用于存放应用程序缓存数据。 用例：系统管理员可能需要定期检查/var/log来监控系统和应用程序的活动。 /srv 用于存放服务提供的数据，例如Web服务器和FTP服务器的数据文件。\n用例：如果您运行一个Web服务，网站的数据可能位于/srv/www。\n/sys 与/proc相似，/sys是一个虚拟文件系统，提供了内核、设备和驱动程序的接口。\n用例：/sys提供了一种更加结构化的方式来浏览设备和驱动程序的信息，如查询特定USB设备的信息。\n/etc/cron.* 这些目录（cron.daily, cron.hourly, cron.monthly, cron.weekly）用于存放定时执行的脚本。\n用例：自动备份脚本可能放在/etc/cron.daily中，以确保每天执行。\n5.Vim必须会的几个操作 已经不在执着于美化Vim的各种插件了（因为完全可以用更好的CLion、VSCode之类）\n‼️但是命令行中Vim最方便，但只要知道最基础的操作就足够了：怎么增删改查，怎么复制粘贴。\nVim是一个非常强大的文本编辑器，常被用于编程和脚本编辑。它的操作方式与其他文本编辑器有很大不同，主要基于键盘快捷键，分为多种模式，最主要的是普通模式（Normal Mode）、插入模式（Insert Mode）、命令模式（Command-Line Mode）和可视模式（Visual Mode）。以下是关于Vim的基本用法，包括增删改查、复制粘贴，以及批量执行命令的方法。\nVim的基本操作 进入插入模式 在普通模式下，按i进入插入模式，在光标前插入文本。 按a也可以进入插入模式，在光标后插入文本。 按I在当前行首进入插入模式，按A在当前行尾进入插入模式。 删除文本 在普通模式下，按x删除光标所在位置的字符。 按dd删除光标所在行。 要删除从当前光标位置到行尾的内容，可以使用D。 修改文本 在普通模式下，按r后跟一个字符可以替换光标所在位置的字符。 使用cw可以更改光标开始的单词，这将删除单词并进入插入模式。 查找文本 在普通模式下，按/后输入要查找的文字，然后按Enter进行搜索。按n查找下一个匹配项，按N查找上一个匹配项。 复制和粘贴 在普通模式下，按yy复制当前行，按p粘贴到光标后。 要复制多行，可以先按2yy来复制两行（2可以替换为任何数字，表示行数）。 使用可视模式（按v进入）可以选择特定的文本区域，然后按y复制。 移动操作 基本移动：h（左移）、j（下移）、k（上移）、l（右移）。 按单词移动： w：向前移动到下一个单词的开头。 b：向后移动到前一个单词的开头。 e：向前移动到当前或下一个单词的结尾。 按行移动： 0（零）：移动到当前行的开始。 ^：移动到当前行的第一个非空白字符。 $：移动到当前行的末尾。 跳转到特定行： gg：跳转到文件的第一行。 G：跳转到文件的最后一行。 :\u0026lt;行号\u0026gt;+Enter：跳转到文件中的特定行号。 屏幕移动： H：移动到屏幕顶部的行。 M：移动到屏幕中间的行。 L：移动到屏幕底部的行。 翻页： Ctrl+f：向前翻一页。 Ctrl+b：向后翻一页。 Ctrl+d：向前翻半页。 Ctrl+u：向后翻半页。 可以结合前置数字来实现“批量移动”，这意味着可以在移动命令前加上一个数字来重复该命令多次，例如：\n5j 表示向下（j）移动5行。 3w 表示向前跳过3个单词到下一个单词的开头。 10k 表示向上（k）移动10行。 4$ 表示移动到后面4行的末尾。 Vim与外部（macOS）的复制粘贴 在macOS上，从Vim复制文本到外部程序，首先需要确认你的Vim版本是否支持剪贴板（clipboard）功能。可以通过在终端中输入vim --version查看。如果看到+clipboard，则表示支持剪贴板功能；如果是-clipboard，则表示不支持，可能需要安装支持剪贴板的Vim版本，比如通过brew install vim。\n启用剪贴板支持：确保Vim版本支持系统剪贴板。\n复制文本到剪贴板：\n在普通模式下，要复制整行到系统剪贴板，使用\u0026quot;+yy。（一个一个字符来按） 要复制指定文本，先按v进入可视模式，选择需要的文本，然后使用\u0026quot;+y复制。 从外部粘贴到Vim：在插入模式下，使用Cmd+V（macOS通常的粘贴快捷键）或在普通模式下使用\u0026quot;+p来粘贴剪贴板的内容到Vim。\n一些技巧 在普通模式下，可以通过:norm命令批量执行操作。比如，:norm I//会在所有选中的行前添加//（注释掉这些行）。\n批量替换文本，可以使用:s命令。例如，要在整个文件中替换\u0026quot;old\u0026quot;为\u0026quot;new\u0026quot;，可以使用:s/old/new/g。\n在多个行前添加内容：假设想在文件的每一行前添加序号或特定标记，可以使用:norm命令。例如，:5,10norm I// 会在第5行到第10行的开头添加// 。\n转换大小写：要将选定行的文本转换为大写，可以使用:norm结合gU命令。例如，:5,10norm gU$会将第5到第10行的内容转换为大写。\n快速跳转至匹配的括号：在普通模式下，使用%可以跳转至匹配的括号，这在编辑代码时非常有用。\n撤销和重做：使用u来撤销最近的一次更改，使用Ctrl+r来重做被撤销的更改。\n打开/关闭行号显示：快速切换行号显示，可以使用:set nu!和:set rnu!来分别切换绝对行号和相对行号的显示状态。\n","permalink":"https://ahaknow.com/posts/know/slam14-ch1/","summary":"第一讲里没有具体需要好好理解的部分，不过自测题目题目值得过一遍。 1.线性方程Ax=b的求解 有线性方程$Ax=b$，若已知$A,b$，需要求解","title":"SLAM十四讲第一讲：预备知识"},{"content":" 引子：\n我们生活的世界是三维的，在三维世界中对物体的感知拥有明确的距离感，比如键盘在手的前面，显示器在键盘的前面，那么显示器就在手的更前面（这里的“前”或者“后”属于自定义的界定，也可以认为键盘在手的后面，显示器在手的更后面），而如果通过相机将这个三维世界中的场景拍成一张照片，此时三维空间中的所有距离层次就一起被“拍”进了二维图像中，形象地比喻就是将立体的空间“压”成一张了平面的表达，从此表达空间深度的维度就丢失了，并且这个过程在自然状态下是不可逆的。\n而当我们谈到三维空间（Three-dimensional space，以下称3D）的视觉感知时，则必然与深度（距离层次感）脱不开关系，也就是说，当我们用视觉（人可以用眼睛+大脑，机器可以用图像传感器+软件算法）去感知周围的环境时，只有同时获取到了深度，才有资格去讨论3D的视觉感知，否则还是停留在2D平面图像的层次。\n因此在讨论“3D视觉感知的发展”时可以将关注点聚焦在两处：\n如何提高机器视觉系统获取深度信息的精度和可靠性？（如何获得更高精度的深度信息？） 在融合图像和深度信息后，能够推动哪些3D视觉感知技术的发展？（在拥有图像和深度信息后，我们能继续做什么？） 机器视觉的深度获取 首先，我们讨论的是机器的视觉系统，关于机器视觉的定义，简言之，就是通过“某些设备”让机器能够“看到”周围的环境，在不具体追溯这些设备的软硬件实现时，我们以“相机”这个更为广泛的概念进行代替，也就是说，通过相机（相机内部还需要算法和软件支持）可以让机器“看到”这个世界，而相机实现的不同，则可以让机器看待这个世界的方式也发生改变。\n因此，比较直观地获取深度的方式是直接通过相机软硬件这个载体来实现，在这里只进行简要的介绍，因为以下的每一种相机在具体讨论时都需要大篇幅的内容进行结构、原理和方法的说明。\n从相机的角度来看，获取图像深度的方式可以分为两大类型：\n一种是通过硬件的物理测量，比如向三维空间中发射特殊的光源，这个光源接触到物体发生反射后可以回到接收装置，通过测量光源的来回传播时间获得距离信息的飞行时间原理（Time of Flight，TOF）的深度相机，以及向三维空间中投射具有特殊形状的光源，通过测量计算这些光源在物体表面发生的形变来获得距离信息的结构光原理（Structured Light）的深度相机； 另一种则是通过图像中的几何学关系计算得到，专业的表达是多视图几何（Multiple View Geometry），具体的实现可以是一个相机拍摄的多个连续场景图像，或者是两个或多个相机拍摄的同一个场景图像，其中较为成熟的是通过两个平行相机实现的双目立体视觉（Binocular Stereo Vision）相机。 具体到每一种类型的深度相机，都有其各自的关注点来提高相机获取深度的精度，在此暂不深究。从另一个角度出发，如果没有这些额外的软硬件支持，只能通过相机拍摄二维图像，怎么得到图像的深度信息呢？\n在当下能够通过数据驱动解决复杂问题的大背景下，利用机器学习（更具体一点是深度学习）直接从二维图像中估计出深度是一种技术趋势，比如在paperswithcode.com上检索“Depth Estimation”可以看到很多开源的算法和模型，并且所依赖的数据也不再限制，利用单张图像或者多张图像都有相应的方法。因此更直观的想法就是在相机中嵌入深度学习技术直接从图像中估计出深度信息，从而也就避免了采用额外硬件设备所需要的校准、标定等繁杂的维护工作。\n在深度学习里有一条基本认知是：“数据决定了深度学习的上限，而模型只是逼近这个上限而已”。也就是说，想要通过深度学习完善地解决直接的图像深度估计问题，一个好的模型固然重要，但更为关键是拥有驱动这个模型完好运转的数据燃料，并且数据的质量决定了模型效果，那么怎样获得这些高质量的数据呢？\n上文介绍的通过硬件物理测量和通过图像几何学关系获取深度的两种相机，这些在市场中已经有成熟的产品投入应用，如果用它们得到的深度数据来驱动深度学习，从理论上来讲，最理想的状态也不过是达到了深度相机的最高精度效果，并且物理测量或者几何计算本身就具有的偏差还会对模型的效果产生负面影响。\n因此，从数据驱动的深度学习方法估计图像深度的这一方向切入，如果想要让模型的结果更精确从而获取更可靠的深度信息，还需要从数据上下功夫，具体可实践的方式是使用3D仿真，通过模拟相机和构建3D场景产生所需求的且完全准确的深度信息，可以采用的工具和软件包括：\n3D建模和动画软件：Blender； 游戏物理引擎：Unity 3D，Unreal Engine； 机器人仿真器（开源）：Gazebo Sim； 自动驾驶仿真器（开源）：CARLA。 而随着人工智能的发展，特别是生成式人工智能（Generative AI）的技术，将人工智能自己生成内容的技术融入到3D仿真生成也将成为一种新趋势。\n3D视觉感知技术 有了图像深度（用Z表示）之后，我们能做什么呢？\n首先能够从二维图像恢复出三维的空间关系，图像中每一个像素点(x,y)可以通过投影关系恢复到三维空间中的点(X,Y,Z)，将这些三维的点组合起来就构成了点云（Point Cloud）。 通过点云可以分析出哪些是可以移动的区域，哪些区域不平坦；以及哪些是空间中的阻挡自身运动的障碍物，这些障碍物与自身的实时距离等，这个过程体现的就是三维空间的感知。 由于从三维空间“拍”进二维图像的过程中，距离相机更近的物体会挡住其身后的物体，因此在从二维图像恢复到三维空间时，那些被挡住的部分自然也不会呈现出来，而想要从图像中恢复出一个空间的完整样貌，就需要很多张拍摄到这个空间各个角落的图像一起“组合”，共同“拼接”来还原，这个过程就叫做三维空间的场景重建。 以上的过程在具体实现中会涉及到较多的数学原理推导，在这里没有具体展开说明，但从本质的理解出发，在拥有图像深度之后，视觉的感知就完整了，下面从移动机器人和智能驾驶两个领域来谈一谈3D视觉感知技术的具体应用。\n移动机器人领域 一般而言，移动机器人是在一个区域内运行的，也就是说，移动机器人需要拥有这个区域的地图信息，然后在已有地图的基础上再完成感知、定位、路径规划和导航，甚至在实际应用时还需要考虑对地图的更新。机器人的定位和建图可以通过SLAM（Simultaneous Localization And Mapping）技术来实现，SLAM中也需要知道深度信息，比如视觉SLAM在只提供图像的情况下时通过几何学关系来计算出深度，而如果能够同时提供足够精确的深度信息，那么SLAM的建图和定位精度也会更加准确。\n在3D视觉下，机器人可以做到对物体更加准确和丰富的感知，不仅是对物体实现简单的位置测距，在一些算法的支持下，还能够对特定的物体实现姿态的估计，在同时拥有物体的位置和姿态后，就可以展开定位、抓取等后续的操作。同时利用三维空间的场景重建技术，还能够将机器人所处的三维空间模型恢复出来，以这个三维场景为基础，可以继续构建更丰富的地图形式，以及结合3D检测分割等技术实现更具体的环境感知。\n智能驾驶领域 行驶状态中的车辆是实时运动的，并且车辆所在的道路环境也是实时变化，因此即使没有预先加载的高精度地图，智能驾驶的车辆也应该能够通过视觉或者其他传感器感知到周围环境中其他车辆或者物体的状况变化从而调整自身，这是业界常说的“轻地图，重感知”。\n智能驾驶的车辆，不同于移动机器人在一个区域内运行，也不会像移动机器人一样为了补全视野的盲区而在一个范围内来回打转，车辆的运行轨迹基本是持续向前的，因此对于3D视觉的感知更倾向于实时的呈现，通过相机持续拍摄车辆周围可以获得视频流，而同时拥有了图像深度后，这个平面图像的视频流就可以转换为三维空间的点云运动流，这个转换的过程不涉及深度学习。对点云空间也可以同样进行检测、分割等处理，从而获得周围环境的实时道路状况信息。\n近几年兴起的Occupancy Networks（占用网络）是上述描绘场景的一种近似表达，特别是MonoScene，通过一个网络模型实现了从单张图像中获取深度和语义信息再以三维栅格网络方式呈现的流程，从一定意义上掀起了占用网络的热潮。而从本质出发，如果拥有图像中每一个像素对应的精确深度，那么不管是高密度的三维空间点云还是数据量更低的栅格化网格，都可以顺畅地实现。\n3D视觉感知的本质前提是拥有足够精确的第三维度信息，也就是深度，而后再开展以3D视觉为主导的感知技术才能如鱼得水。现如今虽然说人工智能是大趋势，深度学习方法可以解决很多问题，但要驱动深度学习方法完好运转还需要充足且高质量的数据驱动，不管是先获得精确深度信息还是说直接的3D视觉感知，当应用深度学习方法时，都离不开数据。\n总的来说，3D视觉的核心是先恢复出了准确可靠的深度信息，而后再进行更具体的感知任务。一种思路是从相机本身考虑，但可能目前几种深度相机有理论的上限或者实际应用的瓶颈难以继续突破深度测量的精度和可靠性，另一种思路是完全的数据驱动，首先拥有足够量级的精准深度数据，而后不断优化深度学习的模型来达到最佳效果。3D视觉感知技术的应用也是一样，在拥有准确深度后，很多传统的感知任务都会锦上添花，当然也可以将3D视觉感知作为一个整体，在只有图像输入的情况下实现3D视觉的感知，这里就回到了应用深度学习方法解决的思路，模型优化固然重要，更必要还是高质量数据驱动。\n","permalink":"https://ahaknow.com/posts/know/3d-visual-perception/","summary":"引子： 我们生活的世界是三维的，在三维世界中对物体的感知拥有明确的距离感，比如键盘在手的前面，显示器在键盘的前面，那么显示器就在手的更前面（这","title":"3D视觉感知"},{"content":" 问题的描述是这样的（用我理解后的语言来表达）：\n以搭载2D激光雷达（2D-Lidar）的扫地机器人为例，只考虑在二维平面下的关系。世界坐标系$O_W$，机器人坐标系$O_C$，雷达坐标系$O_L$，雷达坐标系的方向轴与机器人坐标系一致，雷达搭载在机器人上，用机器人坐标系$O_C$的坐标表达，雷达的位置为$(xlc, ylc)$，现在空间中有一个物体点P，通过2D雷达对其测量（雷达旋转方向为逆时针），得到对应的角度$angle$和距离$dis$，现在假设扫地机器人运动的角速度是$w_c$，线速度是$v_c$，在$t_0$时刻时，机器人坐标系$O_C$与世界坐标系$O_W$重合，这里的角度单位都是弧度，距离单位都是米。\n现在给这样一组数据，问在$t_1$时刻时，物体点P在世界坐标系$O_W$下的坐标：\nangle、dis、xlc、ylc、 vc、wc、t1\n需要理解的前提 首先，对于输入数据的理解：可以将测试数据作为一个验证情况，因为，当世界坐标系$O_W$，机器人坐标系$O_C$，雷达坐标系$O_L$之间的关系表达明确时，不管带入什么测试数据，都应该是满足的。\n另外，有一个常识需要补充：在C++环境以及处理物体学、数学分析等进行三角函数计算时，使用的都是弧度制， 1弧度 $\\frac{180}{\\pi}$度，1 度 = $\\frac{\\pi}{180}$弧度。\ndouble degrees = 90.0; double radians = degrees * (M_PI / 180.0); double sinValue = sin(radians); // 使用弧度 🌟进行一步一步拆解 t时间后机器人运动的位置 首先需要理解，扫地机器人是怎么运动的，在这里知道机器人运动同时拥有角速度$w_c$，线速度$v_c$。\n一般情况下，移动机器人是通过控制两个并行轮子的速度差（差速）进行旋转的。两个轮子速度相同时，移动机器人将直线运动，两个轮子速度不同时，移动机器人将绕着某一点进行旋转运动，这个点就是即时转动中心（Instantaneous Center of Rotation, 简称 ICC）。\n也就是说，机器人此时的运动模型是一个圆弧运动，运动的半径$R = \\frac{v_c}{w_c}$，运动的角度可以通过$\\theta = w \\cdot t$得到，而对于机器人中心点的位置情况则可以通过极坐标的关系来得到，也就是机器人中心为一点，绕着ICC为原点，进行半径为R的圆周运动，转动了$\\theta = w \\cdot t$角度，那么转动$t$时间后机器人中心点的位置以XY坐标系（笛卡尔坐标系）表达就是：\n$X_{t} = R \\sin(w_c \\cdot t)$ $Y_{t} = R (1 - \\cos(w_c \\cdot t))$ 由此假设以机器人坐标系$O_C$原点来计算，那么在t时间后，$O_C$原点的坐标在世界坐标系$O_W$上的表达为：\n$X_{W_C} = R \\sin(w_c \\cdot t)$ $Y_{W_C} = R (1 - \\cos(w_c \\cdot t))$ 即时转动中心（Instantaneous Center of Rotation） 在任意给定瞬间，一个在平面上进行复合运动（即同时包含平移和旋转）的物体看起来是围绕一个假想点进行旋转，这个点就是即时转动中心。\n这个点可能位于物体内部，也可能位于物体外部（取决于左右轮的速度），甚至可能无限远（这种情况下，物体的运动可以看作是纯平移）。\n假设一个通过两个并行轮子进行差速驱动的移动机器人，左右轮子的速度分别为$V_l$和$V_r$，两轮中心之间距离为$L$，那么可以定义机器人的线速度$v_c$和角速度$w_c$如下：\n线速度$v_c$，表示机器人移动时机器人中心点的速度，通过左右轮速度的平均值来估计： $$ v_c = \\frac{V_r + V_l}{2} $$ 角速度$w_c$描述了机器人绕ICC的旋转速度，可以通过左右轮速度差与轮距的比值来计算（通过$v = \\omega \\cdot r$得到）： $$ w_c = \\frac{V_r - V_l}{L} $$ 机器人绕ICC的圆弧运动半径$R$（从ICC到机器人中心的距离），根据$v = \\omega \\cdot r$可以得到： $$ R = \\frac{v_c}{w_c} $$\n将上述定义的$v_c$和$w_c$代入到$R$的公式中可以得到： $$ R = \\frac{\\frac{V_r + V_l}{2}}{\\frac{V_r - V_l}{L}} $$ $$ R = \\frac{L}{2} \\cdot \\frac{V_r + V_l}{V_r - V_l} $$\n另一种数学解释 对于ICC的计算，在任意瞬间，机器人的左右轮到ICC的距离固不变，形成一个圆周运动。假设右轮比左轮快，那么ICC位于机器人左侧，ICC距离机器人的中心点为$R$。\n由于机器人的左右两个轮子绕ICC的旋转半径不同，但是它们完成一次完整旋转所需的时间相同，因此有：\n左轮的圆周速度是$V_l$，旋转半径是$R - \\frac{L}{2}$。 右轮的圆周速度是$V_r$，旋转半径是$R + \\frac{L}{2}$。 根据圆周运动的速度公式$v = \\omega \\cdot r$，得到：\n$V_l = w_c \\cdot (R - \\frac{L}{2})$ $V_r = w_c \\cdot (R + \\frac{L}{2})$ 将$w_c$带入解方程可以得到：\n$$ R = \\frac{L}{2} \\cdot \\frac{V_r + V_l}{V_r - V_l} $$\n但是更直观的方式是利用角速度和线速度的定义来直接求解$R$，如下：\n$$ w_c = \\frac{V_r - V_l}{L} \\Rightarrow w_c \\cdot L = V_r - V_l $$\n并且\n$$ v_c = \\frac{V_r + V_l}{2} $$\n而$R$可以理解为机器人（中心点）绕ICC旋转的半径，其线速度$v_c$与角速度$w_c$之间存在如下关系：\n$$ R = \\frac{v_c}{w_c} $$\n圆周运动中的位置计算 对于绕ICC的圆周运动，可以用极坐标系下的圆方程来描述物体的位置。在极坐标系中，一个点的位置由它到原点的距离（半径$R$）和一个角度（$\\theta$）来定义。\n将ICC视为原点，则机器人中心就是这个点，其位置转换为笛卡尔坐标系来表示就是：\n$X = R \\sin(\\theta)$ $Y = R - R \\cos(\\theta) = R (1 - \\cos(\\theta))$ 物体点P在机器人坐标系$O_C$的表达 将2D-Lidar看作为一个点，也就是原点$O_L$，那么在雷达坐标系$O_L$下，物体点P可以直接通过三角关系得到在雷达坐标系$O_L$的表达：\n$X_{L_p} = dis \\cdot \\cos(angle)$ $Y_{L_p} = dis \\cdot \\sin(angle)$ 而雷达坐标系$O_L$和机器人坐标系$O_C$只相差了一个平移关系，也就是$(xlc, ylc)$，因此可以将平移的量加上得到在机器人坐标系$O_C$的表达\n$X_{C_p} = dis \\cdot \\cos(angle) + xlc$ $Y_{C_p} = dis \\cdot \\sin(angle) + ylc$ 物体点P在世界坐标系$O_W$的表达 因为机器人坐标系$O_C$和世界坐标系$O_W$相差了一个旋转，机器人坐标系$O_C$从与世界坐标系$O_W$重合的状态，通过逆时针旋转$\\theta = w \\cdot t$得到现在的状态。\n也就是说，以机器人坐标系$O_C$的表达的物体点P也需要通过这个**逆时针旋转$\\theta = w \\cdot t$**得到在当世界坐标系$O_W$的表达；\n因此世界坐标系$O_W$的物体点P为$(X_{W_p},Y_{W_p})$可以通过$(X_{C_p},Y_{C_p})$应用上逆时针旋转，再加上$O_C$的偏移得到。\n$X_{W_p} = X_{C_p} \\cdot \\cos{\\theta} - Y_{C_p} \\cdot \\sin{\\theta} + X_{W_C}$\n$X_{W_p} = X_{C_p} \\cdot \\sin{\\theta} + Y_{C_p} \\cdot \\cos{\\theta} + Y_{W_C}$\n注意，逆时针为正（以右手坐标系来看，X轴朝左，Y轴朝上）\n逆时针旋转角度 $\\theta$ 的旋转矩阵的证明 从二维旋转的基本几何出发。假设我们有一个点 $P$，在原点 $O$ 的坐标系中的初始位置为 $P(x, y)$，需要求出 $P$ 绕原点逆时针旋转角度 $\\theta$ 后的新位置 $P\u0026rsquo;(x\u0026rsquo;, y\u0026rsquo;)$：\n旋转前，点 $P$ 的位置可以由极坐标 $r$（原点到 $P$ 的距离）和 $\\phi$（$x$ 轴到 $OP$ 的角度）确定。在笛卡尔坐标系中，有：\n$x = r\\cos(\\phi)$ $y = r\\sin(\\phi)$ 当 $P$ 绕原点逆时针旋转 $\\theta$ 后，它的新位置 $P\u0026rsquo;$ 可以用新的极坐标 $r$ 和新的角度 $\\phi + \\theta$ 来表示（$r$ 保持不变，因为旋转不改变原点到 $P$ 的距离）。因此，旋转后的坐标为：\n$x\u0026rsquo; = r\\cos(\\phi + \\theta)$ $y\u0026rsquo; = r\\sin(\\phi + \\theta)$ 使用三角恒等式 $\\cos(a + b) = \\cos(a)\\cos(b) - \\sin(a)\\sin(b)$ 和 $\\sin(a + b) = \\sin(a)\\cos(b) + \\cos(a)\\sin(b)$，我们可以将 $x\u0026rsquo;$ 和 $y\u0026rsquo;$ 重写为：\n$x\u0026rsquo; = r\\cos(\\phi)\\cos(\\theta) - r\\sin(\\phi)\\sin(\\theta)$ $y\u0026rsquo; = r\\sin(\\phi)\\cos(\\theta) + r\\cos(\\phi)\\sin(\\theta)$ 将 $x = r\\cos(\\phi)$ 和 $y = r\\sin(\\phi)$，代入得到：\n$x\u0026rsquo; = x\\cos(\\theta) - y\\sin(\\theta)$ $y\u0026rsquo; = x\\sin(\\theta) + y\\cos(\\theta)$ 将上述方程写成矩阵形式，得到：\n$$ \\begin{bmatrix} x\u0026rsquo; \\ y\u0026rsquo; \\end{bmatrix} = \\begin{bmatrix} \\cos(\\theta) \u0026amp; -\\sin(\\theta) \\\\ \\sin(\\theta) \u0026amp; \\cos(\\theta) \\end{bmatrix} \\begin{bmatrix} x \\ y \\end{bmatrix} $$ 这个矩阵就是逆时针旋转角度 $\\theta$ 的旋转矩阵 $R(\\theta)$，能够将任何给定的点在二维平面上逆时针旋转 $\\theta$ 角度，而不改变点到原点的距离。\n如果旋转是顺时针方向的，角度 $\\theta$ 将被视为负值，以右手坐标系来看，X轴朝左，Y轴朝上时，逆时针旋转是正方向，顺时针旋转则是负方向。\n顺时针旋转角度 $\\theta$ 的旋转矩阵可以通过将逆时针旋转矩阵中的角度 $\\theta$ 替换为它的负值 $-\\theta$ 来得到，因为 $\\cos(-\\theta) = \\cos(\\theta)$ 和 $\\sin(-\\theta) = -\\sin(\\theta)$。这意味着，对于顺时针旋转，旋转矩阵 $R_{cw}(\\theta)$ 是：\n$$ R_{cw}(\\theta) = \\begin{bmatrix} \\cos(-\\theta) \u0026amp; -\\sin(-\\theta) \\\\ \\sin(-\\theta) \u0026amp; \\cos(-\\theta) \\end{bmatrix} $$ 使用三角函数的性质 $\\cos(-\\theta) = \\cos(\\theta)$ 和 $\\sin(-\\theta) = -\\sin(\\theta)$，得到：\n$$ R_{cw}(\\theta) = \\begin{bmatrix} \\cos(\\theta) \u0026amp; \\sin(\\theta) \\\\ -\\sin(\\theta) \u0026amp; \\cos(\\theta) \\end{bmatrix} $$ 因此，顺时针旋转矩阵直接使用正角度 $\\theta$ 为：\n$$ R_{cw}(\\theta) = \\begin{bmatrix} \\cos(\\theta) \u0026amp; \\sin(\\theta) \\\\ -\\sin(\\theta) \u0026amp; \\cos(\\theta) \\end{bmatrix} $$ 这个矩阵可以用来将任何给定的点在二维平面上顺时针旋转 $\\theta$ 角度，这与逆时针旋转从形式上看只是$\\sin(\\theta)$的正负号相反。\n完整的C++实现 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; int main() { // jj double angle, dis, xlc, ylc, vc, wc, t1; std::cin \u0026gt;\u0026gt; angle \u0026gt;\u0026gt; dis \u0026gt;\u0026gt; xlc \u0026gt;\u0026gt; ylc \u0026gt;\u0026gt; vc \u0026gt;\u0026gt; wc \u0026gt;\u0026gt; t1; // angle为弧度制，wc为弧度/s // dis为距离，vc为m/s // 起点(0, 0), 角速度wc, 线速度vc // 经过t1时间 double delta_v = vc * t1; double delta_w = wc * t1; // 机器人坐标系Oc，世界坐标Ow double Xwc, Ywc; double R = vc / wc; Xwc = R * sin(delta_w); Ywc = R * (1 - cos(delta_w)); // 打印Xwc, Ywc // std::cout \u0026lt;\u0026lt; Xwc \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; Ywc \u0026lt;\u0026lt; std::endl; // 求P点在世界坐标系Ow的坐标 // 先求P点在Oc的坐标 double Xcp, Ycp; Xcp = xlc + dis * cos(angle); Ycp = ylc + dis * sin(angle); // 打印Xcp, Ycp // std::cout \u0026lt;\u0026lt; Xcp \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; Ycp \u0026lt;\u0026lt; std::endl; // 再求P点在Ow的坐标 double Xwp, Ywp; Xwp = cos(delta_w) * Xcp - sin(delta_w) * Ycp + Xwc; Ywp = sin(delta_w) * Xcp + cos(delta_w) * Ycp + Ywc; // 打印Xwp, Ywp std::cout \u0026lt;\u0026lt; Xwp \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; Ywp \u0026lt;\u0026lt; std::endl; return 0; } ","permalink":"https://ahaknow.com/posts/know/2d-coordinate-transformation/","summary":"问题的描述是这样的（用我理解后的语言来表达）： 以搭载2D激光雷达（2D-Lidar）的扫地机器人为例，只考虑在二维平面下的关系。世界坐标系$","title":"二维平面下的坐标系变换"},{"content":"就是要实现下面这种效果：\n# 就是展示一下效果^-^ 像这种想法怎么样一步步实现的呢？\n对于前端开发来说，最好的学习方式就是阅读源码学习：\n直接看实现过这个效果的的网站是怎么实现的（只要是HTML+CSS方式的，就能读出来，如果全是JS生成的，那就。。。只能另辟蹊径了。）\n","permalink":"https://ahaknow.com/posts/know/blog-mac-style-code/","summary":"就是要实现下面这种效果： # 就是展示一下效果^-^ 像这种想法怎么样一步步实现的呢？ 对于前端开发来说，最好的学习方式就是阅读源码学习： 直接看实现","title":"博客自定义：实现Mac风格的代码栏"},{"content":"以下是心路历程：\n为了写博客，因为觉得工具看着不爽，变成了学习Python后端（为啥不是Java？质问脸），开始造引擎？\n纠结于用什么博客框架，Hexo？Hugo？Halo？甚至想学JS框架自己做一个！\n最终还是回归了Hugo，因为markdown写完，直接编译，然后push就OK了；\n但是，又纠结起要不要自己租个服务器！国内服务器要备案（想想当年怎么在腾讯云备案的，又怎么气鼓鼓说再也不干这事了），so考虑香港服务器，一台服务器只是用来放博客嘛？（当然可以有很多用处，个人邮箱、下载器等等等）……\n就是一个静态博客啊，Github不就够了！！\n……\n好吧，老老实实Gitub + Hugo（当然可以Vercel自动部署，暂时用不到，Gitub Page就可以了）\n只是为了写作输出，又觉得直接的Hugo模版不够满意，再次变成了重学HTML、CSS、JS，自己动手改……\n改了一些，比如：Mac窗户风格的代码栏（甚至灵机一动还模拟鼠标放置显示关闭、最小化、最大化的效果）\n但是还是有不满意的：比如：标题下面的显示，太单调；目录能不能放置在两边，等等等等……无底深渊！\n算了，先写一篇正经的博客出来吧，剩下的想法之后慢慢补充！\n写博客到底为了啥？ 我是典型的属于“本末倒置”，不管用啥，哪怕就是文本直接展示，写博客的核心就是写啊！哪里是说：哦，这个博客引擎不行，自己写一个；那个框架看着不错，要不要换一个。重点是写先把文章写出来啊！\n就比如再写这篇文章之前，还在纠结，要不要再完善一下博客的外观……是啊，等你都完善了，菜都凉了，结果就是工具做好了，然后没有工作了，这不是搞笑嘛！放到写博客就是，兴致过去了，说要重新拾起来在写，然后精力全放在怎么把博客弄得好看点，最终精力用光了，博客又没写成，于是一年又一年，没了。\n写博客啊，你得先写再考虑展示啊！\n另外一个就是，不能拖，打死不能拖，脑袋里有想法了就写下来，不然一定会忘，不会再想起来的！血的教训！\n因此，现在我需要做的就是：\n把这两天折腾博客的东西记录下来，总结下来，沉淀下来，虽然少，但积少成多！\n以及，此前的博文写得断断续续的，也需要整理再拿出来，或者直接存着吧，今天开始，好好记录！不要停！\n","permalink":"https://ahaknow.com/posts/think/2024-begin-again/","summary":"以下是心路历程： 为了写博客，因为觉得工具看着不爽，变成了学习Python后端（为啥不是Java？质问脸），开始造引擎？ 纠结于用什么博客框架，","title":"折腾博客是为了更好地专注在写作上？"},{"content":" 让自己不后悔的话，那就动起来！\n动起来就能转起来了！\n—— 2024年4月12日补充\n话说，重新拾起要再次记录的念头，应该是一年前！\n最早开始想要记录，应该是六年前！六年啊！一恍惚就过去了？并且最可怕的事情，对比现在的自己和六年前的自己，似乎，还不如了？！！！\n六年，2190天，每天退步一点点，0.99的2190次方： $$ 0.99^{6\\times365} = 2.7610621 \\times 10^{-10} = 0.00000000028 $$ 真的是，退步的不能再退步了，也真的太可怕了。\n时间无情的走了，而我呢，日复一日，年复一年，忙忙碌碌，重重复复，一路滑向深渊。\n能不能再做到，每天思考并记录呢？以前做到过，但是中断了，能不能在捡起来，再继续做下去！\n一直对自己说，自己是内驱的，自己是自律，结果事实却在打自己脸。\n一样会沉迷于电视剧，一样会沉沦在概率游戏中。\n总之，不知好歹！！\n","permalink":"https://ahaknow.com/posts/diary/2024_first/","summary":"让自己不后悔的话，那就动起来！ 动起来就能转起来了！ —— 2024年4月12日补充 话说，重新拾起要再次记录的念头，应该是一年前！ 最早开始想要记录","title":"2024年的第一篇记录"},{"content":"💊Linux药剂 command-not-found：遇见各种Command not found时服用\n🌊艺术细胞 uhdpaper：当需要使用超高清壁纸时服用\n无用之地：有点东西！\n🥣日常服用 markdown权威指南：基础和拓展两部分语法\n","permalink":"https://ahaknow.com/toolkits/","summary":"💊Linux药剂 command-not-found：遇见各种Command not found时服用 🌊艺术细胞 uhdpaper：当需要使用超高清壁纸","title":"🧰 医疗箱"}]