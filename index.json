[{"content":" 主打一个“懒”字！\n移动文件啊，重命名啥的，动手拖拖不行嘛？！\n不行！用键盘，用命令行！\n比如：\n想要移动 ZYC01981 - 01.jpg，同时又想把 - 01 后缀给去掉，怎么做？\n好记性不如烂笔头！\n很厉害？嗯！唯手熟尔～\n要匹配任何以 \u0026quot; - 01\u0026quot;、\u0026quot; - 02\u0026quot;、\u0026quot; - 03\u0026quot;、\u0026quot; - 12\u0026quot;、\u0026quot; - 13\u0026quot; 等等等等结尾的 .jpg 文件，可以这样写：\nfind . -type f -regex \u0026#39;.* - [0-9][0-9]\\.jpg\u0026#39; 这个正则表达式会匹配任何以两位数字结尾的 .jpg 文件。如果需要限制特定的数字，则可以调整正则表达式的数字部分。例如，只匹配以 \u0026ldquo;01\u0026rdquo;、\u0026ldquo;02\u0026rdquo;、\u0026ldquo;03\u0026rdquo;、\u0026ldquo;12\u0026rdquo;、\u0026ldquo;13\u0026rdquo; 结尾的文件：\nfind . -type f -regex \u0026#39;.* - \\(01\\|02\\|03\\|12\\|13\\)\\.jpg\u0026#39; 对于重命名操作，如果希望去掉文件名中的 \u0026quot; - 数字\u0026quot; 部分，可以使用以下命令（使用 echo 只打印不执行）：\nfind . -type f -regex \u0026#39;.* - [0-9][0-9]\\.jpg\u0026#39; -exec bash -c \u0026#39;echo mv \u0026#34;$0\u0026#34; \u0026#34;${0/ - [0-9][0-9]/}\u0026#34;\u0026#39; {} \\; 如果想要移动它们，则可以：\nfind . -type f -regex \u0026#39;.* - [0-9][0-9]\\.jpg\u0026#39; -exec mv {} DestinationFolder/ \\; 解释一下每个部分的作用\nfind .：\nfind 用于在目录树中查找文件和目录。 . 指定从当前目录开始搜索。 -type f：\n这个选项限制 find 命令只查找文件（不包括目录）。 -regex '.* - [0-9][0-9]\\.jpg'：\n-regex 选项让 find 使用完整的正则表达式来匹配文件路径。 '.* - [0-9][0-9]\\.jpg' 是一个正则表达式，用来匹配文件名中包含 \u0026quot; - 数字数字.jpg\u0026quot; 的文件。 -exec bash -c 'echo mv \u0026quot;$0\u0026quot; \u0026quot;${0/ - [0-9][0-9]/}\u0026quot;' {} \\;：\n-exec 选项后跟一个命令，该命令对每个找到的文件执行。在此处，它调用 bash -c，允许执行更复杂的 bash 命令。 'echo mv \u0026quot;$0\u0026quot; \u0026quot;${0/ - [0-9][0-9]/}\u0026quot;' 是一个 bash 命令。它使用 echo 预览 mv 命令的效果，而不实际执行文件移动。 \u0026quot;$0\u0026quot; 代表当前处理的文件名。 \u0026quot;${0/ - [0-9][0-9]/}\u0026quot; 是 bash 的参数替换，它在文件名中删除 \u0026quot; - 数字数字\u0026quot; 模式。 {} 是 find 命令用来代表当前找到的文件名。 \\; 表示 -exec 执行的命令结束。 -exec mv {} DestinationFolder/ \\;：\n这个命令也是 -exec 用法的一个例子，用于将找到的文件移动到指定目录。 mv 是移动（或重命名）文件的命令。 {} 代表当前处理的文件名。 DestinationFolder/ 是目标目录，所有找到的文件都会被移动到这个目录。 \\; 表示 -exec 执行的命令结束。 ","permalink":"https://ahaknow.com/posts/know/shell-move-file/","summary":"主打一个“懒”字！ 移动文件啊，重命名啥的，动手拖拖不行嘛？！ 不行！用键盘，用命令行！ 比如： 想要移动 ZYC01981 - 01.jpg，同时又想把 - 01 后缀给去掉","title":"Shell基础操作：移动文件"},{"content":" 本试题仅用于考查 C++/C 程序员的基本编程技能。内容限于 C++/C 常用语法，不涉及数据结构、算法以及深奥的语法。考试成绩能反映出考生的编程质量以及对 C++/C 的理解程度，但不能反映考生的智力和软件开发能力。\n一、请填写 BOOL , float, 指针变量 与“零值”比较的 if 语句。(10 分) 提示:这里“零值”可以是 0, 0.0 , FALSE 或者“空指针”。例如 int 变量 n 与“零值” 比较的 if 语句为:\nif ( n == 0 ) if ( n != 0 ) 以此类推。\n请写出 BOOL flag 与“零值”比较的 if 语句。（3 分） //标准答案 if ( flag ) if ( !flag ) // 如下写法均属不良风格，不得分。 if (flag == TRUE) if (flag == 1 ) if (flag == FALSE) if (flag == 0) 注解：BOOL值直接用if判断即可，没必要出现==的情况。\n请写出 float x 与“零值”比较的 if 语句。（4 分） ","permalink":"https://ahaknow.com/posts/know/c-c++-exam/","summary":"本试题仅用于考查 C++/C 程序员的基本编程技能。内容限于 C++/C 常用语法，不涉及数据结构、算法以及深奥的语法。考试成绩能反映出考生的编程质量以及对 C++/C 的理解","title":"高质量编程指南：C/C++试题"},{"content":" 在上一篇打通了读取字节流文件后，能够得到每一帧的字节数据了，这一篇就来解决为这些数据赋予实际意义。\n彩色图像采用H.264编码 -\u0026gt; 那就需要按照H.264解码\n视差图像采用LZ4压缩 -\u0026gt; 视差图保存的16位无符号整数，采用LZ4解压缩（开源）\n背景知识 LZ4 LZ4 是一个非常快速的压缩算法，提供了实时压缩速度和非常快的解压缩速度，由 Yann Collet（FaceBook大佬） 开发。它属于无损压缩算法，意味着压缩后的数据可以完全恢复到其原始形态。LZ4 主要设计用于非常高速的场景（解压速度可以达到数GB每秒），例如实时数据传输、日志数据处理等。\nH.264 H.264，也被称为MPEG-4 AVC（Advanced Video Coding），是一种广泛使用的视频压缩标准。它是由国际电信联盟（ITU-T）下的视频编码专家组（VCEG）以及运动图像专家组（MPEG）共同开发的。H.264标准的目标是提供高质量的视频传输，同时显著降低比特率，相对于以前的标准如MPEG-2和MPEG-4 Part 2，它在保持相同视觉质量的情况下，可以使文件大小减少到原来的一半以上。\nH.264 和 Qt Qt 使用 Qt Multimedia 模块来处理多媒体内容，包括视频和音频。这个模块支持多种格式，包括 H.264。使用 Qt Multimedia，开发者可以较容易地在应用中集成视频播放功能，而不需要直接处理底层的视频解码。\nQt Multimedia Widgets：可以使用 QMediaPlayer 和 QVideoWidget 来播放 H.264 视频。Qt 处理多媒体流的解码和渲染，开发者只需要关注如何控制播放器和集成到UI中。 自动解码：Qt 底层使用系统的编解码库（如 DirectShow on Windows, GStreamer on Linux）来解码视频流，包括 H.264。这意味着通常不需要手动解析 H.264 数据帧，除非需要非常定制化的处理。 FFmpeg FFmpeg 是一个开源的多媒体框架，它提供了一套全面的库和工具，用于处理视频、音频和其他多媒体文件和流。这个框架支持转码、转流、播放和分析几乎所有类型的多媒体数据。FFmpeg 包括以下主要组件：\nlibavcodec: 提供广泛的编解码器支持，是处理视频和音频编解码的核心库。 libavformat: 处理多种音视频容器格式的输入和输出。 libavutil: 包含一些辅助的实用功能，如日志管理和错误处理。 libavfilter: 提供视频和音频流的转换和操作功能。 libswscale: 处理图像色彩和像素格式转换。 libswresample: 处理音频采样数据的转换。 项目中使用LZ4 首先安装 liblz4-dev：\nsudo apt update sudo apt install liblz4-dev 有可能 CMake 仍然找不到 LZ4，这时候可以手动指定 LZ4 库和头文件的路径。首先需要确定 liblz4.so 和 LZ4 的头文件 lz4.h 的位置。这些文件通常位于 /usr/include 和 /usr/lib 下，如果不确定可以通过 find /usr -name lz4.h命令查找 。\n修改 CMakeLists.txt 文件，手动设置路径：\ncmake_minimum_required(VERSION 3.10) project(DataFrameParser) set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_STANDARD_REQUIRED True) # Find OpenCV find_package(OpenCV REQUIRED) # Include directories for OpenCV and manually for LZ4 include_directories( ${OpenCV_INCLUDE_DIRS} /usr/include ) # Link directories for LZ4 link_directories(/usr/lib /usr/lib/x86_64-linux-gnu) # Adjust this path according to your system add_executable(DataFrameParser main.cpp) target_link_libraries(DataFrameParser lz4 ${OpenCV_LIBS}) 这里，这里使用了 link_directories 和 target_link_libraries 中直接指定 lz4，而不是 ${LZ4_LIBRARIES}。这是因为没有使用 find_package 来定义 LZ4_LIBRARIES 变量。\n项目中使用FFmpeg 安装 FFmpeg 和相应的开发库：\nsudo apt update sudo apt install ffmpeg sudo apt install libavcodec-dev libavformat-dev libswscale-dev libavutil-dev 这些开发库包括用于处理视频编解码的 libavcodec，用于处理多媒体容器格式的 libavformat，以及用于视频缩放和格式转换的 libswscale 等。\n在 CMake 项目中使用 FFmpeg，则需要在 CMakeLists.txt 文件中正确设置找到和链接这些库，举例如下：\ncmake_minimum_required(VERSION 3.10) project(DataFrameParser) set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_STANDARD_REQUIRED True) # Find OpenCV find_package(OpenCV REQUIRED) # Find FFmpeg components find_package(PkgConfig REQUIRED) pkg_check_modules(AVCODEC REQUIRED libavcodec) pkg_check_modules(AVFORMAT REQUIRED libavformat) pkg_check_modules(SWSCALE REQUIRED libswscale) pkg_check_modules(AVUTIL REQUIRED libavutil) include_directories( ${OpenCV_INCLUDE_DIRS} ${AVCODEC_INCLUDE_DIRS} ${AVFORMAT_INCLUDE_DIRS} ${SWSCALE_INCLUDE_DIRS} ${AVUTIL_INCLUDE_DIRS} ) add_executable(DataFrameParser main.cpp) target_link_libraries(DataFrameParser ${OpenCV_LIBS} ${AVCODEC_LIBRARIES} ${AVFORMAT_LIBRARIES} ${SWSCALE_LIBRARIES} ${AVUTIL_LIBRARIES} ) 难点分析 不使用QT，希望能够转换为OpenCV处理的图像，因此需要使用到FFmpeg。\n由于处理的字节流，那么就需要保证能够持续的解码。也就是需要初始化一次，然后持续运行，运行结束后释放资源。\n使用 FFmpeg 解析 H.264 图像的过程和原理 初始化和配置解码器（这部分只需要初始化一次）\n查找并打开解码器:使用 avcodec_find_decoder 根据指定的编解码器ID（例如 AV_CODEC_ID_H264）来查找对应的解码器。然后使用 avcodec_alloc_context3 和 avcodec_open2 来分配并初始化解码器上下文。 设置解码上下文:配置解码器上下文，如设置时间基、延迟等。 解码过程\n读取和发送数据包:从源数据（如文件、网络流）中读取数据，并构建成 AVPacket。使用 av_read_frame 从多媒体文件读取数据帧或使用 av_init_packet 处理自定义的数据，然后使用 avcodec_send_packet 将数据包发送给解码器。 接收和解码:使用 avcodec_receive_frame 接收解码器输出的帧。该函数从解码器中提取一个解码好的帧，如果没有足够的数据解码一个完整的帧，它会返回 EAGAIN。 图像转换:使用 libswscale（或 SwsContext）将解码后的帧（通常为YUV格式）转换为其他像素格式（如RGB），以便于显示或进一步处理。 资源清理 释放资源:使用 av_frame_free、av_packet_free 和 avcodec_close 释放帧、数据包和关闭解码器。 代码实现 // 全局变量或类成员变量 AVCodecContext* context = nullptr; bool initializeDecoder() { AVCodec* codec = avcodec_find_decoder(AV_CODEC_ID_H264); if (!codec) { std::cerr \u0026lt;\u0026lt; \u0026#34;Codec not found.\\n\u0026#34;; return false; } context = avcodec_alloc_context3(codec); if (!context) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not allocate video codec context.\\n\u0026#34;; return false; } if (avcodec_open2(context, codec, NULL) \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not open codec.\\n\u0026#34;; avcodec_free_context(\u0026amp;context); return false; } return true; } void cleanupDecoder() { if (context) { avcodec_close(context); avcodec_free_context(\u0026amp;context); } } bool processH264Frame(const std::vector\u0026lt;uint8_t\u0026gt;\u0026amp; data, cv::Mat\u0026amp; image) { AVPacket* pkt = av_packet_alloc(); if (!pkt) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not allocate AVPacket.\\n\u0026#34;; return false; } av_init_packet(pkt); // set data source pkt-\u0026gt;data = const_cast\u0026lt;uint8_t*\u0026gt;(data.data()); // Unsafe cast, data must be non-const pkt-\u0026gt;size = data.size(); int ret = avcodec_send_packet(context, pkt); if (ret \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error sending a packet for decoding.\\n\u0026#34;; av_packet_free(\u0026amp;pkt); return false; } AVFrame* frame = av_frame_alloc(); ret = avcodec_receive_frame(context, frame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) { av_frame_free(\u0026amp;frame); av_packet_free(\u0026amp;pkt); return false; } else if (ret \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error during decoding.\\n\u0026#34;; av_frame_free(\u0026amp;frame); av_packet_free(\u0026amp;pkt); return false; } // Convert AVFrame to cv::Mat // yuvj420p std::cout \u0026lt;\u0026lt; \u0026#34;Pixel Format: \u0026#34; \u0026lt;\u0026lt; av_get_pix_fmt_name(static_cast\u0026lt;AVPixelFormat\u0026gt;(frame-\u0026gt;format)) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Pixel Format Enum: \u0026#34; \u0026lt;\u0026lt; frame-\u0026gt;format \u0026lt;\u0026lt; std::endl; SwsContext* img_convert_ctx = sws_getContext(frame-\u0026gt;width, frame-\u0026gt;height, static_cast\u0026lt;AVPixelFormat\u0026gt;(frame-\u0026gt;format), frame-\u0026gt;width, frame-\u0026gt;height, AV_PIX_FMT_BGR24, SWS_BICUBIC, NULL, NULL, NULL); int linesize[1] = {3 * frame-\u0026gt;width}; // RGB stride image = cv::Mat(frame-\u0026gt;height, frame-\u0026gt;width, CV_8UC3); sws_scale(img_convert_ctx, frame-\u0026gt;data, frame-\u0026gt;linesize, 0, frame-\u0026gt;height, \u0026amp;image.data, linesize); sws_freeContext(img_convert_ctx); av_frame_free(\u0026amp;frame); av_packet_free(\u0026amp;pkt); return true; } 代码分析 由于SPS（序列参数集）和PPS（图像参数集）等关键解码信息通常只在视频流的开始部分发送，因此只需要初始化解码器一次。（最开始的实现是每次解码帧之前都重新初始化解码器，这样的话，这些关键信息可能会丢失，导致后续帧无法正确解码，表现的现象是卡在了第一帧画面）。\n以下是上述代码的逐行解释：\n初始化解码器 // 找到并确认解码器 AVCodec* codec = avcodec_find_decoder(AV_CODEC_ID_H264); if (!codec) { std::cerr \u0026lt;\u0026lt; \u0026#34;Codec not found.\\n\u0026#34;; return false; } avcodec_find_decoder: 这个函数用于查找指定编解码器（这里是H.264），返回一个指向解码器的指针。 if (!codec): 如果没有找到解码器，输出错误信息并返回失败。 // 分配编解码器上下文 AVCodecContext* context = avcodec_alloc_context3(codec); if (!context) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not allocate video codec context.\\n\u0026#34;; return false; } avcodec_alloc_context3: 分配一个新的解码器上下文，关联给定的编解码器。 if (!context): 如果上下文分配失败，输出错误信息并返回失败。 // 打开解码器 if (avcodec_open2(context, codec, NULL) \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not open codec.\\n\u0026#34;; return false; } avcodec_open2: 初始化解码器上下文以准备使用，传入的 codec 是上文查找得到的编解码器。 if (avcodec_open2(...) \u0026lt; 0): 如果解码器打开失败，输出错误信息并返回失败。 处理单帧数据 // 分配数据包 AVPacket* pkt = av_packet_alloc(); if (!pkt) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not allocate AVPacket.\\n\u0026#34;; return false; } av_packet_alloc: 分配一个新的数据包。数据包用于存储编码的数据（例如一个压缩的视频帧）。 if (!pkt): 如果数据包分配失败，输出错误信息并返回失败。 // 初始化数据包并设置数据 av_init_packet(pkt); pkt-\u0026gt;data = const_cast\u0026lt;uint8_t*\u0026gt;(data.data()); // Unsafe cast, data must be non-const pkt-\u0026gt;size = data.size(); av_init_packet: 初始化分配的数据包。 pkt-\u0026gt;data, pkt-\u0026gt;size: 设置数据包的数据指针和大小。data 是函数传入的H.264数据。 // 发送数据包到解码器 int ret = avcodec_send_packet(context, pkt); if (ret \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error sending a packet for decoding.\\n\u0026#34;; return false; } avcodec_send_packet: 将数据包发送到解码器，等待解码。 if (ret \u0026lt; 0): 如果发送失败，输出错误信息并返回失败。 接收解码后的帧并转换为cv::Mat // 分配帧存储解码后的数据 AVFrame* frame = av_frame_alloc(); ret = avcodec_receive_frame(context, frame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) { av_frame_free(\u0026amp;frame); break; } else if (ret \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error during decoding.\\n\u0026#34;; return false; } av_frame_alloc: 分配一个帧用于存储解码后的数据。 avcodec_receive_frame: 从解码器中获取一个解码后的帧。 if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF): 检查是否全部数据已处理完毕或需要更多数据。 // 转换解码后的帧为cv::Mat格式 SwsContext* img_convert_ctx = sws_getContext(frame-\u0026gt;width, frame-\u0026gt;height, static_cast\u0026lt;AVPixelFormat\u0026gt;(frame-\u0026gt;format), frame-\u0026gt;width, frame-\u0026gt;height, AV_PIX_FMT_BGR24, SWS_BICUBIC, NULL, NULL, NULL); int linesize[1] = {3 * frame-\u0026gt;width}; // RGB stride image = cv::Mat(frame-\u0026gt;height, frame-\u0026gt;width, CV_8UC3); sws_scale(img_convert_ctx, frame-\u0026gt;data, frame-\u0026gt;linesize, 0, frame-\u0026gt;height, \u0026amp;image.data, linesize); sws_freeContext(img_convert_ctx); sws_getContext: 创建一个上下文用于转换像素数据格式。 sws_scale: 转换像素数据格式从解码帧的格式到BGR24，这是OpenCV常用的格式。 cv::Mat: 创建一个OpenCV矩阵来存储图像数据。 这个流程需要在视频处理的生命周期中只初始化和清理一次编解码器，而帧处理可以多次调用，以提高性能和保持编解码器状态。这是一种高效处理视频帧的典型方法。\nL4Z 解压缩 L4Z解压缩的过程相对直接，直接根据函数来实现即可。\n代码实现 bool decompressLZ4Frame(const std::vector\u0026lt;uint8_t\u0026gt;\u0026amp; compressedData, cv::Mat\u0026amp; image, int width, int height) { std::vector\u0026lt;uint8_t\u0026gt; decompressedData(width * height * sizeof(uint16_t)); int decompressedSize = LZ4_decompress_safe(reinterpret_cast\u0026lt;const char*\u0026gt;(compressedData.data()), reinterpret_cast\u0026lt;char*\u0026gt;(decompressedData.data()), compressedData.size(), decompressedData.size()); if (decompressedSize \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to decompress LZ4 data.\u0026#34; \u0026lt;\u0026lt; std::endl; return false; } image = cv::Mat(height, width, CV_16UC1, decompressedData.data()); cv::Mat pseudoColorImage(height, width, CV_8UC3); for (int i = 0; i \u0026lt; height; i++) { for (int j = 0; j \u0026lt; width; j++) { uint16_t disparity = image.at\u0026lt;uint16_t\u0026gt;(i, j); if (disparity \u0026lt; 8192) { pseudoColorImage.at\u0026lt;cv::Vec3b\u0026gt;(i, j) = cv::Vec3b(pColorTable[disparity * 3 + 2], pColorTable[disparity * 3 + 1], pColorTable[disparity * 3]); } else { pseudoColorImage.at\u0026lt;cv::Vec3b\u0026gt;(i, j) = cv::Vec3b(0, 0, 0); } } } image = pseudoColorImage; return true; } 这里对解压缩的视差图进行颜色映射的处理，是根据视差值直接映射得到\n","permalink":"https://ahaknow.com/posts/know/decode-h.264-lz4-image-frames/","summary":"在上一篇打通了读取字节流文件后，能够得到每一帧的字节数据了，这一篇就来解决为这些数据赋予实际意义。 彩色图像采用H.264编码 -\u0026gt; 那就需要按照H","title":"开发实战：解析H.264编码和LZ4压缩的相机图像"},{"content":" 需要解析相机的字节流文件（就是一个一个Byte组成的文件，不解析的话没有啥实际意义）。\n解析需要按照一定的规则，比如：如何确定数据的头（Header），以及一个数据帧（一个数据包）的结构是什么样的，这个有点像网络包的定义，在头部定义了很多信息，这些信息能够让这个数据包按照规则解析出来后有具体的意义。\n下面按照尝试-失败-再尝试-成功之后的思考来进行整理。因为一开始采用直接“复制-粘贴（ChatGPT指导）”的方式，遇到了解析失败的情况，根据结果一点点分析，始终没发现问题在哪。\n因为问题出现在了一开始，也是比较基础的知识点，字节流在保存时分为大端存储和小端存储，由于这个知识点我压根就忘记了，所以迟迟没有发现，最后是不断往上追问，从ChatGPT的指导中发现了可能的原因，惭愧啊！\n大小端（Endianness）概念 大小端是指多字节数据（如整数、浮点数等）在内存中字节的排列顺序。这是计算机内存架构中的一个重要概念，影响了数据的存储和通信。大小端问题通常在处理跨平台数据传输和文件读写时显得尤为重要。\n大端（Big Endian）\n在大端字节序中，一个数的最高位字节（Big End）存储在内存的低地址处，其次是次高位，依此类推，最低位字节存储在高地址处。 例如，数 0x12345678 在内存中的存储方式（地址从低到高）为 12 34 56 78。 “大端易读”，左到右直接读出来就是原始保存的数据 小端（Little Endian）\n在小端字节序中，一个数的最低位字节（Little End）存储在内存的低地址处，随后是次低位，依此类推，最高位字节存储在高地址处。 例如，数 0x12345678 在内存中的存储方式（地址从低到高）为 78 56 34 12。 “小端反直觉”，因为现代汉语默认从左往右看，这里则需要反过来，两两看 大小端存在的原因主要与不同的处理器架构有关。不同的硬件制造商选择不同的存储方法，这通常取决于硬件设计的优化、历史原因和技术遗留问题。\n大端模式的优点在于从内存的起始地址开始即可读取高位，易于从地址解析其代表的数值大小，这在网络协议设计中尤为重要，因为许多网络协议规定为大端。\n小端模式则使得低位首先被处理，这在进行数学运算时常常更为高效，因为低位通常是先处理的部分。小端是多数现代个人计算机处理器，如x86架构，采用的存储方式。\n在不同字节序的系统间交换数据时，如果不进行字节序的转换，会导致数据解释错误。例如，一个系统以大端模式写入数据，另一个以小端模式读取，未经转换直接读取会得到错误的结果。\n大小端字节序举例 假设有一个4字节（Byte）的整数值 0x12345678，在内存中的存储会根据大小端不同而不同。\n大端（Big Endian）：高位字节（靠近Ox）存于低地址，所以内存布局是 12 34 56 78。 小端（Little Endian）：低位字节存于低地址，所以内存布局是 78 56 34 12。 在内存中，地址从低到高增加。低地址存储较“早”的数据，而高地址存储较“晚”的数据，所以可以近似看成从左往右。\n比如一个字节流的数据如下：\n10010001001011000001\n二进制形式：1001 0001 0010 1100 0001 4个一组，转换16进制：9 1 2 c 1 使用4个字节来表示时，高位补零：00 09 12 c1 小端字节序，低位字节存于低地址： 高位00 -\u0026gt; 高地址 次高位09 -\u0026gt; 次高地址 次低位12 -\u0026gt; 次低地址 低位c1 -\u0026gt; 低地址 实际在内存的中存储位 c1 12 09 00。 具体而言：\nPackage Data Length 594625 -\u0026gt; 内存布局c1 12 09 00 (对应00 09 12 c1) Unit Data: Length 43978 -\u0026gt; 内存布局ca ab 00 00 (实际为 00 00 ab ca) Type 3 -\u0026gt; 内存布局03 00 00 00 (实际为 00 00 00 03) 如果用大端方式读取C1 12 09 00，那么将得到 12653065，这个数字特别大，明显要大于文件大小了\n如果用大端方式读取ca ab 00 00，那么将得到 13282048，这个数字也特别大，并且还大于12653065，所以肯定出错了。\n$594625 \\div 1024 \\div 1024 = 0.57 MB$\n$12653065 \\div 1024 \\div 1024 = 12.07MB$\n$43978 \\div 1024 \\div 1024 = 0.042 MB$\n$13282048 \\div 1024 \\div 1024 = 12.67MB$\n补充说明：\n字节流文件“保存”的是二进制数据，也就是说文件中的数据以二进制形式存放，这意味着每个字节由8位二进制数字（0或1）组成。而使用文件浏览器或某些工具查看这些文件时，常常会看到十六进制的表示，因为十六进制能更有效地展示和定位文件内容，特别是对于非文本数据。\nC++打印时的进制 当在C++中使用 std::cout 打印数字时，除非指定格式（如使用 std::hex 来指定十六进制），否则默认为十进制（ std::dec ）。例如：\nuint32_t num = 0x1234; std::cout \u0026lt;\u0026lt; num; // 默认以十进制输出，打印为 \u0026#34;4660\u0026#34; std::cout \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; num; // 指定十六进制，打印为 \u0026#34;1234\u0026#34; 如果前面使用了std::hex，那么后面的std::cout也会受到影响，因此比较好的策略是用std::hex \u0026laquo; … \u0026laquo; std::dec包起来 C++代码实现 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;iomanip\u0026gt; // For std::setw and std::setfill struct UnitData { uint32_t len; uint32_t type; std::vector\u0026lt;uint8_t\u0026gt; content; UnitData(uint32_t len, uint32_t type, std::vector\u0026lt;uint8_t\u0026gt;\u0026amp; content) : len(len), type(type), content(content) {} }; // 大端 bool readUint32Big(std::ifstream\u0026amp; stream, uint32_t\u0026amp; value) { char buffer[4]; if (stream.read(buffer, 4)) { value = static_cast\u0026lt;uint32_t\u0026gt;((unsigned char)(buffer[3]) | (unsigned char)(buffer[2]) \u0026lt;\u0026lt; 8 | (unsigned char)(buffer[1]) \u0026lt;\u0026lt; 16 | (unsigned char)(buffer[0]) \u0026lt;\u0026lt; 24); return true; } return false; } // 小端 bool readUint32Little(std::ifstream\u0026amp; stream, uint32_t\u0026amp; value) { char buffer[4]; if (stream.read(buffer, 4)) { value = static_cast\u0026lt;uint32_t\u0026gt;((unsigned char)(buffer[0]) | (unsigned char)(buffer[1]) \u0026lt;\u0026lt; 8 | (unsigned char)(buffer[2]) \u0026lt;\u0026lt; 16 | (unsigned char)(buffer[3]) \u0026lt;\u0026lt; 24); return true; } return false; } int main(int argc, char* argv[]) { if (argc != 2) { std::cerr \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;filename\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } std::ifstream file(argv[1], std::ios::binary); if (!file.is_open()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to open file: \u0026#34; \u0026lt;\u0026lt; argv[1] \u0026lt;\u0026lt; std::endl; return 1; } int frameNumber = 0; // Frame counter while (!file.eof()) { // Read and check the header uint8_t header[2]; if (!file.read(reinterpret_cast\u0026lt;char*\u0026gt;(header), 2) || header[0] != 0xFF || header[1] != 0xAA) { if (file.eof()) { break; // Break the loop if EOF is reached during header read } std::cerr \u0026lt;\u0026lt; \u0026#34;Invalid header in frame \u0026#34; \u0026lt;\u0026lt; frameNumber + 1 \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } std::cout \u0026lt;\u0026lt; \u0026#34;Frame \u0026#34; \u0026lt;\u0026lt; ++frameNumber \u0026lt;\u0026lt; \u0026#34; - Header: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; (int)header[0] \u0026lt;\u0026lt; \u0026#34; 0x\u0026#34; \u0026lt;\u0026lt; (int)header[1] \u0026lt;\u0026lt; std::dec \u0026lt;\u0026lt; std::endl; // Read the package length uint32_t packageLength; if (!readUint32Little(file, packageLength)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to read package length.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } std::cout \u0026lt;\u0026lt; \u0026#34;Package Data Length: \u0026#34; \u0026lt;\u0026lt; packageLength \u0026lt;\u0026lt; std::endl; // Process Unit Data uint32_t bytesRead = 0; while (bytesRead \u0026lt; packageLength) { uint32_t unitLen, unitType; if (!readUint32Little(file, unitLen) || !readUint32Little(file, unitType)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to read unit data.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // Correct the content length by subtracting the length of unitType uint32_t contentLength = unitLen - 4; // Subtracting the 4 bytes of the unitType std::vector\u0026lt;uint8_t\u0026gt; content(contentLength); if (!file.read(reinterpret_cast\u0026lt;char*\u0026gt;(content.data()), contentLength)) { if (file.eof()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: EOF reached before reading all data. Expected \u0026#34; \u0026lt;\u0026lt; contentLength \u0026lt;\u0026lt; \u0026#34; bytes, but less were available.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: Failed to read unit content. Expected \u0026#34; \u0026lt;\u0026lt; contentLength \u0026lt;\u0026lt; \u0026#34; bytes.\u0026#34; \u0026lt;\u0026lt; std::endl; } return 1; } // Print the unit data len and type in hex std::cout \u0026lt;\u0026lt; \u0026#34;Unit Length: \u0026#34; \u0026lt;\u0026lt; unitLen \u0026lt;\u0026lt; \u0026#34;, Unit Type: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; std::setw(2) \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(unitType) \u0026lt;\u0026lt; std::dec \u0026lt;\u0026lt; std::endl; bytesRead += 4 + unitLen; } } file.close(); return 0; } ","permalink":"https://ahaknow.com/posts/know/parse-binary-file/","summary":"需要解析相机的字节流文件（就是一个一个Byte组成的文件，不解析的话没有啥实际意义）。 解析需要按照一定的规则，比如：如何确定数据的头（Hea","title":"开发实战：解析二进制文件"},{"content":" 使用Git，在develop分支下创建一个新分支，然后在这个新分支上进行新功能开发。\ngit branch系列操作 1. 列出所有本地分支 git branch 2. 列出所有远程分支 git branch -r 3. 列出所有本地和远程分支 git branch -a 4. 创建新分支 创建新分支但不切换到该分支：\ngit branch feature-x 这会创建一个名为feature-x的分支，但依然停留在当前分支。\n5. 删除分支 删除本地分支：\ngit branch -d feature-x 这个命令会安全地删除分支，只在这个分支已经被合并到当前分支时允许删除。如果分支还有未合并的更改，需要强制删除可以使用-D选项：\ngit branch -D feature-x 6. 重命名分支 如果你需要重命名当前分支：\ngit branch -m new-branch-name 如果要重命名其他分支（不在该分支上时）：\ngit branch -m old-branch-name new-branch-name 实际操作中的应用 通常会这样使用git branch来创建新分支：\ngit checkout develop # 确保你在develop分支 git pull origin develop # 拉取最新的develop分支 git branch feature-x # 创建新分支feature-x git checkout feature-x # 切换到新分支feature-x 这里的步骤可以简化为一个命令，使用git checkout -b同时创建并切换分支：\ngit checkout -b feature-x develop 这条命令直接基于develop分支创建并切换到feature-x分支。\n","permalink":"https://ahaknow.com/posts/know/git-branch-basic/","summary":"使用Git，在develop分支下创建一个新分支，然后在这个新分支上进行新功能开发。 git branch系列操作 1. 列出所有本地分支 git branch 2. 列出所有远","title":"Git：分支的基本操作"},{"content":" 问题描述：\nLinux同时连接局域网，网段是172.27.0.x，以及连接网口的相机设备，网段是192.168.80.x。\nLinux启动后出现这种情况：\n可以连接相机，但无法上网 将相机的网线拔掉后，就能够上网了 简单的分析一下，应该是网络占用的问题。\n先把问题解决了 下面具体来分析\n通过route -n来查看路由表信息：\n❯ route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.80.1 0.0.0.0 UG 0 0 0 eno1 0.0.0.0 172.27.0.1 0.0.0.0 UG 101 0 0 eno1 169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 enx0826ae3c0c7b 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 172.27.0.0 0.0.0.0 255.255.255.0 U 101 0 0 eno1 192.168.80.0 0.0.0.0 255.255.255.0 U 100 0 0 enx0826ae3c0c7b 可以看出来有两个设备，一个是eno1，局域网网线，另一个是enx0826ae3c0c7b，网口的相机。\n为啥会上不了网捏？\n观察这个路由表的可以发现有一个重复的混乱项：\nDestination 为 0.0.0.0 但是 Gateway 却有两个，就是这里导致的，这时候的解决方法就是，先清除默认路由，然后再配置一个正确的默认路由。\n步骤1：清除错误的默认路由\n首先，删除所有默认路由：\nsudo ip route del default 步骤2：添加正确的默认路由\n将默认路由设置为通过网关`172.27.0.1，并指定合适的度量值：\nsudo ip route add default via 172.27.0.1 dev eno1 metric 0 步骤3：验证路由表\n再次检查路由表，确保只有一个默认路由，并且其他路由按预期配置：\nroute -n 这个时候得到的应该就是正确的路由表了：\n❯ route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 172.27.0.1 0.0.0.0 UG 0 0 0 eno1 0.0.0.0 172.27.0.1 0.0.0.0 UG 101 0 0 eno1 169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 enx0826ae3c0c7b 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 172.27.0.0 0.0.0.0 255.255.255.0 U 101 0 0 eno1 192.168.80.0 0.0.0.0 255.255.255.0 U 100 0 0 enx0826ae3c0c7b 另一种思路 在路由表中，metric值用于定义路由的优先级。当存在多条到达同一个目的地的路由时，metric值较小的路由将被优先选择用于数据传输。因此，metric是一种决定路径选择的方法，尤其在多个网络接口可用时这一点非常重要。\nMetric 的含义和作用 含义：metric值是一个数字，用于表示路由的优先级。数字越小，该路由的优先级越高。 作用： 选择最优路径：在多条路由可达同一目的地的情况下，路由器根据metric值选择metric最小的路由作为最佳路径。 负载均衡：在某些配置中，可以故意设置相同的metric值给不同的路由，以实现负载均衡。 避免路由循环：适当的metric值配置可以帮助避免路由循环，特别是在复杂的网络拓扑中。 Metric 值的选择 比如，metric值为0, 101, 100, 1000等，这些都是用来区分不同路由条目的相对优先级。例如：\nMetric 为 0：通常表示该路由具有最高的优先级，系统将优先通过这个路由发送数据。 Metric 为 101 或 100：这些值较高，表示路由的优先级较低。如果默认路由（metric 为 0 的路由）不可用，系统可能会考虑使用这些路由。 Metric 为 1000：更高的metric值，通常用于备份路由，只有在其他较低metric值的路由全都不可用时，才会被使用。 因此上述的问题还可以通过更改路由的优先级来解决\n现在问题解决了，但是解决了一时，解决不了一世，如果Linux主机重新启动，那么又会恢复为原来的设置，怎么办呢？\n那就设置一个自动化的启动项！\n自动化的“一劳永逸” 创建一个自定义的systemd服务，可以通过调整systemd服务来确保在执行路由删除和添加操作之前，网络接口已经正确初始化。此外，还可以加入条件判断，只在默认路由存在时尝试删除它。\n修改 Systemd 服务文件： 编辑之前创建的systemd服务文件，添加条件判断和依赖关系，确保在执行路由操作前网络接口已准备好。\nsudo vim /etc/systemd/system/setdefaultgateway.service 修改服务文件，加入网络在线的条件和执行命令前的检查：\n[Unit] Description=Set default gateway Wants=network-online.target After=network-online.target [Service] Type=oneshot ExecStartPre=/bin/sh -c \u0026#39;ip route | grep -q default \u0026amp;\u0026amp; ip route del default\u0026#39; ExecStart=/sbin/ip route add default via 172.27.0.1 dev eno1 metric 0 RemainAfterExit=yes [Install] WantedBy=multi-user.target 这里ExecStartPre行用于检查是否存在默认路由，并且只有在存在的情况下才尝试删除它。这样可以避免因为尝试删除一个不存在的路由而导致服务失败。\n重新加载和启动服务： 加载新的配置并重新启动服务：\nsudo systemctl daemon-reload sudo systemctl restart setdefaultgateway 检查服务状态： 确保服务现在能够成功执行，不再报错：\nsudo systemctl status setdefaultgateway 通过确保在网络接口准备好后执行命令，并且只在默认路由存在时尝试删除它，能够避免服务启动时遇到的“RTNETLINK answers: No such process”错误。\n服务文件的部分解释 [Unit]部分： Description: 仅为此服务提供描述，说明其用途。 Wants: 这一行指定了此服务想要的其他单位（unit）。network-online.target是一个特殊的目标，代表网络配置已完全完成且互联网连接已建立。 After: 这一行确保了在network-online.target之后才启动这个服务。也就是说，只有在网络确实可用之后，此服务才会运行其命令。 这两个设置（Wants和After）确保了网络服务在尝试修改路由表之前已经完全启动和激活。这是非常重要的，因为如果在网络接口还没有激活的情况下尝试设置路由，可能会导致命令失败。\n[Service]部分： Type=oneshot: 这意味着这个服务在启动时运行一次然后结束，不会持续运行。 ExecStartPre: 这是在主命令（ExecStart）执行之前运行的命令。它的作用是检查当前路由表中是否存在默认路由： /bin/sh -c 'ip route | grep -q default \u0026amp;\u0026amp; ip route del default'：这条命令会首先查找是否存在默认路由，如果存在（grep -q default 返回0），则执行删除默认路由的命令（ip route del default）。这里使用grep -q是为了静默模式，只返回存在与否的状态码而不输出文本。 ExecStart: 这是服务的主命令，用于添加新的默认路由。如果前面的默认路由已被删除，这条命令会无障碍地设置新的默认路由。 RemainAfterExit=yes: 通常用于Type=oneshot的服务，指示即使服务的主进程已经结束，此服务的状态依旧被视为激活。 这种配置方式，特别是ExecStartPre命令的使用，是为了确保修改默认路由时不会因为旧的路由设置存在而出现冲突或错误。通过这样的安排，服务在执行任何操作之前确保了网络接口的可用性和清理了可能存在的冲突配置，从而使得默认网关的设置更加可靠和稳定。\n","permalink":"https://ahaknow.com/posts/know/linux-repair-routing-table/","summary":"问题描述： Linux同时连接局域网，网段是172.27.0.x，以及连接网口的相机设备，网段是192.168.80.x。 Linux启动后出现","title":"Linux：上不了网了之路由表修复"},{"content":"Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2:\nInput: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 105 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 0 \u0026lt;= k \u0026lt;= 105 Follow up:\nTry to come up with as many solutions as you can. There are at least three different ways to solve this problem. Could you do it in-place with O(1) extra space? 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n示例 1:\n输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2:\n输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 0 \u0026lt;= k \u0026lt;= 105 进阶：\n尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 轮转数组，比较直接的方法就是重新开辟了一个新数组，然后复制过去，这种方法能够解决问题，但是不够巧妙。\n再进一步想，可以环状替换，这种方法就比较有意思，需要一个额外的中间变量，然后实现一种环状的，前后衔接的，依次交替的更换（这种方法稍微有点复杂，动手笔画理解得可能更好）。\n另外一种就比较奇特，**通过多次整体翻转的策略，**这个算法将在下文中仔细说明。\n🌽上菜 方法一：使用额外数组 可以创建一个新的数组来重新排列元素。\n遍历原数组，将每个元素放置到 (i + k) % n 的位置上。 将新数组复制回原数组。 这种方法的空间复杂度是 O(n)。\n方法二：环状替换 这种方法可以不使用额外的空间，直接在原数组上操作：\n从某个位置开始，将其元素放到正确的位置上，同时把目标位置的原元素保存下来。 继续操作新位置的元素，直到回到起始位置。 如果数组有多于一个的独立循环（例如，数组长度和 k 的最大公约数大于1），需要从数组中不同的位置开始，直到每个元素都被移动过。 这种方法的空间复杂度是 O(1)，因为它是原地操作。\n用实际的例子来理解“环状替换”：\n环状替换举例 1 2 3 4 需要移动 2 位，变成 3 4 1 2\n从下标0开始，start = 0，prev = nums[0] = 1；（起点）\n需要替换的在0 + 2的位置，next = 2，temp = nums[2] = 3；\n发生替换（使用prev）：1 2 1 4；更新：prev = temp = 3；current = next = 2；\n循环继续；\ncurrent = 2；需要替换的在0 + 2的位置（与nums.size()取模），current = 0；temp = nums[0] = 1；（终点，这里就又回到了起点，形成了闭环）\n发生替换（使用prev）：3 2 1 4；\n此时current == start，说明这一轮遍历结束，start 需要更新；\n循环中止，start + 1；\n从下标1开始，start = 1，prev = nums[1] = 2；（起点）\n需要替换的在1 + 2的位置，next = 3，temp = nums[3] = 4；\n发生替换（使用prev）：3 2 1 2；更新：prev = temp = 4；current = next = 3；\n循环继续；\ncurrent = 3；需要替换的在3 + 2的位置（与nums.size()取模），current = 1；temp = nums[1] = 2；（终点，又回到了起点，形成了闭环）\n发生替换（使用prev）：3 4 1 2；\n此时current == start，说明这一轮遍历结束，start 需要更新；\n循环中止，start + 1；\n此时已经完成排序了，可以退出程序了。\n具体的循环退出依据可以通过数组长度和轮转次数的最大公约数得到。\n环状替换中的GCD（最大公约数） 当将数组中的每个元素向右移动 k 个位置时，可以通过 $i \\rightarrow (i + k) % n$ 的映射关系来理解每个元素的新位置，其中 i 是原始索引，n 是数组的长度。\n但是使用这种映射，得需要知道这种循环结构何时会回到起点，也就是形成一个闭合的循环。\n循环长度和返回起点：\n当从某个索引 start 开始，不断应用 $i \\rightarrow (i + k) % n$ 映射，我们想要知道什么时候会回到 start 索引。这就意味着寻找最小的正整数 m，使得 $(start + m \\cdot k) % n = start$。简化后得到 $(m \\cdot k) % n = 0$，即 $m \\cdot k$ 应该是 n 的倍数。 最小的 m 值：\n要找到最小的 m，使得 $m \\cdot k$ 是 n 的倍数，等价于找到最小的 m 使得 $\\frac{m \\cdot k}{n}$ 是一个整数。这意味着 m 是一个特定的值，使得 $m \\cdot k$ 能够整除 n。这就需要 k 中的任何可能因子已经在 n 中有对应的因子以保证整除。 GCD（最大公约数）是 k 和 n 的共同最大因子。当我们通过 GCD 来除 n 和 k，实际上是在移除两者共有的所有因子，所得的比例（k/GCD 和 n/GCD）是最简形式，没有更多的公共因子。 使用 GCD，我们可以重新定义 k 和 n： $k\u0026rsquo; = \\frac{k}{\\text{gcd}(k, n)}$ $n\u0026rsquo; = \\frac{n}{\\text{gcd}(k, n)}$ 现在 $k\u0026rsquo;$ 和 $n\u0026rsquo;$ 互质（即没有共同因子），因此最小的 m 使得 $(m \\cdot k\u0026rsquo;) % n\u0026rsquo; = 0$ 就是 n'，即 $n / \\text{gcd}(k, n)$。 因此，$m = \\frac{n}{\\text{gcd}(k, n)}$ 是使得 $(i + m \\cdot k) % n = i$ 成立的最小 m 值，这里的 gcd 表示 k 和 n 的最大公约数。 循环的数量：\n如果从数组中的每个 start 点开始都运行一个循环，通过 k 和 n 的最大公约数可以知道，从一个给定的起点开始，会在经过 $n / \\text{gcd}(k, n)$ 步后回到起点。 因此，要遍历所有可能的起点（确保每个元素都被移动到正确的位置），需要从 gcd(k, n) 个不同的起点开始，每个起点所经历的循环都是这个全覆盖循环的独立的一部分。 假设 n = 12 和 k = 8：\n$\\text{gcd}(12, 8) = 4$。 从 0 开始的循环会经过索引 $0 \\rightarrow 8 \\rightarrow 4 \\rightarrow 0$，形成一个长度为3的循环。 因为 gcd 是 4，可以从 0, 1, 2, 3 这四个起点开始（这里也可以观察出：起点4是没必要，因为已经出现在起点为0的循环中了），每个起点都会形成一个独立的循环，这些循环共同覆盖整个数组。 计算 GCD 的方法 GCD 可以使用辗转相除法（Euclidean algorithm）来计算，这是一种高效的算法。\n辗转相除法，也被称为欧几里得算法（Euclidean algorithm），是一种用于计算两个整数的最大公约数（GCD，Greatest Common Divisor）的古老算法。这个算法基于一个简单的原理：两个数的最大公约数不变，如果较大数减去较小数。更具体地说，给定两个正整数 $a$ 和 $b$，其中 $a \u0026gt; b$，那么 $gcd(a, b)$ 等于 $gcd(b, a - b)$。但为了效率，通常使用除法代替减法。\n以下是计算 GCD 的简单函数实现：\nint gcd(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a; } 基本步骤：\n将较大数除以较小数。 将除法的余数替换到较小数的位置。 重复这个过程，直到其中一个数变成零。 当余数为零时，另一个数就是最大公约数。 形式上，算法可以描述为：\n输入：两个正整数 $a$ 和 $b$。 输出：$a$ 和 $b$ 的最大公约数 $gcd(a, b)$。 比如计算 $252$ 和 $105$ 的最大公约数：\n$gcd(252, 105)$ $252 \\mod 105 = 42$，现在计算 $gcd(105, 42)$ $105 \\mod 42 = 21$，现在计算 $gcd(42, 21)$ $42 \\mod 21 = 0$，结束。所以，最大公约数是 $21$。 ‼️有一点重要的点，算法本身具有自校正的特性，即使 $b$ 大于 $a$，它仍然可以正确工作。\n这是因为在算法的每一步中，都是取两个数的余数来进行下一次迭代，这个过程会自动调整两个数的顺序。\n如果在算法开始时 $b \u0026gt; a$，那么在第一次迭代中，余数将是 $a$（因为 $a \\mod b = a$ 当 $a \u0026lt; b$），然后 $a$ 和 $b$ 的角色在下一次迭代中就会交换。这就自然地保证了接下来的迭代中较大的数总是被较小的数除，算法的逻辑不会受到初始条件的影响。\n举例：\n假设 $a = 18$ 和 $b = 24$，需要找到它们的最大公约数。\n迭代 1:\n$b = 24, a = 18$ $a \\mod b = 18 \\mod 24 = 18$（因为 18 小于 24） 接下来，$b$ 变为 18，$a$ 变为 24。 迭代 2:\n$b = 18, a = 24$ $a \\mod b = 24 \\mod 18 = 6$（现在按正常的逻辑进行） $b$ 变为 6，$a$ 变为 18。 迭代 3:\n$b = 6, a = 18$ $a \\mod b = 18 \\mod 6 = 0$（余数为 0，结束） $gcd$ 是 6。 不论 $a$ 和 $b$ 的初始大小关系如何，欧几里得算法总能正确地调整并找到最大公约数。这也是为什么这种算法非常强大和灵活的原因之一。\n欧几里得算法还可以扩展到更一般的情况，如求解线性方程、多项式的最大公约数，以及非欧几里得域（如高斯整数）的公约数计算等。还有一些变种和改进方法，包括：\n扩展欧几里得算法：\n不仅计算最大公约数，还找到整数解 $x$ 和 $y$，使得 $ax + by = gcd(a, b)$。这在某些数论和密码学应用中非常重要。 二进制GCD算法：\n也称为Stein算法，这种方法不使用除法，而是基于更简单的位运算来计算最大公约数，效率在某些硬件上更优。 多项式GCD：\n使用类似欧几里得算法的方法来找到两个多项式的最大公共因子。 使用这个 gcd 函数，我们可以计算出 n 和 k 的 GCD，从而确定需要进行的环状替换的起始位置数。\n方法三：反转数组 使用数组反转可以巧妙地实现旋转，而不需要额外的空间：\n反转整个数组：这一步把数组的头部移到尾部，尾部移到头部。 反转前 k % n 个元素：由于整个数组已经被反转，最初的最后 k % n 个元素现在位于数组的前部。再次反转这部分可以恢复它们的原始顺序。 反转剩余的 n - k % n 个元素：这样可以恢复这部分元素的原始顺序。 这同样是一个空间复杂度为 O(1) 的原地算法。\n举例说明 假设数组为 [1,2,3,4,5,6,7]，需要向右移动 k = 3 步。\n初始数组：[1,2,3,4,5,6,7] 反转整个数组：[7,6,5,4,3,2,1] 反转前 k % n = 3 个元素：[5,6,7,4,3,2,1] 反转剩余 n - k = 4 个元素：[5,6,7,1,2,3,4] 不够轮转的k 是多少，整个操作只涉及三次数组遍历，因此时间复杂度为 $O(n)$，而且不需要额外的存储空间，空间复杂度为 $O(1)$。\n核心思想 这里需要细品的是：\n同样反转两次，可以复原操作 所以先整体反转，再局部反转 代码实现 // 189. Rotate Array #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 方法一 使用额外的数组 class Solution { public: void rotate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); // 错误写法，自己反思一下吧 // k = n % k; // 处理给的k大于n的情况 k = k % n; vector\u0026lt;int\u0026gt; nums_new(n); for (int i = 0; i \u0026lt; n; i++) { // 注意这种错误写法 // nums_new[i] = nums[i + k]; // 肯定要从nums[0]开始，不然会越界的 nums_new[(i + k) % n] = nums[i]; } nums = nums_new; } }; // 方法二 环状替换（循环替换） class Solution { public: // 需要计算最大公约数 int gcd(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a; } void rotate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); k = k % n; int end = gcd(n, k); for (int start = 0; start \u0026lt; end; start++) { int current = start; int prev = nums[start]; do { // 注意这里写错了 // int next = (start + k) % n; // 因为已经知道current，start标记的是大循环 int next = (current + k) % n; int temp = nums[next]; nums[next] = prev; prev = temp; // 还需要更新current current = next; } while (current != start); } } }; // 方法三 反转数组 // 直接使用vector的reverse方法 class Solution { public: void rotate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); k = k % n; reverse(nums.begin(), nums.end()); // 反转两次，顺序就会复原 // 左闭右开区间 reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); } }; ","permalink":"https://ahaknow.com/posts/know/leetcode-189-rotate-array/","summary":"Given an integer array nums, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3]","title":"Leetcode：189. 轮转数组"},{"content":"Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\nExample 1:\nInput: nums = [3,2,3] Output: 3 Example 2:\nInput: nums = [2,2,1,1,1,2,2] Output: 2 Constraints:\nn == nums.length 1 \u0026lt;= n \u0026lt;= 5 * 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 Follow-up: Could you solve the problem in linear time and in O(1) space?\n给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例 1：\n输入：nums = [3,2,3] 输出：3 示例 2：\n输入：nums = [2,2,1,1,1,2,2] 输出：2 提示：\nn == nums.length 1 \u0026lt;= n \u0026lt;= 5 * 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 进阶： 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。\n第一反应是分别计数，这种方法显然有点笨。。。\n因为题目想找出现次数最多的数字（这种题目要求大于一半数量，说明肯定有大于一半数量存在的），其实可以这样，不用分别计数，而是按照顺序依次“增减”计数，比如：\n1 1 2 2 1 1\n最开始遇到1，遇到1就计数+1，遇到不是1就计数-1，如果这个数字大于一半数量，那么增增减减之后，一定也还是大于零\n🥬上菜 在这个问题中，需要找到一个出现次数超过 ⌊n/2⌋ 次的多数元素。对于这种问题，有一种非常高效的解决方法，称为 Boyer-Moore 投票算法。这种算法可以在 O(n) 时间复杂度内找到多数元素，并且其空间复杂度为 O(1)。\nBoyer-Moore 投票算法 其核心思想是通过一种巧妙的方式取消掉非多数元素的计数，来找到多数元素。具体步骤如下：\n初始化：设置两个变量，candidate（候选人）初始化为任意值，count（计数）初始化为 0。 第一遍遍历：遍历数组 nums。 如果 count 为 0，设当前元素为 candidate。 如果当前元素等于 candidate，增加 count。 否则减少 count。 第二遍遍历：验证 candidate 是否为多数元素（这一步在题目中可以省略，因为题目保证了总是存在多数元素）。 计算 candidate 的出现次数。 如果出现次数大于 ⌊n/2⌋，返回 candidate。 直觉的理解：\n每次在找到两个不同的元素时就将它们“抵消”。如果一个元素的数量超过总数的一半，那么即使它与其他所有不同的元素进行抵消，最后仍然会剩余该元素，因为它的数量多于其他所有元素的总和。\n但是要注意这个算法成立的关键前提：数组中存在一个多数元素，其出现次数严格大于数组长度的一半。\n实现代码（C++） // 169. Majority Element #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int candidate; int count = 0; for (int num : nums) { // 说明增增减减之后又回到零 if (count == 0) { candidate = num; } count += (candidate == num) ? 1 : -1; } // 由于题目限制，下面的判断可以省略（但其实很必要） // count = 0; // for (int num : nums) { // if (num == candidate) { // count++; // } // } // if (count \u0026gt; nums.size() / 2) return candidate; return candidate; } }; ","permalink":"https://ahaknow.com/posts/know/leetcode-169-majority-element/","summary":"Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array. Example 1: Input: nums = [3,2,3] Output: 3 Example 2: Input: nums = [2,2,1,1,1,2,2] Output: 2 Constraints: n == nums.length 1 \u0026lt;= n \u0026lt;= 5 * 104 -109 \u0026lt;= nums[i] \u0026lt;=","title":"Leetcode：169. 多数元素"},{"content":"Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,_,_] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums is sorted in non-decreasing order. 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n说明：\n为什么返回数值是整数，但输出的答案是数组呢？\n请注意，输入数组是以 「引用」 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例 1：\n输入：nums = [1,1,1,2,2,3] 输出：5, nums = [1,1,2,2,3] 解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。 示例 2：\n输入：nums = [0,0,1,1,1,1,2,3,3] 输出：7, nums = [0,0,1,1,2,3,3] 解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按升序排列 这和上一题的区别就是重复的元素只出现两次\n其实解题的本质和上一题是一样的，还是使用双指针，但是实现逻辑上稍有不同，需要注意‼️\n不管是只出现两次还是n次，\n因为是升序排列，只能出现一次是比较一次，那么只能出现两次那就判断两次\n但比较一次可以简化为比较不同，比较两次则要保证不受到原地替换的影响，在逻辑上有巧妙之处。\n🌽上菜 这个问题是前一个问题的一个变体，不同之处在于需要保留每个元素最多两次，而不是一次。因此，仍然可以采用双指针的方法来解决这个问题，只是需要对比较逻辑做一些调整，以确保每个元素最多出现两次。\n解题思路：\n使用两个指针 slow 和 fast。其中 slow 指针用来指示处理后的数组的末尾位置，而 fast 指针用来遍历整个数组。 需要确保 slow 指向的新数组中，每个元素最多出现两次。这可以通过比较 nums[fast] 与 nums[slow-2]（而不是 nums[slow-1]）来实现，因为这次是允许每个元素出现两次。 当 fast 指针指向的元素与 slow-2 指针指向的元素不同，或者 slow 小于2（意味着还没有填充两个元素）时，将 nums[fast] 的值复制到 nums[slow]，然后递增 slow。 需要特别注意： if (nums[fast] != nums[slow - 2])，与之前的写法不同！\n具体代码实现（C++）如下：\n#include \u0026lt;vector\u0026gt; using namespace std; int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() \u0026lt;= 2) return nums.size(); int slow = 2; // 因为允许元素最多出现两次，所以从索引2开始检查 for (int fast = 2; fast \u0026lt; nums.size(); ++fast) { if (nums[fast] != nums[slow - 2]) { nums[slow++] = nums[fast]; } } return slow; } 这段代码有效地在原地修改了数组，同时只使用了 O(1) 的额外空间。时间复杂度为 O(n)，因为只需要需要遍历一次数组。空间复杂度为 O(1)，因为没有使用额外的存储空间，只是在原数组上进行了操作。\n💣特别注意 在处理有序数组中删除重复元素，并保留最多两个重复元素的情景中，使用 if (nums[fast] != nums[slow - 2]) 和使用 if (nums[fast - 2] != nums[fast]) 进行判断有本质的不同，主要因为这两种判断方式所依赖的逻辑和数组的修改方式不同。\nif (nums[fast] != nums[slow - 2]) 这种判断方式是在原地修改数组，通过保持一个 slow 指针来跟踪应该写入的位置。这个条件检查的是当前正在遍历的元素（由 fast 指针指示）是否与 slow - 2 位置的元素不同。这样可以确保每个元素最多出现两次。当数组中前两个元素已经存在时，这种方法可以保证不会超过两个相同的元素被连续保留。\n优点：\n它允许在已经有两个元素的情况下继续放置新元素，只要新元素与 slow - 2 的元素不同。 if (nums[fast - 2] != nums[fast]) 这种方法的关键在于比较当前元素与它前面第二个元素是否不同。这种方法适用于检查整个数组并判断哪些元素应该被保留，不适合在使用 slow 和 fast 指针原地修改数组的情境。在初始数组中，如果用这种判断方法，那么从第三个元素开始，每个元素都要与它前面的第二个元素比较，如果相同，则说明它是第三次或更多次重复出现。\n问题：\n这种方法假设每个元素的前两个元素已经确定并且正确地处理过，这在初始化阶段并不总是成立。 在使用双指针进行原地操作时，这种判断不能正确地更新 slow 指针的位置，因为它基于遍历过程中之前的元素的状态，而在 slow 和 fast 指针操作中，我们需要基于动态更新的数组状态进行判断。 if (nums[fast] != nums[slow - 2]) 是针对双指针原地修改数组设计的，能有效处理只保留最多两个重复元素的要求，而 if (nums[fast - 2] != nums[fast]) 更多的是一种检查方式，用于理解和分析，但不适合直接用于双指针原地修改数组的具体实现。\n举例说明 如果是if (nums[fast - 2] != nums[fast]):\n1 1 1 2 2 3 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针相同，快指针继续循环，慢指针位置不变 1 1 1 2 2 3 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 2 3 ⬆慢 1 1 2 2 2 3 注意由于慢指针的替换，导致此时原始数组发生变化 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针相同，快指针继续循环，慢指针位置不变 1 1 2 2 2 3 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 3 2 3 ⬆慢 结果错误❌ 如果是if (nums[fast] != nums[slow - 2])：\n1 1 1 2 2 3 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针相同，快指针继续循环，慢指针位置不变 1 1 1 2 2 3 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 2 3 ⬆慢 1 1 2 2 2 3 注意由于慢指针的替换，导致此时原始数组发生变化 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 2 3 ⬆慢 1 1 2 2 2 3 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 3 3 ⬆慢 快指针到头，循环结束 结果正确✅ 🌟与上一题的区别 对于上一题，即移除所有重复的元素使每个元素只出现一次的情况，使用 if (nums[fast] != nums[fast - 1]) 对结果没有影响，分析如下：\n原地操作 在数组操作中，“原地”意味着不需要额外的空间来存储输出，仅允许使用常数级别的额外空间。在使用 if (nums[fast] != nums[fast - 1]) 的双指针策略中，直接在输入数组 nums 上进行修改，不需要额外的存储空间（除了几个指针变量）。这是一种原地操作，因为它直接在原数组上进行元素的重写和覆盖，没有使用新的数组结构来存储结果。\n使用 if (nums[fast] != nums[fast - 1])也可以的原因 这个条件是用来检查当前快指针 fast 指向的元素是否与它前一个元素相同。这里的关键是理解我们的目标是保证数组中每个元素只出现一次。由于数组是有序的，所有的重复元素都会连续出现。因此，只需要检查当前元素是否与前一个元素不同：\n如果 不同，则表示当前元素是一个新的元素，应该被保留。这时你就将当前 fast 指向的元素复制到 slow 指针的位置，然后递增 slow。 如果 相同，则快指针 fast 继续向前移动，直到找到一个不同的元素。 如果是 if (nums[fast] != nums[slow - 1]) 效果也一样。\n在只允许每个元素出现一次的问题中，关注的是确保不复制相同的元素到 slow 指向的位置。而在允许每个元素出现两次的问题中，关注点则是允许至多两个重复元素。\nslow - 2的关键在于：保证slow-2到slow之间是相同的元素，并且用fast指针进行比较时，是有一个比较参考，而不是自己和自己比（有点需要意会的意思，慢慢品）\n","permalink":"https://ahaknow.com/posts/know/leetcode-80-remove-duplicates-from-sorted-array-ii/","summary":"Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements","title":"Leetcode：80. 删除有序数组中的重复项 II"},{"content":" 我发现我的思维特别容易发散，就是干这一件事，脑海中突然有了其他灵感，此前的做法是“直接插队的优先队列”，就是放下手中活，把突然想到去办了，其实这种方法有时候并不好，容易“本末倒置”，原本的事到最后没做好。\n所以，再次把一写博客的灵感记录下来，然后一件一件事情按部就班完成了再来处理这里。\n在此之前已经实现了很多想法，比如一些美化操作（哼，徒有外表，华而不实！！），就不记录了；之后新产生的，在此记录。\n文章元数据显示等美化 字体替换与加速 时间线按照最近更新时间排序 Hugo里面时间计算的原理需要优化（公式优化） Hugo的模版页面自定义 使用jsDelivr配合Github实现文件读取加速 文章缩略截断的字数修改 添加访问次数 ","permalink":"https://ahaknow.com/posts/know/blog-todo/","summary":"我发现我的思维特别容易发散，就是干这一件事，脑海中突然有了其他灵感，此前的做法是“直接插队的优先队列”，就是放下手中活，把突然想到去办了，其","title":"Blog：奇思妙想待办项"},{"content":" 记录一些实用Hugo写博客的小技巧。\n—— 因为如果当时不记录，那么日后肯定不会再记录的！（懒！）\n使用Archetype预设模版 在使用 hugo new 命令创建新内容时，你可以指定使用特定的 archetype。Archetype 是 Hugo 中的模板文件，用于预设新内容文件的元数据和结构。默认情况下，Hugo 会使用名为 default.md 的 archetype，但可以创建和指定其他 archetype 来满足不同类型内容的需求。\n创建自定义 Archetype 在 Hugo 站点的根目录中，archetypes 目录用于存放 archetype 文件。\n可以在这个目录下创建新的 archetype 文件。例如，创建一个名为 blog.md 的文件，用于博客帖子：\narchetypes/blog.md 编辑 blog.md 文件，定义你想要预置的内容和 Front Matter，例如：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] --- 在这里写博客内容... 使用自定义 Archetype 创建内容 当创建新内容时，可以通过指定 archetype 的名称来使用它。格式如下：\nhugo new \u0026lt;路径\u0026gt;/\u0026lt;文件名\u0026gt;.\u0026lt;扩展名\u0026gt; --kind \u0026lt;archetype名称\u0026gt; 或者，如果创建的内容直接位于 archetypes 下的同名目录中，你只需指定路径，Hugo 会自动寻找匹配的 archetype。例如，如果有一个名为 blog.md 的 archetype，就可以这样创建新的博客帖子：\nhugo new blog/我的新博客帖子.md 这里，Hugo 会在 archetypes 目录下寻找名为 blog.md 的文件，并使用它作为新内容文件的模板。\n如果想显式地使用特定的 archetype 而不依赖于目录结构，可以使用 --kind 参数，像这样：\nhugo new posts/我的新博客帖子.md --kind blog 这命令会创建一个新的内容文件 posts/我的新博客帖子.md，并使用 archetypes/blog.md 作为模板。\n在文章内链接导航其他文章 在Hugo中创建文章间的超链接，最佳实践是使用相对URL或者Hugo的内置函数来生成URL。这样做的好处是可以保持链接的持久性，即使你的站点URL发生变化，链接也不会断裂。以下是几种在Hugo中链接到另一个本地文章的方法：\n1. 使用相对URL 如果知道目标文章的路径，可以直接在Markdown文件中使用相对URL创建链接。例如，如果想从位于 /content/posts/my-first-post.md 的文章链接到 /content/posts/my-second-post.md，可以这样写：\n请查看我的[第二篇文章](../my-second-post/) 这里使用的是相对于当前文件的路径。注意，链接的路径部分应该与目标Markdown文件的位置相对应，且通常情况下，不包括文件扩展名.md。\n2. 使用Hugo的ref和relref短代码 Hugo提供了ref和relref短代码，这两个短代码可以生成到站点内任何页面的永久链接。这是一种更健壮的链接方法，因为它不依赖于站点的部署路径。这两个短代码的区别在于ref可以用于任何站点（得到绝对路径）页面，而relref仅用于相同语言（得到相对路径）的页面。\n假设想链接到位于/content/posts/know/blog-tips.md的文章，可以在任何Markdown文件中这样写：\n请查看我的[第二篇文章](两个{\u0026lt; relref \u0026#34;/posts/know/blog-mac-style-code.md\u0026#34; \u0026gt;两个}) 实际效果就是这样的：\n请查看我的[第二篇文章](/posts/know/blog-mac-style-code/) 或者\n请查看我的[第二篇文章](两个{\u0026lt; ref \u0026#34;/posts/know/blog-mac-style-code.md\u0026#34; \u0026gt;两个}) 实际效果如下：\n请查看我的[第二篇文章](https://ahaknow.com/posts/know/blog-mac-style-code/) 使用ref或relref短代码时，需要指定目标文件的路径从content目录的下一个目录开始（也就是hugo new时使用的路径文件名）。\n当使用ref和relref短代码时，确保路径是从content文件夹开始的相对路径，并且包括文件的扩展名.md。 如果站点支持多语言，relref是链接到当前语言下的相对内容，而ref可用于链接到任何语言的内容（因为hugo的不同语言通过url区分）。 使用ref和relref的另一个好处是，如果目标链接不存在，Hugo在构建站点时会报错，这有助于你及时发现并修正死链（所以上述使用的是真实存在的文件路径）。 ","permalink":"https://ahaknow.com/posts/know/blog-tips/","summary":"记录一些实用Hugo写博客的小技巧。 —— 因为如果当时不记录，那么日后肯定不会再记录的！（懒！） 使用Archetype预设模版 在使用 hugo new 命令创","title":"Blog：Hugo写作小技巧 "},{"content":"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -100 \u0026lt;= nums[i] \u0026lt;= 100 nums is sorted in non-decreasing order. 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 判题标准:\n系统会用下面的代码来测试你的题解:\nint[] nums = [...]; // 输入数组 int[] expectedNums = [...]; // 长度正确的期望答案 int k = removeDuplicates(nums); // 调用 assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } 如果所有断言都通过，那么您的题解将被 通过。\n示例 1：\n输入：nums = [1,1,2] 输出：2, nums = [1,2,_] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：\n输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按 非严格递增 排列 “非严格递增”的意思是指：序列已经按照从小到大排序了，只不过有些元素重复了，所以是非严格递增；\n有序数列的问题，还是用双指针，只不过指针的用处稍微不同。\n快指针用来判断前后元素是否相同，慢指针用来按照需求保留。\n🥬上菜 这个问题可以使用类似于LeetCode26的解决方案，即使用双指针法。这次也是使用快慢指针，但是有一点不同：当快指针指向的元素与慢指针指向的元素相同时，只移动快指针，以跳过重复的元素；当快慢指针指向的元素不同，将快指针的元素复制到慢指针的下一个位置，然后同时移动快慢指针。\n这样处理后，数组的前 k 个元素就是唯一的元素，并且保持了它们最初的相对顺序，其中 k 是返回的数组长度。\n下面是具体步骤：\n如果数组的长度 n 小于等于1，则直接返回 n（因为没有重复元素需要删除）。 初始化两个指针 slow = 1 和 fast = 1。 当 fast 小于数组长度时，比较 nums[fast] 和 nums[fast - 1]： 如果 nums[fast] 不等于 nums[fast - 1]，说明遇到了一个新的元素，就将 nums[fast] 的值复制到 nums[slow]，然后 slow 增加1。 否则，快指针 fast 继续前进，直到找到一个不同的元素。 当数组遍历完成后，slow 指针的位置就是新数组的长度。 下面是用C++实现的代码示例：\n// 26. Remove Duplicates from Sorted Array #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() \u0026lt;= 1) return nums.size(); int slow = 1; for (int fast = 1; fast \u0026lt; nums.size(); fast++) { if (nums[fast - 1] != nums[fast]) { nums[slow++] = nums[fast]; } } return slow; } }; // 这道题也可以直接使用vector的earse()和unique() // nums.erase(unique(nums.begin(), nums.end()), nums.end()); 这段代码通过双指针法高效地实现了原地删除数组中的重复项，且只使用了 O(1) 的额外空间。由于 nums 是非严格递增排列的，可以确保所有的重复项都是连续出现的，这让问题变得更加简单。\n","permalink":"https://ahaknow.com/posts/know/leetcode-26-remove-duplicates-from-sorted-array/","summary":"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things: Change the array nums such that the first","title":"Leetcode：26删除有序数组中的重复项"},{"content":"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i \u0026lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例 1：\n输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2：\n输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,3,0,4] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示：\n0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100 这道题的用意是指，不能用额外空间。\n不能用额外空间，那就用两个指针。快慢指针，这种设计很巧妙，快指针遍历，慢指针覆盖，因为有筛选，所以原始数组的大小够用\n🥬上菜上菜 可以使用双指针法来实现原地算法。具体来说，可以采用快慢指针的策略：快指针（fast）遍历数组，慢指针（slow）指向更新数组的下一个位置。当遇到与 val 相等的元素时，快指针继续前进，跳过这些元素；当遇到不等于 val 的元素时，将其复制到慢指针的位置，然后慢指针前进。这样，所有不等于 val 的元素都被移动到数组的前面，且不需要使用额外的空间。\n下面是具体的步骤：\n初始化两个指针：fast = 0, slow = 0。 遍历数组，fast 作为遍历的指针，slow 指向下一个可能存放非 val 元素的位置。 如果 nums[fast] 不等于 val，就将 nums[fast] 的值复制到 nums[slow]，然后 slow 前进一位。 fast 指针每次循环都前进一位。 当 fast 遍历完整个数组后，slow 的位置即为新数组的长度。 这种方法之所以高效，是因为它避免了对 val 元素的重复检查和不必要的元素移动。\n下面是用C++实现的代码示例：\n// 27. Remove Element #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 快慢指针 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { // 快指针遍历数组，慢指针按需替换 int slow = 0; for (int fast = 0; fast \u0026lt; nums.size(); fast++) { if (nums[fast] != val) { nums[slow++] = nums[fast]; } } return slow; } }; // 当返回slow后，之后nums[]里有多少个元素，同时nums[]slow位置及以前的都已经按要求替换好，slow位置以后的不管了 这段代码中，fast 和 slow 两个指针分别扮演了遍历数组和更新数组的角色。通过这种方式，可以实现原地修改数组，同时只使用 O(1) 的额外空间。\n","permalink":"https://ahaknow.com/posts/know/leetcode-27-remove-element/","summary":"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things: Change the array nums such that","title":"Leetcode：27移除元素"},{"content":" LeetCode上“最简单”的一道题了吧？\n长时间没有写过题，面试的时候竟然不会写了，奇耻大辱的一件事！\nYou are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints:\nnums1.length == m + n nums2.length == n 0 \u0026lt;= m, n \u0026lt;= 200 1 \u0026lt;= m + n \u0026lt;= 200 -109 \u0026lt;= nums1[i], nums2[j] \u0026lt;= 109 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意: 最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n示例 1：\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2：\n输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3：\n输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示：\nnums1.length == m + n nums2.length == n 0 \u0026lt;= m, n \u0026lt;= 200 1 \u0026lt;= m + n \u0026lt;= 200 -109 \u0026lt;= nums1[i], nums2[j] \u0026lt;= 109 直接使用“双指针”的写法！\n（你还记得你多年未写算法题，想到了双指针，结果一上来写了两个for的蠢事嘛🤣）\n🥬直接上菜 从两个数组的末尾开始，每次取两者之中较大的数，放到 nums1 的合适位置。这样，当 nums2 被完全复制到 nums1 后，合并就完成了，因为 nums1 和 nums2 本来就是有序的。\n下面是详细的步骤：\n初始化两个指针 p1 和 p2 分别指向 nums1 和 nums2 的有数值的末尾，即 p1 = m - 1, p2 = n - 1。同时，初始化 p 指向 nums1 的末尾，即 p = m + n - 1。 比较 p1 和 p2 指向的值，将较大的值放在 p 位置上，并移动指针 p 和被选中的 p1 或 p2。 如果 p2 \u0026gt;= 0 而 p1 \u0026lt; 0，意味着 nums1 已经被遍历完，但 nums2 还有元素未被复制过去，此时直接将 nums2 的剩余元素复制到 nums1 的前面。 如果 p1 \u0026gt;= 0 而 p2 \u0026lt; 0，意味着 nums2 已经被遍历完，nums1 的剩余元素已经在正确的位置，不需要做任何操作。 下面是用C++实现的代码示例：\n// 88. Merge Sorted Array #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 逆向双指针 class Solution { public: void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums1, int m, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int n) { // 确定终点指针 // 合并后留下nums1数组 int p1 = m - 1, p2 = n - 1, p = m + n - 1; // 因为已经排序，逆向考虑就是从大往小 while (p1 \u0026gt;= 0 \u0026amp;\u0026amp; p2 \u0026gt;= 0) { if (nums1[p1] \u0026gt; nums2[p2]) { // 从后往前，先安排大的 nums1[p--] = nums1[p1--]; } else { nums1[p--] = nums2[p2--]; } } // //这时候再看p1和p2谁大于零 // 其实只要看p2是不是大于零就行，因为是从nums2合并到nums1 while (p2 \u0026gt;= 0) { nums1[p--] = nums2[p2--]; } } }; // 这道题可以直接把两个vector加起来，然后一个sort()解决 这段代码通过从后向前遍历 nums1 和 nums2，避免了合并时覆盖 nums1 中未被检查的元素，同时减少了需要移动元素的次数。\n时间复杂度为 O(m+n)，空间复杂度为 O(1)，因为它不需要额外的存储空间。\n","permalink":"https://ahaknow.com/posts/know/leetcode-88-merge-sorted-array/","summary":"LeetCode上“最简单”的一道题了吧？ 长时间没有写过题，面试的时候竟然不会写了，奇耻大辱的一件事！ You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n,","title":"Leetcode：88合并两个有序数组"},{"content":" 我想重命名一个文件（手动操作是不可能的，懒！）\n将“清晰易懂的的线性代数，国立阳明交通大学周志成，国语版mit线性代数Gilbert Strang LA_1-3”改成“LA_1-3”\n所以，就想到了正则匹配咯～\n🍲直接上代码 import os import re # 指定你想要处理文件的目录 directory = \u0026#39;./\u0026#39; # 正则表达式匹配模式 pattern = re.compile(r\u0026#39;LA[_\\-\\d\\w\\s]+.*?\\.mp4$\u0026#39;) # 遍历指定目录下的所有文件 for filename in os.listdir(directory): if filename.endswith(\u0026#34;.mp4\u0026#34;): # 只处理扩展名为.mp4的文件 match = pattern.search(filename) # 在文件名中搜索匹配的部分 if match: new_filename = match.group() # 如果找到匹配，使用匹配的字符串作为新文件名 old_path = os.path.join(directory, filename) new_path = os.path.join(directory, new_filename) # 重命名文件 # os.rename(old_path, new_path) print(f\u0026#39;Renamed \u0026#34;{filename}\u0026#34; to \u0026#34;{new_filename}\u0026#34;\u0026#39;) 正则表达的解释 正则表达式r'(LA[_\\-\\d\\s]+[\\w\\s]*\\.mp4)$'：\nr''：在字符串前面加上r表示这是一个原始字符串，这样做可以确保字符串中的反斜杠不会被当作转义字符处理。在Python中编写正则表达式时，通常推荐这么做。\nLA[_\\-\\d\\w\\s]+.*?\\.mp4$：这个表达式从左到右的意思是：\n(和)：捕获组，这意味着匹配到的这部分表达式会被作为一个整体处理，可以从匹配结果中单独提取出来。\nLA：匹配字面量字符串\u0026quot;LA\u0026quot;。\n[_\\-\\d\\w\\s]+：这是一个字符集合，它可以匹配下划线_、短横线-、任何数字\\d和任何空白字符\\s。+表示前面的字符集合中的字符至少出现一次。\n_：匹配下划线字符。\n\\-：匹配短横线字符。在字符集中，短横线通常用来表示范围（如a-z），所以当我们想要匹配短横线本身时，需要对它进行转义。\n\\d：匹配任何数字字符。\n\\w：匹配任何单词字符（包括字母、数字和下划线）。\n\\s：匹配任何空白字符（包括空格、制表符、换行符等）。\n.*?：以非贪婪方式匹配零个或多个任意字符（除换行符外）。\n\\.mp4：匹配字面量字符串\u0026quot;.mp4\u0026quot;。点.在正则表达式中通常表示匹配任意字符，所以当我们想要匹配点字符本身时，需要对它进行转义\\.。\n$：这表示行结束符，确保字符串以我们指定的模式结尾。\n这个正则表达式用于匹配以\u0026quot;LA\u0026quot;开头，后面跟随至少一个下划线、短横线、数字或字母数字字符，然后是任意数量的任意字符（.*?表示非贪婪匹配），最后以\u0026quot;.mp4\u0026quot;结尾的字符串。\n主要是抛砖引玉，触类旁通，下次再遇到类似的，就可以自己修改啦\n正则表达式（Regular Expression，简称Regex），其核心思想是模式匹配，通过定义一个搜索模式来匹配字符串中的特定序列，这种模式可以用来进行字符串搜索、替换、分割等操作。\n🌟基本用法和常用元字符 1. 字符匹配 .：匹配任意单个字符，除了换行符。 \\d：匹配任意一个数字（0-9）。 \\w：匹配任意一个字母、数字或下划线。 \\s：匹配任意一个空白字符（空格、制表符等）。 2. 位置匹配 ^：匹配字符串的开始位置。 $：匹配字符串的结束位置。 3. 量词 *：匹配前面的字符零次或多次。 +：匹配前面的字符一次或多次。 ?：匹配前面的字符零次或一次。 {n}：匹配前面的字符n次。 {n,}：匹配前面的字符至少n次。 {n,m}：匹配前面的字符至少n次，但不超过m次。 4. 字符类 [abc]：匹配任意一个在括号内的字符（a、b或c）。 [^abc]：匹配任意一个不在括号内的字符。 5. 分组和引用 ()：将括号内的字符视为一个单独的分组。可以对整个组应用量词，也可以通过编号或名称引用组内的匹配。 |：逻辑“或”操作符，匹配左边或右边的表达式。 6. 转义 \\：转义特殊字符，使之成为字面量意义上的字符，如\\.表示点字符本身，而不是任意字符的匹配。 正则表达式示例：匹配邮箱 这是一种比较简单的写法：\n[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,} [a-zA-Z0-9._%+-]+：这部分匹配电子邮件地址的本地部分，允许字母（无论大小写）、数字、点、下划线、百分号、加号和减号。它假设这些字符可以出现一次或多次。\n@：匹配电子邮件地址中的\u0026quot;@\u0026ldquo;符号。\n[a-zA-Z0-9.-]+：这部分匹配电子邮件地址的域名部分，允许字母（无论大小写）、数字、点和减号。它假设这些字符可以出现一次或多次。\n\\.[a-zA-Z]{2,}：匹配电子邮件地址中的顶级域名，开始于一个点，后面跟着至少两个字母（无论大小写）。这里假设所有的顶级域名至少有两个字符长。\n","permalink":"https://ahaknow.com/posts/know/tech-a-regex-example/","summary":"我想重命名一个文件（手动操作是不可能的，懒！） 将“清晰易懂的的线性代数，国立阳明交通大学周志成，国语版mit线性代数Gilbert Strang LA_1","title":"技术：一个正则表达式的小例子"},{"content":" 又干了一件：“为了一碟醋，包了一锅饺子”的事。。。\n就是重新开始学习Strang老爷子的线性代数课了，然后下载了之前国内字幕组的版本（多年不好好学，英语水平明显下降了！！！），这个版本的老问题一直存在，就是某些视频音轨缺失，只有右耳机有声音（这对于一个常年降噪耳机离耳只是为了补充电量的人来说，简直不能忍。。。）\n于是……\n都是4202年了，有什么问题是写个代码解决不了的呢？\n于是Python闪亮登场✨\n废话不多说，直接上代码：\nfrom moviepy.editor import VideoFileClip, AudioFileClip from pydub import AudioSegment # 加载视频文件 video_clip = VideoFileClip(\u0026#34;./麻省理工-线性代数/[P01]Lec01_方程组的几何解释.mp4\u0026#34;) # 提取音频并保存为临时文件 temp_audio_path = \u0026#34;temp_audio.mp3\u0026#34; video_clip.audio.write_audiofile(temp_audio_path) # 使用pydub处理音频 audio_segment = AudioSegment.from_file(temp_audio_path) # 如果原始音频是立体声，分割为单声道；否则直接复制为左右两个声道 if audio_segment.channels \u0026gt; 1: mono_channels = audio_segment.split_to_mono() right_channel = mono_channels[1] # 右声道 else: right_channel = audio_segment stereo_audio = AudioSegment.from_mono_audiosegments(right_channel, right_channel) # 将处理后的音频保存为另一个临时文件 stereo_audio_path = \u0026#34;temp_stereo_audio.mp3\u0026#34; stereo_audio.export(stereo_audio_path, format=\u0026#34;mp3\u0026#34;) # 使用moviepy将新音频设置回视频 new_audio_clip = AudioFileClip(stereo_audio_path) video_clip.audio = new_audio_clip # 输出处理后的视频文件 video_clip.write_videofile(\u0026#34;./麻省理工-线性代数/[P01]Lec01_方程组的几何解释（修复）.mp4\u0026#34;) # 清理临时文件 import os os.remove(temp_audio_path) os.remove(stereo_audio_path) 这里用到两个Python的工具：pydub、moviepy，直接安装就好。\nmoviepy可以同时处理视频和音频；pydub`主要处理音频部分，这个库提供了更灵活的音频处理功能，包括声道的操作。\npip install moviepy pip install pydub 同时确保系统中也安装了ffmpeg，因为pydub依赖于ffmpeg来处理音频文件：\nbrew install ffmpeg ","permalink":"https://ahaknow.com/posts/know/tech-mp4-audio-track-repair/","summary":"又干了一件：“为了一碟醋，包了一锅饺子”的事。。。 就是重新开始学习Strang老爷子的线性代数课了，然后下载了之前国内字幕组的版本（多年不好","title":"技术：MP4的音轨修复"},{"content":" 博客里使用了自定义的字体，最开始直接采用ttf文件加载的方式，因为博客内容全部是静态存在Github上的，这种直接加载多少有点慢，所以想了一些策略。\n压缩字体 先显示后加载 使用CDN加速 压缩字体 TrueType Font (TTF) 常见的字体文件格式，由Apple和Microsoft在上世纪80年代末共同开发。TTF使用二次贝塞尔曲线来描述字符形状，这种曲线可以精确地表示复杂形状，并且在放大时保持平滑。\nWeb Open Font Format (WOFF) WOFF是专门为Web设计的字体格式，2009年成为W3C的推荐标准。WOFF是基于TTF和OpenType字体格式的，但提供了更好的压缩和额外的元数据支持。WOFF存在两个版本：WOFF 1.0和WOFF 2.0。WOFF 2.0使用了更高效的压缩算法，文件大小比WOFF 1.0更小。\nTTF是一种通用的字体格式，广泛用于各种操作系统和设备，提供了高质量的矢量字体展示。而WOFF是为Web设计的字体格式，它优化了文件大小和加载性能，特别适合在线使用。选择哪种格式取决于你的具体需求：如果你需要确保字体在各种环境中的广泛兼容性，TTF可能是更好的选择；如果你主要关注网页性能和加载速度，WOFF将是更优的选择。\n在MacOS上直接本地转换ttf字体。\n安装woff2工具：\nbrew install woff2 使用以下命令将TTF字体文件转换为WOFF2格式：\nwoff2_compress path/to/your/font.ttf 这会生成一个与原始TTF文件同名，但扩展名为.woff2的文件。例如，如果源文件名为font.ttf，输出文件将会是font.woff2。\n先显示后加载 这里主要是CSS的工作：\n在CSS文件中使用@font-face规则引入转换后的WOFF2字体文件，并通过font-display: swap;属性设置字体显示策略。这样做可以确保文本在字体文件下载完成之前使用回退字体显示，从而提升页面的可用性和性能。\n@font-face { font-family: \u0026#39;MyCustomFont\u0026#39;; src: url(\u0026#39;MyFont.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;); font-display: swap; /* 使用回退字体直到自定义字体加载完毕 */ } 这里，font-display: swap;指示浏览器在自定义字体加载期间使用回退字体，一旦自定义字体加载完毕立即切换。这有助于改善首次内容渲染时间（FCP）和最大内容绘制（LCP）等性能指标。\n也可以使用Web Font Loader，这里就是JavaScript的工作了：\nWeb Font Loader允许添加事件回调和控制字体加载的行为，简单的使用方式如下（需要配合CSS中的@font-face）：\n\u0026lt;script src=\u0026#34;https://ajax.googleapis.com/ajax/libs/webfont/1.6.28/webfont.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; WebFont.load({ custom: { families: [\u0026#39;MyCustomFont\u0026#39;], urls: [\u0026#39;path/to/your/css/file.css\u0026#39;] // CSS文件的路径（可以不特别设置） } }); \u0026lt;/script\u0026gt; 使用jsDelivr实现CDN加速 jsDelivr 是一个免费的开源内容分发网络（CDN），它能够提供对GitHub、npm、WordPress插件等的直接加速服务。这是通过jsDelivr与这些平台的集成以及其在全球多个地点的服务器网络实现的。下面详细解释一下为什么和如何jsDelivr能够直接加速GitHub的内容。\n1. 如何工作\njsDelivr 是设计来优化项目文件的交付速度和可靠性的。它通过缓存和分发静态文件（如JavaScript库、CSS样式表和字体文件等）来实现这一点。当开发者将他们的代码托管在GitHub或npm上时，jsDelivr 可以直接链接到这些资源，并通过其全球分布的CDN网络提供这些资源。\n2. 全球CDN网络\njsDelivr 使用多个CDN提供商，包括Cloudflare、Fastly和Quantil。这意味着它不依赖于单一的CDN提供商，而是能够通过多个网络提供数据，从而确保在全球范围内的高可用性和速度。这种多CDN路由策略使得jsDelivr在处理大量请求、尤其是在流量高峰时，可以提供更加稳定和快速的服务。\n3. GitHub和npm集成\njsDelivr 对GitHub和npm有特别的支持。开发者只需通过简单的URL格式，就可以直接引用在GitHub仓库或npm包中的文件。jsDelivr会自动处理这些文件的CDN分发。\nGitHub：可以直接引用任何GitHub仓库中的文件，jsDelivr 会处理路径并通过其CDN提供这些文件。 npm：可以引用任何npm包中的文件，同样通过CDN加速分发。 4. 性能优化\njsDelivr 不仅仅提供文件的CDN加速，还对文件进行了优化处理。例如，它可以自动压缩文件以减少文件大小，从而加快加载速度。此外，它还提供了一个可以合并多个文件的功能，减少了网页加载时的请求数量。\n5. 易用性和无成本\njsDelivr 是完全免费的服务，为开发者和网站提供了一个零成本的解决方案来优化其资源的分发。它的设置非常简单，只需要修改文件的URL即可开始使用，无需复杂的配置。\n通过GitHub和jsDelivr实现字体文件（如WOFF2格式）的CDN加速：\n步骤 1: 准备字体文件 首先，确保拥有字体文件的使用权，并且该字体文件已经是WOFF2格式。WOFF2是一种为网络优化的字体格式，具有良好的压缩率和快速的加载性能。\n步骤 2: 上传字体文件到GitHub 创建一个新的GitHub仓库（如果还没有的话）。\n将WOFF2字体文件上传到这个仓库中。可以直接在GitHub网站上进行上传，或者使用Git命令行工具。\n例如，如果字体文件名为 example.woff2，可以在仓库的根目录或任何一个子目录中放置这个文件。\n步骤 3: 使用jsDelivr jsDelivr是一个免费的开源CDN服务，它可以提供GitHub仓库中静态文件的CDN支持。\n获取GitHub文件的URL路径。这通常是：\nhttps://github.com/\u0026lt;username\u0026gt;/\u0026lt;repository\u0026gt;/blob/main/path/to/your/font.woff2 其中 \u0026lt;username\u0026gt; 是你的GitHub用户名，\u0026lt;repository\u0026gt; 是你的仓库名，path/to/your/font.woff2 是文件在仓库中的路径。\n将GitHub链接转换为jsDelivr链接。jsDelivr为GitHub项目提供了一个特别的URL格式，用于CDN加速。将上述URL按以下格式改写：\nhttps://cdn.jsdelivr.net/gh/\u0026lt;username\u0026gt;/\u0026lt;repository\u0026gt;/path/to/your/font.woff2 步骤 4: 在网页中使用字体 在HTML或CSS文件中，使用新的jsDelivr CDN链接来引用字体文件。例如，在CSS中，可以这样指定字体：\n@font-face { font-family: \u0026#39;MyCustomFont\u0026#39;; src: url(\u0026#39;https://cdn.jsdelivr.net/gh/username/repository/path/to/your/font.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;); font-weight: normal; font-style: normal; } 这里，font-family 是给字体起的名字，用于后续在CSS中引用。\n","permalink":"https://ahaknow.com/posts/know/blog-font-display-acceleration/","summary":"博客里使用了自定义的字体，最开始直接采用ttf文件加载的方式，因为博客内容全部是静态存在Github上的，这种直接加载多少有点慢，所以想了一","title":"博客优化：自定义字体加速显示"},{"content":" 记不清第一次读《SLAM十四讲》是什么感受了（那会是第一次接触SLAM这个东西），可能似懂非懂，也可能不懂装懂，总之就是没懂。\n这次，时隔两年（我滴个乖，你这两年就这样荒废啦？你都学了个啥😠）重新来读，一点一点，一步一步读懂、理解透，之前可能广度优先浅尝则止了，这次是深度优先刨根问底！\n视觉SLAM概览 视觉SLAM研究和解决的到底是一个什么问题呢？\n一种感性的理解 视觉SLAM所应用的场景是通过图像数据来完成 SLAM(Simultaneous Localization and Mapping) 同时定位与建图任务。而图像是将三维空间的世界和场景“拍扁”成了一张二维平面，因此三维空间中的距离感（深度信息）在二维图像中就消失了，而且这是一种在自然情况不可逆的过程，即不通过其他手段是无法直接从图像中恢复出原有的深度信息。因此SLAM想要实现对自身的定位和对周围环境的建图，那么首先要做的就是得到图像的深度信息。\n对于图像的深度信息，根据相机软硬件的区别有不同的获取策略，通过硬件设备直接测量当然是最准的，比如RGB-D相机，具体有飞行时间原理（Time of Flight，TOF）和结构光原理（Structured Light）两种，不不过这也会有误差。\n而只有图像的情况，如果是已知相对位置关系的两张图像或者多张图像，那么问题还好些，是双目或者多目的立体匹配问题，涉及到多视图几何的知识（Multiple View Geometry，这本书已买，要读起来了！）；如果只是单张图像的话，想要恢复深度就会复杂很多，首先得是多张图像，也就是让相机动起来去模拟两个或者多个相机的情况，比如水平移动或者竖直移动，如果是随意的移动，那问题就更复杂了，因为还得知道相机运动的每一个位置之间的相对关系，这又涉及到后面要提到的问题：视觉里程计（Visual Odometry, VO），用来估计相邻图像所对应相机的运动，并且如果没有绝对物理尺寸作为参考，这种相对的比例放大或者缩小都不会对结果产生实际性的影响，因此这里的尺度（Scale）是不确定的。这里做一个引子，下一篇学习用来介绍如何通过图像估计出深度。\n假设现在能够获取到图像的深度，从图像像素位置能够恢复出其在空间中的三维坐标，这里需要用到相机模型和投影关系的知识，这也需要在后面的学习中补充。\nSLAM想要做的同时定位和建图，这两者都需要知道自身是怎么运动，也就是相机的位置变换是怎么样的，这时候就需要用到视觉里程计的理论：**相邻图像中如果确定同一个点（从像素点对应到三维空间的一点），然后这个点对应的空间点与相机之间的几何关系，从这个几何关系中估计相邻图像对应相机的位置变换。**这一块也是后面学习的重点。\n假设能够实现相邻图像间位置变换关系的计算了，下一步是将一系列这样的相邻对一起计算，得到一个完整的位姿（位置和姿态）序列，由于传感器的噪声也是很难完全去除的，估计的误差也就不可避免，两个两个进行简单计算时可能误差很小，但是这些很小的误差累积起来就会让结果偏差很大，因此只是完成了单纯的视觉里程计还不够，还需要能够把偏差纠正回来。\n**完整的SLAM还需要对位姿估计进行优化，降低系统噪声的影响，同时对于累积的误差可能产生的质变差异，也就是累积漂移（Accumulating Drift），比如实际是起点终点一致，但估计出来终点和起点直接劈叉了，这就需要通过“回环检测”的策论纠正过来。**两者具体实现起来都比较复杂，这也是后面学习需要突破的。\n简单小结一下：\n如果将SLAM按照“外在表现”和“内在服务”这种思路来划分，视觉里程计可以归为“前端”，并且其中所涉及的理论主要与计算机视觉相关。而对于提取的空间点和估计的位姿进行的优化则可以归为后端，因为这些需要优化的数据涉及各种复杂的几何关系，本身就不是线性的，所以后端常用的是一些滤波和非线性优化的算法（……写到这，其实对于滤波在干啥竟然没有直观的感觉，说明此前的学习真的很拉垮！）最后的回环检测同样也会涉及到计算机视觉的理论，比如图像的相似性，由于回环检测的结果会使得整个位姿估计的结果发生整体的纠正，因此可以看作是SLAM前后端之间的纽带。（……好吧，其实写到这，对于怎么进行回环的，也是一脑子懵逼。。。）\n最后的一部分是建图，SLAM讲究的建图需要从两方面来看。\n同时定位的目的是为了构建出地图，根据需要可以构建不同类型的地图，且这个地图能在之后被使用，比如导航，路径规划，重定位等； 建图的本质是通过相机的位姿将相机看到的场景再“拼接”成一个完整的空间，这时如果只选取场景中的代表特征，比如角点、边缘，一般称之为路标（Landmark），那么构建就是一种稀疏的地图；而如果是将整张图像的每一个点（都知道相应的深度）都拿来建图，那么就会得到一个较为稠密的地图，这种地图一般也为点云地图。 到此，SLAM到底是在干啥算了有一个初步的感性认识了，下面还有内容一些需要补充说明。\n关于稠密与稀疏的讨论 这里对地图的稀疏和稠密程度，是一种相对而言的概念，有这样一个观点：\n你看点云地图，即使它再稠密，将这个点云放大来看，那么点与点之间也是有空隙的，这算稠密嘛？\n在讨论点云地图是否稠密时，我们通常不是指点与点之间完全没有空隙，而是相对于感知系统的分辨率和所需的应用精度来说，数据点的密度足够高。\n稠密地图在SLAM和机器视觉中通常是相对定义的。例如，对于某些应用，如导航或障碍物避让，一个地图可能不需要细致到毫米级别的每一个细节，只要能够较为准确地表示出环境的主要结构和障碍物位置，这样的地图就可以被视为是“稠密”的。\n然而，如果应用需要更高精度的环境建模，例如在精密工业应用中，那么即使是通常意义上的稠密点云地图也可能被视为不够稠密。这是因为在放大观察时，点与点之间的空隙可能导致精度不足，这个时候可能就需要网格化（meshing）的操作。\n补充知识 以下为本次学习中发散思维想到的一些知识点的理解和补充。\nSLAM地图的类型及其适用场景 稀疏地图 特点：包含关键的特征点或路标。 应用场景：适用于需要快速、实时响应的场合，如在资源受限的设备上进行基本导航和避障。 稠密地图 特点：提供环境的详尽几何描述。 应用场景：用于需要高度精确的任务，如在复杂环境中进行精细操作的机器人，或者那些需要高精度视觉信息来进行详细分析的应用。 语义地图 特点：不仅记录物理形状，还标注物体的类别信息（如椅子、桌子、门等）。 应用场景：适用于高级交互、辅助机器人和增强现实应用。例如，辅助机器人利用语义地图识别并与特定物体交互，如抓取物品或开关门。 2D地图和3D地图 2D地图：主要用于平面环境，如家庭或仓库中的地面机器人导航。 3D地图：提供环境的三维结构，适用于复杂或多层环境，如多层建筑内的导航或飞行机器人。 点云网格化 网格化是一种将散乱的点云数据转化为连续三维表面的技术。通过这种方式，可以用三角形网格来近似表示物体的表面，从而提高模型的视觉和计算效果。这不仅可以填补点与点之间的空隙，还能提供更平滑、更详细的表面模型，有助于进行更精确的计算和可视化。\n点云网格化的常见方法 Delaunay 三角剖分：\n这是一种常用的方法，可以生成三角网格，通常用于2D和3D空间中。它尝试保证在三角形网格的每个三角形的圆周上没有其他点存在，这有助于最大化最小角，从而避免生成细长的三角形。 泊松表面重建：\n泊松方法是一种流行的3D重建技术，用于从点云中推导出一个平滑的曲面。它基于假设一个隐式表面可以通过点云定位，然后通过求解一个泊松方程来找到最佳的表面。 Marching Cubes 算法：\n这是一个用于提取等值面并创建三角网格的算法。在医学成像和科学可视化中尤其常见。它通过逐个检查数据体积的立方体（或“体素”）的网格，根据边界上的点来构造表面。 Greedy Projection Triangulation：\n这种方法适用于较大的点集，它依赖于贪婪策略来逐步构建三角网格。它通常从一个点开始，逐步向外扩展，直到覆盖所有点。 SLAM的数学表达 从数学的角度来理解SLAM问题，可以归结为机器人的“运动”和机器人对路标（Landmark）的“观测”。\nSLAM（Simultaneous Localization and Mapping）是一个核心问题，在机器人学和自动导航系统中非常关键。它涉及到机器人在未知环境中同时进行自我定位和环境地图构建的过程。理解SLAM的基本问题涉及到几个关键方面：运动方程、观测方程、已知的数据、需要估计的变量、噪声模型以及求解这些问题的方法。\n运动方程 运动方程描述了机器人状态的时间演化，基于其运动模型。在最基本的形式中，这可以表示为：\n$$ x_{t} = f(x_{t-1}, u_t, w_t) $$\n$ x_{t-1} $：上一个时间步的机器人状态（位置和方向）。 $ u_t $：控制输入（如速度和方向变化）。 $ w_t $：过程噪声，模拟由于机器人动力系统的不精确性和环境因素带来的不确定性，通常假设为高斯分布。 观测方程 观测方程描述了机器人如何通过其传感器从环境中获取信息，以及这些信息如何依赖于当前的机器人状态和地图：\n$$ z_t = h(x_t, m, v_t) $$\n$ z_t $：在时间 $ t $ 的传感器观测。 $ x_t $：当前机器人状态。 $ m $：地图中的特征。 $ v_t $：观测噪声，代表传感器误差和其他测量不确定性，通常假设为高斯分布。 已知和未知变量 已知变量： 控制输入 $ u_t $：例如从机器人的驱动系统获得。 观测数据 $ z_t $：来自机器人的传感器。 未知变量： 机器人的状态 $ x_t $：需要实时估计。 地图 $ m $：需要逐步构建和更新。 噪声的存在 过程噪声 $ w_t $：存在于运动方程中，反映了控制输入到实际运动之间的不精确转换。 观测噪声 $ v_t $：存在于观测方程中，反映了传感器本身的不精确性和环境导致的误差。 求解方法 求解SLAM问题通常采用以下几种方法：\n扩展卡尔曼滤波器（EKF）：通过线性化非线性模型处理较小的不确定性和噪声，适用于线性高斯模型。 粒子滤波器（特别是FastSLAM）：使用大量随机样本（粒子）来代表可能的机器人状态和地图配置，适合处理非线性和非高斯问题。 图优化方法：将整个SLAM过程建模为一个优化问题，节点代表状态，边代表运动或观测的约束，通过优化这些约束来精确地估计机器人的轨迹和地图。 理论依据 SLAM的理论基础建立在概率论和估计理论之上，允许系统在存在噪声和不确定性的情况下有效地估计机器人的状态和构建环境地图。这些方法不仅能够提供对当前状态的最佳估计，还可以预测未来状态并修正过去的误差，从而实现对环境的连续\n学习和适应。\n通过这些核心组成部分和方法，SLAM技术可以有效地支持机器人在复杂且未知的环境中进行导航和任务执行。\n","permalink":"https://ahaknow.com/posts/know/slam14-ch2/","summary":"记不清第一次读《SLAM十四讲》是什么感受了（那会是第一次接触SLAM这个东西），可能似懂非懂，也可能不懂装懂，总之就是没懂。 这次，时隔两年","title":"SLAM十四讲第二讲：初识SLAM"},{"content":"第一讲里没有具体需要好好理解的部分，不过自测题目题目值得过一遍。\n1.线性方程Ax=b的求解 有线性方程$Ax=b$，若已知$A,b$，需要求解$x$，该如何求解？这对$A$和$b$有哪些要求？\n（提示：从$A$的维度和秩的角度来分析）\n这个问题很简单，但是值得全面地分析和理解：\n首先假设$A$是一个$m \\times n$矩阵，$x$是一个$n \\times 1$的列向量，$b$是一个$m \\times 1$的列向量。这里的$m$表示方程的数量，$n$表示未知数的数量。\n先从矩阵的秩出发来理解，以列的角度看，矩阵的秩表示了所有列向量线性组合所能达到的空间范围，对于方程$Ax=b$，如果向量$b$在矩阵$A$的列空间中（$b$可以被$A$的列向量线性表示），那么存在至少一个解$x$使得$Ax=b$，因此就有了下面的判断性质（比较矩阵$A$和增广矩阵$A|b$秩的关系）：\n$rank(A) = rank(A|b)$：表明向量$b$在矩阵$A$的列空间中，因此至少存在一个解$x$使得$Ax=b$。 $rank(A) \u0026lt; rank(A|b)$：表明$b$不在$A$的列空间中，因此没有解。 然后再分析$rank(A)$来确定解的情况，是有唯一解还是存在多个解：\n如果$rank(A)=n$（未知数的数量，也就是列的数量），则$A$的所有列向量都是线性独立的，意味着对于给定的$b$，存在唯一的$x$满足$Ax=b$。 如果$rank(A)\u0026lt;n$，则$A$中的某些列向量是其他列向量的线性组合，意味着给定的$b$时，这些可以被其他列向量表示的向量不参与线性组合出$b$，也就可以有任意值作为系数，导致存在无限多个解。 线性方程$Ax=b$的求解方法 ‼️以下的回答来自GPT，自己还不是很理解，需要重新系统学习线性代数的知识后再进行自己的消化吸收！\n超定系统：$m \u0026gt; n$，方程数量多于未知数。 欠定系统：$m \u0026lt; n$，方程数量少于未知数。 适定系统：$m = n$，方程数量等于未知数。 LU分解 原理：将矩阵$A$分解为两个特殊的矩阵乘积，一个下三角矩阵$L$和一个上三角矩阵$U$，即$A=LU$。这样，原始问题$Ax=b$变为求解两个更简单的线性方程组$L(Ux)=b$。 求解过程：首先解$L\\mathbf{y}=b$找到$\\mathbf{y}$，然后解$Ux=\\mathbf{y}$找到$x$。 适用性：特别适用于适定系统，也可用于某些类型的超定和欠定系统，假设$A$可以进行有效的LU分解。 QR分解 原理：将矩阵$A$分解为一个正交矩阵$Q$和一个上三角矩阵$R$，即$A=QR$。正交矩阵具有性质$Q^TQ=I$（$I$是单位矩阵）。 求解过程：利用$Q$的正交性质，原方程$Ax=b$变为$QRx=b$，进一步化简为$Rx=Q^Tb$，然后可以通过回代求解上三角方程组$Rx=Q^Tb$来找到$x$。 适用性：适用于所有类型的系统，尤其是超定系统，因为QR分解提供了一种求解最小二乘问题的自然方法。 奇异值分解（SVD） 原理：SVD将矩阵$A$分解为三个矩阵的乘积，即$A=U\\Sigma V^T$，其中$U$和$V$是正交矩阵，$\\Sigma$是对角矩阵，对角线上的元素是所谓的奇异值。 求解过程：对于方程$Ax=b$，可以转换为$\\Sigma y=U^Tb$（这里$y=V^Tx$），然后通过求解$\\Sigma y=U^Tb$来找到$y$，进一步求得$x=Vy$。 适用性：SVD是一种非常强大的方法，特别是对于奇异矩阵或矩阵秩不满的情况，因为它允许计算伪逆矩阵$A^+$，即使在$A$不可逆的情况下也能找到最小二乘解或最小范数解。 迭代方法求解 原理：迭代方法是从一个初始估计开始，通过重复应用迭代公式来逐步逼近方程的解。常见的迭代方法包括雅可比方法、高斯-赛德尔方法和共轭梯度法等。 求解过程：根据具体的迭代公式，每一步都基于前一步的结果来更新解的估计值，直至满足某个终止条件（如解的变化小于某个阈值）。 适用性：迭代方法特别适用于大规模稀疏矩阵的系统，因为它们通常不需要矩阵分解，而矩阵分解在大规模问题上可能非常昂贵。 2.高斯分布 高斯分布是什么？它的一维形式是什么样子？它的高维形式是什么样子？\n高斯分布，也称为正态分布，高斯分布可以被视为描述自然和人为现象中随机误差的理想模型，其普遍性来源于中心极限定理（Central Limit Theorem, CLT），这个定理说明了许多小效应的累积可以产生高斯分布的现象，具体而言就是：“大量相互独立且分布相同的随机变量之和趋向于服从正态分布，无论原始随机变量的分布如何。”\n高斯分布的一维形式 一维高斯分布（或简称为正态分布）的数学表达式为：\n$$ f(x | \\mu, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right) $$\n其中，$\\mu$是分布的均值，$\\sigma^2$是方差，$\\sigma$是标准差。这个公式描述了在给定均值$\\mu$和方差$\\sigma^2$的情况下，随机变量$X$取特定值$x$的概率密度。图形上，一维高斯分布是一个对称的钟形曲线，其中心位于均值$\\mu$，曲线的宽度由标准差$\\sigma$决定。\n高斯分布的高维形式 高维高斯分布，或多变量高斯分布，是一维高斯分布在多维空间中的推广。其数学表达式为：\n$$ f(\\mathbf{x} | \\boldsymbol{\\mu}, \\Sigma) = \\frac{1}{\\sqrt{(2\\pi)^k |\\Sigma|}} \\exp\\left(-\\frac{1}{2}(\\mathbf{x}-\\boldsymbol{\\mu})^T \\Sigma^{-1} (\\mathbf{x}-\\boldsymbol{\\mu})\\right) $$\n其中，$\\mathbf{x}$是一个$k$维随机向量，$\\boldsymbol{\\mu}$是均值向量，$\\Sigma$是协方差矩阵，$|\\Sigma|$是协方差矩阵的行列式。高维高斯分布的图形是在多维空间中的一个“山峰”，其中心位于均值向量$\\boldsymbol{\\mu}$，“山峰”的形状和方向由协方差矩阵$\\Sigma$决定。\n协方差是衡量两个随机变量联合变化趋势的度量。如果两个变量的增减趋势相同（即一个变量增加时，另一个也增加），则它们的协方差为正；如果一个变量增加时另一个减少，则协方差为负。\n对于两个随机变量$X$和$Y$，协方差定义为$Cov(X, Y) = E[(X - \\mu_X)(Y - \\mu_Y)]$，其中$\\mu_X$和$\\mu_Y$分别是$X$和$Y$的均值，$E$表示期望值操作。\n3.C++基本知识 C++中的类是什么？STL是什么？模版又是什么？\n（将基本常用的举例出来进行说明）\nC++11的新特性以及其他标准\n对于C和C++，我觉得需要系统的课程来学习补充，边用边学是持续的，先打好基础，边学边成长才更好\n以下只是对这个回答的简要回答（举例说明）\n类（Class） 类是C++中用于数据封装和面向对象编程的基本构建块。它定义了一种数据类型的蓝图，包括数据成员（属性）和成员函数（方法），用于操作这些数据。\nclass Car { public: Car(int y, const std::string\u0026amp; m) : year(y), model(m) {} void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;Year: \u0026#34; \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#34;, Model: \u0026#34; \u0026lt;\u0026lt; model \u0026lt;\u0026lt; std::endl; } private: int year; std::string model; }; 标准模板库（STL） STL是一组模板化的通用类和函数的集合，提供了常见的数据结构（如向量、列表、队列等）和算法（如排序、搜索等）。STL的核心组成部分包括：\n容器：存储数据的数据结构。例如std::vector、std::list、std::map等。 算法：操作数据的函数，例如std::sort、std::find。 迭代器：提供对容器中元素的访问方式。 #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {4, 1, 3, 5, 2}; std::sort(vec.begin(), vec.end()); for(int i : vec) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } 模板（Template） 模板允许在不指定具体类型的情况下编写代码。它们使得可以创建泛型类和函数，使代码更加灵活和可重用。\ntemplate \u0026lt;typename T\u0026gt; T add(T a, T b) { return a + b; } // 使用模板函数 int result = add\u0026lt;int\u0026gt;(1, 2); C++11/14/17的新特性举例 C++11 自动类型推断（auto）：让编译器自动推断变量的类型。 基于范围的for循环：简化了集合的遍历。 智能指针：如std::shared_ptr和std::unique_ptr，管理动态分配的内存。 Lambda表达式：允许定义匿名函数。 C++14 泛型Lambda：Lambda表达式中使用自动类型推断。 返回类型推断：函数的返回类型可以被自动推断。 C++17 结构化绑定：允许从数组或元组中一次性解包多个值。 内联变量：对于头文件中的全局变量，允许多个源文件中包含同一个变量而不会引起重定义错误。 std::optional：表示一个可能不存在的值。 4.Linux必备的操作 Linux必备知识 基本命令行操作: 理解如何使用命令行界面（CLI）进行文件系统的导航（如cd, ls, pwd）、文件操作（如cp, mv, rm, mkdir）和文本文件查看与编辑（如cat, nano, vi/vim）。\n软件安装与管理: 熟悉所用发行版的包管理器，如Ubuntu的apt, CentOS的yum或Fedora的dnf，用于安装、更新和管理软件包。\n权限和用户管理: 了解文件权限（chmod, chown）和用户管理命令（useradd, usermod, groupadd），以及如何使用sudo来执行需要超级用户权限的命令。\n进程管理: 学会如何使用ps, top, htop, kill, 和systemctl来查看和管理运行中的进程和服务。\n网络配置和故障排除: 掌握使用ifconfig/ipconfig, ping, netstat, ss, traceroute等命令进行网络配置和故障排查。\nShell脚本编写: 学习基本的Shell脚本编写，以自动化日常任务。\n文件系统管理: 了解不同的文件系统类型，磁盘分区（fdisk, parted），以及如何挂载和卸载文件系统（mount, umount）。\n安全和防火墙: 基本的系统安全知识，如使用iptables或ufw管理防火墙规则，以及使用ssh进行安全远程登录。\nLinux的一些“术” 使用man命令: 几乎所有Linux命令都有手册页，通过man \u0026lt;命令名\u0026gt;可以查看详细的使用说明和选项。 命令行自动完成: 通过按Tab键自动完成命令名称或参数，这不仅可以加快命令输入速度，还可以帮助记忆命令。 使用apropos命令: 如果不确定使用哪个命令，可以通过apropos \u0026lt;关键词\u0026gt;来搜索相关的命令。 建立个人命令备忘录: 当学习新命令时，将它们记录在笔记中，随时查阅。 Linux安装软件 在使用apt（或apt-get）在Ubuntu或基于Debian的系统中安装软件时，软件包通常会被安装到系统的标准目录下，这遵循了Linux的文件系统层次结构标准（FHS）。大部分可执行文件会放置在/usr/bin/或/usr/local/bin/目录下，库文件通常位于/usr/lib/或/usr/local/lib/，而配置文件大多数在/etc/下。文档和示例文件可能位于/usr/share/doc/。\n如何安装软件 如果你只是模糊知道某个软件包的名字，可以使用apt提供的搜索功能来查找正确的软件包名。以下是步骤和示例，以Eigen这个数学库为例：\n更新软件包列表：首先，最好更新本地软件包列表，以确保搜索和安装的是最新版本的软件。在终端中运行：\nsudo apt update 搜索软件包：如果不确定软件包的确切名称，可以使用apt-cache search命令进行搜索。例如，如果要搜索Eigen，可以运行：\napt-cache search eigen 这将列出所有与“eigen”相关的软件包。在结果中，会看到很多与Eigen相关的包，其中可能包括实际的Eigen库包和其他相关包。\n安装软件包：一旦你找到了想要安装的确切软件包名称，就可以使用apt-get install命令进行安装。如果结果显示Eigen的开发包是libeigen3-dev（这是一个常见的包名，用于包含Eigen库的开发文件），就可以运行：\nsudo apt-get install libeigen3-dev 这条命令会安装Eigen库及其所有依赖项。\n如何找到安装的软件 如果想知道apt安装的软件具体放在哪里，可以使用dpkg -L命令来列出软件包安装的所有文件的位置。例如，要找到libeigen3-dev安装的所有文件，可以运行：\ndpkg -L libeigen3-dev 这将列出所有由该软件包安装的文件和目录的路径，包括库文件、头文件、文档等。\n✨Linux的文件系统 Linux的文件系统层次结构标准（FHS, Filesystem Hierarchy Standard）定义了操作系统中目录和目录内容的标准布局。这种标准化设计使得开发者和用户能够预测在任何基于Linux的系统上找到特定类型文件的位置。以下是一些主要目录及其用途的简要说明：\n根目录 / 在Linux中，所有的文件和目录都从根目录开始。这是整个文件系统的起点。\n/bin 这个目录包含执行文件（二进制文件），这些文件是系统启动和运行所必需的，同时也存放了用户常用的命令（如ls, cp等）所依赖的执行文件。\n用例：存放基本的命令，如grep, echo, sleep。这些命令在单用户模式下或紧急恢复时也必须可用。\n/boot 包含启动Linux系统所需的文件，比如Linux内核（vmlinuz），引导加载程序（GRUB或LILO）的配置文件等。\n/dev 这个目录下包含设备文件。Linux将设备视为文件，这些设备文件代表系统中的硬件组件。\n/etc 包含系统配置文件。这些文件只能被根用户或具有适当权限的用户修改。这里包括系统启动脚本、网络配置文件等。\n用例：包含如/etc/passwd（用户账户信息）和/etc/fstab（文件系统挂载的静态信息）等关键配置文件。\n/home 用户的个人目录位于此处。每个用户都有一个与其用户名对应的目录，用于存储个人文件、配置等。\n/lib 包含系统最基本的共享库和内核模块。这些库支持位于/bin和/sbin目录中的二进制文件。\n用例：存放动态链接库（如libc.so.6），它们是执行/bin和/sbin下命令所必需的。\n/media和/mnt /media通常用于挂载可移动媒体设备，如CD-ROMs、USB驱动器等，而/mnt则用作临时挂载文件系统的目的。\n/opt 用于安装“可选”的软件应用。这些是非基本系统软件，通常作为整个应用程序安装在这里。\n用例：第三方应用程序如Google Chrome或某些商业软件可能会安装在这里，每个应用通常有其自己的子目录。\n/proc 这是一个虚拟文件系统，提供对内核和进程信息的接口。它并不占用磁盘空间，而是在内存中动态生成。\n/root 这是系统管理员，也就是root用户的家目录。这与/home目录分开，为了安全性和管理方便。\n/sbin 包含系统管理和维护的必需的执行文件，这些命令通常由root用户运行，如fdisk, ifconfig, swapon等。\n/tmp 一个临时文件存储区域。系统和用户可以在这里创建临时文件。通常，此目录在系统重启时会被清空。\n/usr 包含用户程序和数据。它是Unix System Resources的缩写。随着时间的推移，/usr目录已经成为存储共享系统资源的主要目录。\n/usr/bin：包含用户安装的非系统必需的执行文件。 /usr/lib：类似/lib，但是为/usr/bin下的程序提供库支持。 /usr/local：用于系统管理员安装本地软件，保持与由包管理器安装的软件的分离。 用例：/usr/bin下可能会有如python, gcc等用户级程序。 /var 包含经常变化的文件，如日志文件、打印队列、邮件等。\n/var/log：存放系统日志文件，如/var/log/syslog或/var/log/apache2。 /var/mail：存储用户的邮件。 /var/cache：用于存放应用程序缓存数据。 用例：系统管理员可能需要定期检查/var/log来监控系统和应用程序的活动。 /srv 用于存放服务提供的数据，例如Web服务器和FTP服务器的数据文件。\n用例：如果您运行一个Web服务，网站的数据可能位于/srv/www。\n/sys 与/proc相似，/sys是一个虚拟文件系统，提供了内核、设备和驱动程序的接口。\n用例：/sys提供了一种更加结构化的方式来浏览设备和驱动程序的信息，如查询特定USB设备的信息。\n/etc/cron.* 这些目录（cron.daily, cron.hourly, cron.monthly, cron.weekly）用于存放定时执行的脚本。\n用例：自动备份脚本可能放在/etc/cron.daily中，以确保每天执行。\n5.Vim必须会的几个操作 已经不在执着于美化Vim的各种插件了（因为完全可以用更好的CLion、VSCode之类）\n‼️但是命令行中Vim最方便，但只要知道最基础的操作就足够了：怎么增删改查，怎么复制粘贴。\nVim是一个非常强大的文本编辑器，常被用于编程和脚本编辑。它的操作方式与其他文本编辑器有很大不同，主要基于键盘快捷键，分为多种模式，最主要的是普通模式（Normal Mode）、插入模式（Insert Mode）、命令模式（Command-Line Mode）和可视模式（Visual Mode）。以下是关于Vim的基本用法，包括增删改查、复制粘贴，以及批量执行命令的方法。\nVim的基本操作 进入插入模式 在普通模式下，按i进入插入模式，在光标前插入文本。 按a也可以进入插入模式，在光标后插入文本。 按I在当前行首进入插入模式，按A在当前行尾进入插入模式。 删除文本 在普通模式下，按x删除光标所在位置的字符。 按dd删除光标所在行。 要删除从当前光标位置到行尾的内容，可以使用D。 修改文本 在普通模式下，按r后跟一个字符可以替换光标所在位置的字符。 使用cw可以更改光标开始的单词，这将删除单词并进入插入模式。 查找文本 在普通模式下，按/后输入要查找的文字，然后按Enter进行搜索。按n查找下一个匹配项，按N查找上一个匹配项。 复制和粘贴 在普通模式下，按yy复制当前行，按p粘贴到光标后。 要复制多行，可以先按2yy来复制两行（2可以替换为任何数字，表示行数）。 使用可视模式（按v进入）可以选择特定的文本区域，然后按y复制。 移动操作 基本移动：h（左移）、j（下移）、k（上移）、l（右移）。 按单词移动： w：向前移动到下一个单词的开头。 b：向后移动到前一个单词的开头。 e：向前移动到当前或下一个单词的结尾。 按行移动： 0（零）：移动到当前行的开始。 ^：移动到当前行的第一个非空白字符。 $：移动到当前行的末尾。 跳转到特定行： gg：跳转到文件的第一行。 G：跳转到文件的最后一行。 :\u0026lt;行号\u0026gt;+Enter：跳转到文件中的特定行号。 屏幕移动： H：移动到屏幕顶部的行。 M：移动到屏幕中间的行。 L：移动到屏幕底部的行。 翻页： Ctrl+f：向前翻一页。 Ctrl+b：向后翻一页。 Ctrl+d：向前翻半页。 Ctrl+u：向后翻半页。 可以结合前置数字来实现“批量移动”，这意味着可以在移动命令前加上一个数字来重复该命令多次，例如：\n5j 表示向下（j）移动5行。 3w 表示向前跳过3个单词到下一个单词的开头。 10k 表示向上（k）移动10行。 4$ 表示移动到后面4行的末尾。 Vim与外部（macOS）的复制粘贴 在macOS上，从Vim复制文本到外部程序，首先需要确认你的Vim版本是否支持剪贴板（clipboard）功能。可以通过在终端中输入vim --version查看。如果看到+clipboard，则表示支持剪贴板功能；如果是-clipboard，则表示不支持，可能需要安装支持剪贴板的Vim版本，比如通过brew install vim。\n启用剪贴板支持：确保Vim版本支持系统剪贴板。\n复制文本到剪贴板：\n在普通模式下，要复制整行到系统剪贴板，使用\u0026quot;+yy。（一个一个字符来按） 要复制指定文本，先按v进入可视模式，选择需要的文本，然后使用\u0026quot;+y复制。 从外部粘贴到Vim：在插入模式下，使用Cmd+V（macOS通常的粘贴快捷键）或在普通模式下使用\u0026quot;+p来粘贴剪贴板的内容到Vim。\n一些技巧 在普通模式下，可以通过:norm命令批量执行操作。比如，:norm I//会在所有选中的行前添加//（注释掉这些行）。\n批量替换文本，可以使用:s命令。例如，要在整个文件中替换\u0026quot;old\u0026quot;为\u0026quot;new\u0026quot;，可以使用:s/old/new/g。\n在多个行前添加内容：假设想在文件的每一行前添加序号或特定标记，可以使用:norm命令。例如，:5,10norm I// 会在第5行到第10行的开头添加// 。\n转换大小写：要将选定行的文本转换为大写，可以使用:norm结合gU命令。例如，:5,10norm gU$会将第5到第10行的内容转换为大写。\n快速跳转至匹配的括号：在普通模式下，使用%可以跳转至匹配的括号，这在编辑代码时非常有用。\n撤销和重做：使用u来撤销最近的一次更改，使用Ctrl+r来重做被撤销的更改。\n打开/关闭行号显示：快速切换行号显示，可以使用:set nu!和:set rnu!来分别切换绝对行号和相对行号的显示状态。\n","permalink":"https://ahaknow.com/posts/know/slam14-ch1/","summary":"第一讲里没有具体需要好好理解的部分，不过自测题目题目值得过一遍。 1.线性方程Ax=b的求解 有线性方程$Ax=b$，若已知$A,b$，需要求解","title":"SLAM十四讲第一讲：预备知识"},{"content":" 引子：\n我们生活的世界是三维的，在三维世界中对物体的感知拥有明确的距离感，比如键盘在手的前面，显示器在键盘的前面，那么显示器就在手的更前面（这里的“前”或者“后”属于自定义的界定，也可以认为键盘在手的后面，显示器在手的更后面），而如果通过相机将这个三维世界中的场景拍成一张照片，此时三维空间中的所有距离层次就一起被“拍”进了二维图像中，形象地比喻就是将立体的空间“压”成一张了平面的表达，从此表达空间深度的维度就丢失了，并且这个过程在自然状态下是不可逆的。\n而当我们谈到三维空间（Three-dimensional space，以下称3D）的视觉感知时，则必然与深度（距离层次感）脱不开关系，也就是说，当我们用视觉（人可以用眼睛+大脑，机器可以用图像传感器+软件算法）去感知周围的环境时，只有同时获取到了深度，才有资格去讨论3D的视觉感知，否则还是停留在2D平面图像的层次。\n因此在讨论“3D视觉感知的发展”时可以将关注点聚焦在两处：\n如何提高机器视觉系统获取深度信息的精度和可靠性？（如何获得更高精度的深度信息？） 在融合图像和深度信息后，能够推动哪些3D视觉感知技术的发展？（在拥有图像和深度信息后，我们能继续做什么？） 机器视觉的深度获取 首先，我们讨论的是机器的视觉系统，关于机器视觉的定义，简言之，就是通过“某些设备”让机器能够“看到”周围的环境，在不具体追溯这些设备的软硬件实现时，我们以“相机”这个更为广泛的概念进行代替，也就是说，通过相机（相机内部还需要算法和软件支持）可以让机器“看到”这个世界，而相机实现的不同，则可以让机器看待这个世界的方式也发生改变。\n因此，比较直观地获取深度的方式是直接通过相机软硬件这个载体来实现，在这里只进行简要的介绍，因为以下的每一种相机在具体讨论时都需要大篇幅的内容进行结构、原理和方法的说明。\n从相机的角度来看，获取图像深度的方式可以分为两大类型：\n一种是通过硬件的物理测量，比如向三维空间中发射特殊的光源，这个光源接触到物体发生反射后可以回到接收装置，通过测量光源的来回传播时间获得距离信息的飞行时间原理（Time of Flight，TOF）的深度相机，以及向三维空间中投射具有特殊形状的光源，通过测量计算这些光源在物体表面发生的形变来获得距离信息的结构光原理（Structured Light）的深度相机； 另一种则是通过图像中的几何学关系计算得到，专业的表达是多视图几何（Multiple View Geometry），具体的实现可以是一个相机拍摄的多个连续场景图像，或者是两个或多个相机拍摄的同一个场景图像，其中较为成熟的是通过两个平行相机实现的双目立体视觉（Binocular Stereo Vision）相机。 具体到每一种类型的深度相机，都有其各自的关注点来提高相机获取深度的精度，在此暂不深究。从另一个角度出发，如果没有这些额外的软硬件支持，只能通过相机拍摄二维图像，怎么得到图像的深度信息呢？\n在当下能够通过数据驱动解决复杂问题的大背景下，利用机器学习（更具体一点是深度学习）直接从二维图像中估计出深度是一种技术趋势，比如在paperswithcode.com上检索“Depth Estimation”可以看到很多开源的算法和模型，并且所依赖的数据也不再限制，利用单张图像或者多张图像都有相应的方法。因此更直观的想法就是在相机中嵌入深度学习技术直接从图像中估计出深度信息，从而也就避免了采用额外硬件设备所需要的校准、标定等繁杂的维护工作。\n在深度学习里有一条基本认知是：“数据决定了深度学习的上限，而模型只是逼近这个上限而已”。也就是说，想要通过深度学习完善地解决直接的图像深度估计问题，一个好的模型固然重要，但更为关键是拥有驱动这个模型完好运转的数据燃料，并且数据的质量决定了模型效果，那么怎样获得这些高质量的数据呢？\n上文介绍的通过硬件物理测量和通过图像几何学关系获取深度的两种相机，这些在市场中已经有成熟的产品投入应用，如果用它们得到的深度数据来驱动深度学习，从理论上来讲，最理想的状态也不过是达到了深度相机的最高精度效果，并且物理测量或者几何计算本身就具有的偏差还会对模型的效果产生负面影响。\n因此，从数据驱动的深度学习方法估计图像深度的这一方向切入，如果想要让模型的结果更精确从而获取更可靠的深度信息，还需要从数据上下功夫，具体可实践的方式是使用3D仿真，通过模拟相机和构建3D场景产生所需求的且完全准确的深度信息，可以采用的工具和软件包括：\n3D建模和动画软件：Blender； 游戏物理引擎：Unity 3D，Unreal Engine； 机器人仿真器（开源）：Gazebo Sim； 自动驾驶仿真器（开源）：CARLA。 而随着人工智能的发展，特别是生成式人工智能（Generative AI）的技术，将人工智能自己生成内容的技术融入到3D仿真生成也将成为一种新趋势。\n3D视觉感知技术 有了图像深度（用Z表示）之后，我们能做什么呢？\n首先能够从二维图像恢复出三维的空间关系，图像中每一个像素点(x,y)可以通过投影关系恢复到三维空间中的点(X,Y,Z)，将这些三维的点组合起来就构成了点云（Point Cloud）。 通过点云可以分析出哪些是可以移动的区域，哪些区域不平坦；以及哪些是空间中的阻挡自身运动的障碍物，这些障碍物与自身的实时距离等，这个过程体现的就是三维空间的感知。 由于从三维空间“拍”进二维图像的过程中，距离相机更近的物体会挡住其身后的物体，因此在从二维图像恢复到三维空间时，那些被挡住的部分自然也不会呈现出来，而想要从图像中恢复出一个空间的完整样貌，就需要很多张拍摄到这个空间各个角落的图像一起“组合”，共同“拼接”来还原，这个过程就叫做三维空间的场景重建。 以上的过程在具体实现中会涉及到较多的数学原理推导，在这里没有具体展开说明，但从本质的理解出发，在拥有图像深度之后，视觉的感知就完整了，下面从移动机器人和智能驾驶两个领域来谈一谈3D视觉感知技术的具体应用。\n移动机器人领域 一般而言，移动机器人是在一个区域内运行的，也就是说，移动机器人需要拥有这个区域的地图信息，然后在已有地图的基础上再完成感知、定位、路径规划和导航，甚至在实际应用时还需要考虑对地图的更新。机器人的定位和建图可以通过SLAM（Simultaneous Localization And Mapping）技术来实现，SLAM中也需要知道深度信息，比如视觉SLAM在只提供图像的情况下时通过几何学关系来计算出深度，而如果能够同时提供足够精确的深度信息，那么SLAM的建图和定位精度也会更加准确。\n在3D视觉下，机器人可以做到对物体更加准确和丰富的感知，不仅是对物体实现简单的位置测距，在一些算法的支持下，还能够对特定的物体实现姿态的估计，在同时拥有物体的位置和姿态后，就可以展开定位、抓取等后续的操作。同时利用三维空间的场景重建技术，还能够将机器人所处的三维空间模型恢复出来，以这个三维场景为基础，可以继续构建更丰富的地图形式，以及结合3D检测分割等技术实现更具体的环境感知。\n智能驾驶领域 行驶状态中的车辆是实时运动的，并且车辆所在的道路环境也是实时变化，因此即使没有预先加载的高精度地图，智能驾驶的车辆也应该能够通过视觉或者其他传感器感知到周围环境中其他车辆或者物体的状况变化从而调整自身，这是业界常说的“轻地图，重感知”。\n智能驾驶的车辆，不同于移动机器人在一个区域内运行，也不会像移动机器人一样为了补全视野的盲区而在一个范围内来回打转，车辆的运行轨迹基本是持续向前的，因此对于3D视觉的感知更倾向于实时的呈现，通过相机持续拍摄车辆周围可以获得视频流，而同时拥有了图像深度后，这个平面图像的视频流就可以转换为三维空间的点云运动流，这个转换的过程不涉及深度学习。对点云空间也可以同样进行检测、分割等处理，从而获得周围环境的实时道路状况信息。\n近几年兴起的Occupancy Networks（占用网络）是上述描绘场景的一种近似表达，特别是MonoScene，通过一个网络模型实现了从单张图像中获取深度和语义信息再以三维栅格网络方式呈现的流程，从一定意义上掀起了占用网络的热潮。而从本质出发，如果拥有图像中每一个像素对应的精确深度，那么不管是高密度的三维空间点云还是数据量更低的栅格化网格，都可以顺畅地实现。\n3D视觉感知的本质前提是拥有足够精确的第三维度信息，也就是深度，而后再开展以3D视觉为主导的感知技术才能如鱼得水。现如今虽然说人工智能是大趋势，深度学习方法可以解决很多问题，但要驱动深度学习方法完好运转还需要充足且高质量的数据驱动，不管是先获得精确深度信息还是说直接的3D视觉感知，当应用深度学习方法时，都离不开数据。\n总的来说，3D视觉的核心是先恢复出了准确可靠的深度信息，而后再进行更具体的感知任务。一种思路是从相机本身考虑，但可能目前几种深度相机有理论的上限或者实际应用的瓶颈难以继续突破深度测量的精度和可靠性，另一种思路是完全的数据驱动，首先拥有足够量级的精准深度数据，而后不断优化深度学习的模型来达到最佳效果。3D视觉感知技术的应用也是一样，在拥有准确深度后，很多传统的感知任务都会锦上添花，当然也可以将3D视觉感知作为一个整体，在只有图像输入的情况下实现3D视觉的感知，这里就回到了应用深度学习方法解决的思路，模型优化固然重要，更必要还是高质量数据驱动。\n","permalink":"https://ahaknow.com/posts/know/3d-visual-perception/","summary":"引子： 我们生活的世界是三维的，在三维世界中对物体的感知拥有明确的距离感，比如键盘在手的前面，显示器在键盘的前面，那么显示器就在手的更前面（这","title":"3D视觉感知"},{"content":" 问题的描述是这样的（用我理解后的语言来表达）：\n以搭载2D激光雷达（2D-Lidar）的扫地机器人为例，只考虑在二维平面下的关系。世界坐标系$O_W$，机器人坐标系$O_C$，雷达坐标系$O_L$，雷达坐标系的方向轴与机器人坐标系一致，雷达搭载在机器人上，用机器人坐标系$O_C$的坐标表达，雷达的位置为$(xlc, ylc)$，现在空间中有一个物体点P，通过2D雷达对其测量（雷达旋转方向为逆时针），得到对应的角度$angle$和距离$dis$，现在假设扫地机器人运动的角速度是$w_c$，线速度是$v_c$，在$t_0$时刻时，机器人坐标系$O_C$与世界坐标系$O_W$重合，这里的角度单位都是弧度，距离单位都是米。\n现在给这样一组数据，问在$t_1$时刻时，物体点P在世界坐标系$O_W$下的坐标：\nangle、dis、xlc、ylc、 vc、wc、t1\n需要理解的前提 首先，对于输入数据的理解：可以将测试数据作为一个验证情况，因为，当世界坐标系$O_W$，机器人坐标系$O_C$，雷达坐标系$O_L$之间的关系表达明确时，不管带入什么测试数据，都应该是满足的。\n另外，有一个常识需要补充：在C++环境以及处理物体学、数学分析等进行三角函数计算时，使用的都是弧度制， 1弧度 $\\frac{180}{\\pi}$度，1 度 = $\\frac{\\pi}{180}$弧度。\ndouble degrees = 90.0; double radians = degrees * (M_PI / 180.0); double sinValue = sin(radians); // 使用弧度 🌟进行一步一步拆解 t时间后机器人运动的位置 首先需要理解，扫地机器人是怎么运动的，在这里知道机器人运动同时拥有角速度$w_c$，线速度$v_c$。\n一般情况下，移动机器人是通过控制两个并行轮子的速度差（差速）进行旋转的。两个轮子速度相同时，移动机器人将直线运动，两个轮子速度不同时，移动机器人将绕着某一点进行旋转运动，这个点就是即时转动中心（Instantaneous Center of Rotation, 简称 ICC）。\n也就是说，机器人此时的运动模型是一个圆弧运动，运动的半径$R = \\frac{v_c}{w_c}$，运动的角度可以通过$\\theta = w \\cdot t$得到，而对于机器人中心点的位置情况则可以通过极坐标的关系来得到，也就是机器人中心为一点，绕着ICC为原点，进行半径为R的圆周运动，转动了$\\theta = w \\cdot t$角度，那么转动$t$时间后机器人中心点的位置以XY坐标系（笛卡尔坐标系）表达就是：\n$X_{t} = R \\sin(w_c \\cdot t)$ $Y_{t} = R (1 - \\cos(w_c \\cdot t))$ 由此假设以机器人坐标系$O_C$原点来计算，那么在t时间后，$O_C$原点的坐标在世界坐标系$O_W$上的表达为：\n$X_{W_C} = R \\sin(w_c \\cdot t)$ $Y_{W_C} = R (1 - \\cos(w_c \\cdot t))$ 即时转动中心（Instantaneous Center of Rotation） 在任意给定瞬间，一个在平面上进行复合运动（即同时包含平移和旋转）的物体看起来是围绕一个假想点进行旋转，这个点就是即时转动中心。\n这个点可能位于物体内部，也可能位于物体外部（取决于左右轮的速度），甚至可能无限远（这种情况下，物体的运动可以看作是纯平移）。\n假设一个通过两个并行轮子进行差速驱动的移动机器人，左右轮子的速度分别为$V_l$和$V_r$，两轮中心之间距离为$L$，那么可以定义机器人的线速度$v_c$和角速度$w_c$如下：\n线速度$v_c$，表示机器人移动时机器人中心点的速度，通过左右轮速度的平均值来估计： $$ v_c = \\frac{V_r + V_l}{2} $$ 角速度$w_c$描述了机器人绕ICC的旋转速度，可以通过左右轮速度差与轮距的比值来计算（通过$v = \\omega \\cdot r$得到）： $$ w_c = \\frac{V_r - V_l}{L} $$ 机器人绕ICC的圆弧运动半径$R$（从ICC到机器人中心的距离），根据$v = \\omega \\cdot r$可以得到： $$ R = \\frac{v_c}{w_c} $$\n将上述定义的$v_c$和$w_c$代入到$R$的公式中可以得到： $$ R = \\frac{\\frac{V_r + V_l}{2}}{\\frac{V_r - V_l}{L}} $$ $$ R = \\frac{L}{2} \\cdot \\frac{V_r + V_l}{V_r - V_l} $$\n另一种数学解释 对于ICC的计算，在任意瞬间，机器人的左右轮到ICC的距离固不变，形成一个圆周运动。假设右轮比左轮快，那么ICC位于机器人左侧，ICC距离机器人的中心点为$R$。\n由于机器人的左右两个轮子绕ICC的旋转半径不同，但是它们完成一次完整旋转所需的时间相同，因此有：\n左轮的圆周速度是$V_l$，旋转半径是$R - \\frac{L}{2}$。 右轮的圆周速度是$V_r$，旋转半径是$R + \\frac{L}{2}$。 根据圆周运动的速度公式$v = \\omega \\cdot r$，得到：\n$V_l = w_c \\cdot (R - \\frac{L}{2})$ $V_r = w_c \\cdot (R + \\frac{L}{2})$ 将$w_c$带入解方程可以得到：\n$$ R = \\frac{L}{2} \\cdot \\frac{V_r + V_l}{V_r - V_l} $$\n但是更直观的方式是利用角速度和线速度的定义来直接求解$R$，如下：\n$$ w_c = \\frac{V_r - V_l}{L} \\Rightarrow w_c \\cdot L = V_r - V_l $$\n并且\n$$ v_c = \\frac{V_r + V_l}{2} $$\n而$R$可以理解为机器人（中心点）绕ICC旋转的半径，其线速度$v_c$与角速度$w_c$之间存在如下关系：\n$$ R = \\frac{v_c}{w_c} $$\n圆周运动中的位置计算 对于绕ICC的圆周运动，可以用极坐标系下的圆方程来描述物体的位置。在极坐标系中，一个点的位置由它到原点的距离（半径$R$）和一个角度（$\\theta$）来定义。\n将ICC视为原点，则机器人中心就是这个点，其位置转换为笛卡尔坐标系来表示就是：\n$X = R \\sin(\\theta)$ $Y = R - R \\cos(\\theta) = R (1 - \\cos(\\theta))$ 物体点P在机器人坐标系$O_C$的表达 将2D-Lidar看作为一个点，也就是原点$O_L$，那么在雷达坐标系$O_L$下，物体点P可以直接通过三角关系得到在雷达坐标系$O_L$的表达：\n$X_{L_p} = dis \\cdot \\cos(angle)$ $Y_{L_p} = dis \\cdot \\sin(angle)$ 而雷达坐标系$O_L$和机器人坐标系$O_C$只相差了一个平移关系，也就是$(xlc, ylc)$，因此可以将平移的量加上得到在机器人坐标系$O_C$的表达\n$X_{C_p} = dis \\cdot \\cos(angle) + xlc$ $Y_{C_p} = dis \\cdot \\sin(angle) + ylc$ 物体点P在世界坐标系$O_W$的表达 因为机器人坐标系$O_C$和世界坐标系$O_W$相差了一个旋转，机器人坐标系$O_C$从与世界坐标系$O_W$重合的状态，通过逆时针旋转$\\theta = w \\cdot t$得到现在的状态。\n也就是说，以机器人坐标系$O_C$的表达的物体点P也需要通过这个**逆时针旋转$\\theta = w \\cdot t$**得到在当世界坐标系$O_W$的表达；\n因此世界坐标系$O_W$的物体点P为$(X_{W_p},Y_{W_p})$可以通过$(X_{C_p},Y_{C_p})$应用上逆时针旋转，再加上$O_C$的偏移得到。\n$X_{W_p} = X_{C_p} \\cdot \\cos{\\theta} - Y_{C_p} \\cdot \\sin{\\theta} + X_{W_C}$\n$X_{W_p} = X_{C_p} \\cdot \\sin{\\theta} + Y_{C_p} \\cdot \\cos{\\theta} + Y_{W_C}$\n注意，逆时针为正（以右手坐标系来看，X轴朝左，Y轴朝上）\n逆时针旋转角度 $\\theta$ 的旋转矩阵的证明 从二维旋转的基本几何出发。假设我们有一个点 $P$，在原点 $O$ 的坐标系中的初始位置为 $P(x, y)$，需要求出 $P$ 绕原点逆时针旋转角度 $\\theta$ 后的新位置 $P\u0026rsquo;(x\u0026rsquo;, y\u0026rsquo;)$：\n旋转前，点 $P$ 的位置可以由极坐标 $r$（原点到 $P$ 的距离）和 $\\phi$（$x$ 轴到 $OP$ 的角度）确定。在笛卡尔坐标系中，有：\n$x = r\\cos(\\phi)$ $y = r\\sin(\\phi)$ 当 $P$ 绕原点逆时针旋转 $\\theta$ 后，它的新位置 $P\u0026rsquo;$ 可以用新的极坐标 $r$ 和新的角度 $\\phi + \\theta$ 来表示（$r$ 保持不变，因为旋转不改变原点到 $P$ 的距离）。因此，旋转后的坐标为：\n$x\u0026rsquo; = r\\cos(\\phi + \\theta)$ $y\u0026rsquo; = r\\sin(\\phi + \\theta)$ 使用三角恒等式 $\\cos(a + b) = \\cos(a)\\cos(b) - \\sin(a)\\sin(b)$ 和 $\\sin(a + b) = \\sin(a)\\cos(b) + \\cos(a)\\sin(b)$，我们可以将 $x\u0026rsquo;$ 和 $y\u0026rsquo;$ 重写为：\n$x\u0026rsquo; = r\\cos(\\phi)\\cos(\\theta) - r\\sin(\\phi)\\sin(\\theta)$ $y\u0026rsquo; = r\\sin(\\phi)\\cos(\\theta) + r\\cos(\\phi)\\sin(\\theta)$ 将 $x = r\\cos(\\phi)$ 和 $y = r\\sin(\\phi)$，代入得到：\n$x\u0026rsquo; = x\\cos(\\theta) - y\\sin(\\theta)$ $y\u0026rsquo; = x\\sin(\\theta) + y\\cos(\\theta)$ 将上述方程写成矩阵形式，得到：\n$$ \\begin{bmatrix} x\u0026rsquo; \\ y\u0026rsquo; \\end{bmatrix} = \\begin{bmatrix} \\cos(\\theta) \u0026amp; -\\sin(\\theta) \\\\ \\sin(\\theta) \u0026amp; \\cos(\\theta) \\end{bmatrix} \\begin{bmatrix} x \\ y \\end{bmatrix} $$ 这个矩阵就是逆时针旋转角度 $\\theta$ 的旋转矩阵 $R(\\theta)$，能够将任何给定的点在二维平面上逆时针旋转 $\\theta$ 角度，而不改变点到原点的距离。\n如果旋转是顺时针方向的，角度 $\\theta$ 将被视为负值，以右手坐标系来看，X轴朝左，Y轴朝上时，逆时针旋转是正方向，顺时针旋转则是负方向。\n顺时针旋转角度 $\\theta$ 的旋转矩阵可以通过将逆时针旋转矩阵中的角度 $\\theta$ 替换为它的负值 $-\\theta$ 来得到，因为 $\\cos(-\\theta) = \\cos(\\theta)$ 和 $\\sin(-\\theta) = -\\sin(\\theta)$。这意味着，对于顺时针旋转，旋转矩阵 $R_{cw}(\\theta)$ 是：\n$$ R_{cw}(\\theta) = \\begin{bmatrix} \\cos(-\\theta) \u0026amp; -\\sin(-\\theta) \\\\ \\sin(-\\theta) \u0026amp; \\cos(-\\theta) \\end{bmatrix} $$ 使用三角函数的性质 $\\cos(-\\theta) = \\cos(\\theta)$ 和 $\\sin(-\\theta) = -\\sin(\\theta)$，得到：\n$$ R_{cw}(\\theta) = \\begin{bmatrix} \\cos(\\theta) \u0026amp; \\sin(\\theta) \\\\ -\\sin(\\theta) \u0026amp; \\cos(\\theta) \\end{bmatrix} $$ 因此，顺时针旋转矩阵直接使用正角度 $\\theta$ 为：\n$$ R_{cw}(\\theta) = \\begin{bmatrix} \\cos(\\theta) \u0026amp; \\sin(\\theta) \\\\ -\\sin(\\theta) \u0026amp; \\cos(\\theta) \\end{bmatrix} $$ 这个矩阵可以用来将任何给定的点在二维平面上顺时针旋转 $\\theta$ 角度，这与逆时针旋转从形式上看只是$\\sin(\\theta)$的正负号相反。\n完整的C++实现 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; int main() { // jj double angle, dis, xlc, ylc, vc, wc, t1; std::cin \u0026gt;\u0026gt; angle \u0026gt;\u0026gt; dis \u0026gt;\u0026gt; xlc \u0026gt;\u0026gt; ylc \u0026gt;\u0026gt; vc \u0026gt;\u0026gt; wc \u0026gt;\u0026gt; t1; // angle为弧度制，wc为弧度/s // dis为距离，vc为m/s // 起点(0, 0), 角速度wc, 线速度vc // 经过t1时间 double delta_v = vc * t1; double delta_w = wc * t1; // 机器人坐标系Oc，世界坐标Ow double Xwc, Ywc; double R = vc / wc; Xwc = R * sin(delta_w); Ywc = R * (1 - cos(delta_w)); // 打印Xwc, Ywc // std::cout \u0026lt;\u0026lt; Xwc \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; Ywc \u0026lt;\u0026lt; std::endl; // 求P点在世界坐标系Ow的坐标 // 先求P点在Oc的坐标 double Xcp, Ycp; Xcp = xlc + dis * cos(angle); Ycp = ylc + dis * sin(angle); // 打印Xcp, Ycp // std::cout \u0026lt;\u0026lt; Xcp \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; Ycp \u0026lt;\u0026lt; std::endl; // 再求P点在Ow的坐标 double Xwp, Ywp; Xwp = cos(delta_w) * Xcp - sin(delta_w) * Ycp + Xwc; Ywp = sin(delta_w) * Xcp + cos(delta_w) * Ycp + Ywc; // 打印Xwp, Ywp std::cout \u0026lt;\u0026lt; Xwp \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; Ywp \u0026lt;\u0026lt; std::endl; return 0; } ","permalink":"https://ahaknow.com/posts/know/2d-coordinate-transformation/","summary":"问题的描述是这样的（用我理解后的语言来表达）： 以搭载2D激光雷达（2D-Lidar）的扫地机器人为例，只考虑在二维平面下的关系。世界坐标系$","title":"二维平面下的坐标系变换"},{"content":"就是要实现下面这种效果：\n# 就是展示一下效果^-^ 像这种想法怎么样一步步实现的呢？\n对于前端开发来说，最好的学习方式就是阅读源码学习：\n直接看实现过这个效果的的网站是怎么实现的（只要是HTML+CSS方式的，就能读出来，如果全是JS生成的，那就。。。只能另辟蹊径了。）\n","permalink":"https://ahaknow.com/posts/know/blog-mac-style-code/","summary":"就是要实现下面这种效果： # 就是展示一下效果^-^ 像这种想法怎么样一步步实现的呢？ 对于前端开发来说，最好的学习方式就是阅读源码学习： 直接看实现","title":"博客自定义：实现Mac风格的代码栏"},{"content":"以下是心路历程：\n为了写博客，因为觉得工具看着不爽，变成了学习Python后端（为啥不是Java？质问脸），开始造引擎？\n纠结于用什么博客框架，Hexo？Hugo？Halo？甚至想学JS框架自己做一个！\n最终还是回归了Hugo，因为markdown写完，直接编译，然后push就OK了；\n但是，又纠结起要不要自己租个服务器！国内服务器要备案（想想当年怎么在腾讯云备案的，又怎么气鼓鼓说再也不干这事了），so考虑香港服务器，一台服务器只是用来放博客嘛？（当然可以有很多用处，个人邮箱、下载器等等等）……\n就是一个静态博客啊，Github不就够了！！\n……\n好吧，老老实实Gitub + Hugo（当然可以Vercel自动部署，暂时用不到，Gitub Page就可以了）\n只是为了写作输出，又觉得直接的Hugo模版不够满意，再次变成了重学HTML、CSS、JS，自己动手改……\n改了一些，比如：Mac窗户风格的代码栏（甚至灵机一动还模拟鼠标放置显示关闭、最小化、最大化的效果）\n但是还是有不满意的：比如：标题下面的显示，太单调；目录能不能放置在两边，等等等等……无底深渊！\n算了，先写一篇正经的博客出来吧，剩下的想法之后慢慢补充！\n写博客到底为了啥？ 我是典型的属于“本末倒置”，不管用啥，哪怕就是文本直接展示，写博客的核心就是写啊！哪里是说：哦，这个博客引擎不行，自己写一个；那个框架看着不错，要不要换一个。重点是写先把文章写出来啊！\n就比如再写这篇文章之前，还在纠结，要不要再完善一下博客的外观……是啊，等你都完善了，菜都凉了，结果就是工具做好了，然后没有工作了，这不是搞笑嘛！放到写博客就是，兴致过去了，说要重新拾起来在写，然后精力全放在怎么把博客弄得好看点，最终精力用光了，博客又没写成，于是一年又一年，没了。\n写博客啊，你得先写再考虑展示啊！\n另外一个就是，不能拖，打死不能拖，脑袋里有想法了就写下来，不然一定会忘，不会再想起来的！血的教训！\n因此，现在我需要做的就是：\n把这两天折腾博客的东西记录下来，总结下来，沉淀下来，虽然少，但积少成多！\n以及，此前的博文写得断断续续的，也需要整理再拿出来，或者直接存着吧，今天开始，好好记录！不要停！\n","permalink":"https://ahaknow.com/posts/think/2024-begin-again/","summary":"以下是心路历程： 为了写博客，因为觉得工具看着不爽，变成了学习Python后端（为啥不是Java？质问脸），开始造引擎？ 纠结于用什么博客框架，","title":"折腾博客是为了更好地专注在写作上？"},{"content":" 引子：\n做了一个实时展示的小程序，一开始做的比较粗糙，每次呢，也就是每天的早上，都需要手动去执行，然后用鼠标去一点点调整展示窗口的大小和排列，一共三个窗口，一大两小，排列方式是固定的，但是由于每次都是一点点拖动摆放，因此每一次自己都需要对排列后的样子有一个预期，尽可能调整成看上去还不错的样子，尽管如此这般，也很难做到每次的排列都相同。做到这里，虽然没用到多少时间，几分钟吧，但耗费了不少注意力，因为每天都要想着：早上的第一件事是做这个，而且很有可能哪一天就忘了。晚上的话，还要想着去关掉它，手动关闭，费不了多少时间，但同时消耗了不少注意力，原因和早上的一样：一整天的潜意识里都会挂念着，晚上了得把它关掉。如此，一日复一天，天天如此，重复着同样的工作，而且似乎并没有意识到什么问题……\n都2024年了啊！还是个会敲代码的，天天就干这些事？不知道让这个小程序自己打开再自己关掉嘛？时间一直往前走，怎么写代码的意识还不如从前了呢！\n是啊，已经不知不觉陷入了一种“忙忙碌碌，不思进取，每天做着同样的事，为了活着而活着的”行尸走肉之中了。一天，两天，一周，一个月，大半年，就是这么混过来的，有进步嘛？有一点，但仔细瞧瞧只不过是错觉，很可能还是个负方向的。有反思嘛？好像有过，但借口一句没时间啊就过去了，正如此时敲击着键盘，如果现在不写，那么可能又是，一天过去，一周过去，一个月过去，于是乎，2025年2月20日啦。确实很打脸，因为上一次想要写写文字反思的时候，是2023年2月18日，而当下此刻，是2024年2月19日。。。\n什么时候种树都不迟，只要你意识到了就抡起铲子！也许当下的形势让你觉得自己的所学一文不值，那么就立刻开始，多学习点，想学的就去学，从自己的所爱出发，而不是犹豫、惆怅，还徘徊……\n说回来了，原本这一篇记录是想偏向于“自学的总结”，会涉及一些比较“专业”的东西，一些代码啊，一些指令啥的，昨晚借口一句：“困了先睡觉了”，就没写。欺骗自己说早上醒来写，实际上自己心里很清楚，大概率不可能。人的惰性太自然了，躺着多舒服啊，但如果一直躺着，那不如成为一具尸首。\n正篇：意识到了就立刻行动 我知道此前的我，也是成了“每天重复做着同样工作”的讨厌样子了。\n新的一年，那就由此改变吧！\n实时展示的小程序是吧，加一个自动启动和退出的功能咯！怎么做呢？\n我最开始的想法是将这个小程序软件化，也就是使用QT的可视化图形界面来改写，无奈，尝试了大半天，代码编译看着没问题了，但用不起来，这很大原因和自己没有系统学习有关。现在的chatGPT啊，写代码很厉害了，可能目前我的水平还比较低，用不好它，以至于说是让它辅助我改写，实际上我很多时候并不过脑子，直接复制粘贴，那哪行哦！这不就成了工具的奴隶了，连工具都不如了，这不更容易被食物链中的腐食者给吃了嘛。\n于是，我开始想，能不能通过一些技巧来实现我的需求呢？这些技巧背后依赖的功能应该是存在的，但是我不知道，此时我就是可以通过chatGPT协助了。\n现在是三个窗口（此前实现的时候，使用了多线程，因此同时展示的问题是解决的），我能不能把窗口数量减少，比如两个小窗口直接合成成一个？ 之前每次手动打开都需要手动调整窗口大小和位置，能不能直接在代码中实现预先的设置呢？ 自动打开，Linux上似乎有守护进程可以？但是没有在这里尝试过（这个也是很古老的知识了，至少六年前我就用过），想到过，但是没有行动起来！！ 自动关闭呢？之前设置了通过键盘输入q实现程序的退出，能不能让Linux自动模拟键入q呢？ 按照这个思路我就去做了～\n合并窗口：将思维打开，不要局限 一开始，我是用两个窗口来同时显示两个图像的，最简单也是最笨的操作。为啥之前我就没有想到将两个图像放在一个窗口里呢？\n可能是思维惯性，之前怎么做的，就跟着怎么做了。 也可能就是偷懒，从而导致的不动脑子，以及相应会产生的拖延。 认识到自己的思维存在僵化之后，开始改变：\n首先想到，直接拼接两张图像，上下拼接就能完成。但是在显示上不友好，上下拼接后变成一个长方形了，但是由于显示器很大，把窗口拉长之后上下图居中在一起，上下有空白的，显得很丑，从美观的角度来看的话，如果两个拼接的图像在上下位置能够保证对称，比如上方、两图中间、下方各自留出一块空间，这样就看着舒服了。按照这个思路，那就改～\n直接拼接不成，那就先考虑创建一个大的窗口，然后将两张图像分别搁进去，具体操作起来特别像前端的UI设计，要考虑padding的填充。这样的方法可行，然后还需要加入图像的标题，也采用往大窗口里搁置的思路，同样的，还是考虑了要设置padding的填充，使得标题能够局中。之后就是根据实际的情况，不断地调整窗口的尺寸，padding的大小，以达到自认为满意的比例了。至此，合并窗口完成了，现在的小程序只需要两个窗口就能满足了。\n代码备忘录📝 cv::Mat merged_image; if (left_image_color_global \u0026amp;\u0026amp; !left_image_color_global-\u0026gt;empty() \u0026amp;\u0026amp; disparity_color_global \u0026amp;\u0026amp; !disparity_color_global-\u0026gt;empty()) { int space = 25; // 标题和图像之间的空间 int test_height = 50; // 文本标题的高度（大致估计） cv::Scalar textColor(255, 255, 255); // 文本颜色 int font_face = cv::FONT_HERSHEY_SIMPLEX; double font_scale = 1; int thickness = 2; int top_padding = 20; int between_padding = 60; int bottom_padding = 20; int merged_height = left_image_color_global-\u0026gt;rows + disparity_color_global-\u0026gt;rows + 3 * space + 2 * test_height + top_padding + bottom_padding + between_padding; int merged_width = std::max(left_image_color_global-\u0026gt;cols, disparity_color_global-\u0026gt;cols); merged_image = cv::Mat::zeros(merged_height, merged_width, left_image_color_global-\u0026gt;type()); // 绘制第一个图像和标题 int title1_x = (merged_width - cv::getTextSize(\u0026#34;Left Image\u0026#34;, font_face, font_scale, thickness, nullptr).width) / 2; cv::putText(merged_image, \u0026#34;Left Image\u0026#34;, cv::Point(title1_x, test_height), font_face, font_scale, textColor, thickness); left_image_color_global-\u0026gt;copyTo(merged_image(cv::Rect(0, top_padding + test_height + space, left_image_color_global-\u0026gt;cols, left_image_color_global-\u0026gt;rows))); // 绘制第二个图像和标题 int title2_x = (merged_width - cv::getTextSize(\u0026#34;Dense Disparity\u0026#34;, font_face, font_scale, thickness, nullptr).width) / 2; int merged_mid = left_image_color_global-\u0026gt;rows + 2 * space + test_height + top_padding; cv::putText(merged_image, \u0026#34;Dense Disparity\u0026#34;, cv::Point(title2_x, merged_mid + test_height), font_face, font_scale, textColor, thickness); disparity_color_global-\u0026gt;copyTo(merged_image(cv::Rect(0, merged_mid + bottom_padding + test_height + space, disparity_color_global-\u0026gt;cols, disparity_color_global-\u0026gt;rows))); } 提前设置窗口位置：不知道的不代表没有，以前是搜索，现在是“问” 设置好窗口大小之后，还需要能够实现打开小程序后，两个窗口能够自动“站”到合适的位置。应该是有这样的方法的，只不过是我不知道，在没有chatGPT之前，可以用Google进行搜索，现在有了chatGPT，只要将需求描述清楚，一般互联网上已有的信息就能够获取到。因此我就直接“问”了有没有这样的方法，果然，有的，而且还很简洁。\n忽然想到一点，这个不就是信息差嘛！以前靠信息差吃某一种职位铁饭碗的想法应该在此之后自己消亡了吧？也许不会，因为好逸恶劳，因为懒惰，因为路径依赖？总之，现在自己意识到了还不算迟。\n所以，很可能以后还是很缺“产品经理、项目经理”这种明确知道需求是什么的，能够用精炼的语言将其描述清楚的总揽全局的人，而不缺重复的、低级的、复制粘贴的所谓“程序员”码农。\n代码备忘录📝 cv::namedWindow(\u0026#34;Color \u0026amp; Disparity\u0026#34;, cv::WINDOW_NORMAL); cv::resizeWindow(\u0026#34;Color \u0026amp; Disparity\u0026#34;, 1548, 2160); cv::moveWindow(\u0026#34;Color \u0026amp; Disparity\u0026#34;, 0, 0); // 将窗口移动到左上角 // ---------------------------------------------------------- // 创建点云可视化器 pcl::visualization::PCLVisualizer::Ptr viewer(new pcl::visualization::PCLVisualizer(\u0026#34;Dense PointCloud Viewer\u0026#34;)); viewer-\u0026gt;setBackgroundColor(0, 0, 0); viewer-\u0026gt;addPointCloud\u0026lt;pcl::PointXYZRGB\u0026gt;(point_cloud_ptr_global, \u0026#34;Dense PointCloud\u0026#34;); viewer-\u0026gt;setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, \u0026#34;Dense PointCloud\u0026#34;); viewer-\u0026gt;initCameraParameters(); viewer-\u0026gt;setCameraPosition( 0, 0, -1.5, // 控制相机的XYZ位置 0, 0.25, 1, 0, 1, 0 // 后面点云转了旋转，这里Y为1 ); viewer-\u0026gt;setSize(2220, 2160); // 因为使用了VTK的窗口 vtkSmartPointer\u0026lt;vtkRenderWindow\u0026gt; renderWindow = viewer-\u0026gt;getRenderWindow(); renderWindow-\u0026gt;SetPosition(1900, 0); 自启动：不懂的就多探究，不要是一个“半瓶水响叮当” 之前知道一种方法是用守护进程：通过crontab -e进行设置，我也用这个方法尝试了，发现不起作用。分析原因得到：\n因为，我启动的小程序需要调用显示窗口，OpenCV提供的简易窗口和VTK提供的可视化窗口，而守护进程启动命令时，是一种“文本”方式，无法唤起显示的窗口。\n**以前在服务器上用crontab自启动一些命令，因为只会有文本输出，比较简易，那会儿使用远程服务器，自然也不会涉及显示，也就忽略了这个问题。**所以，我此前对于守护进程的理解还只是皮毛，今天多了一些使用的经验。但更重要的是从这次的经历中学会一些“遇到问题、分析现象、思考解决”的思维。\n发现这条路走不通，于是，将自己的需求重新整理了一遍：\n“我希望在当前显示器下，当前的命令行终端下，定时地执行某一个命令”\n在这个思路下，找到了一个可行的方式：\n在终端中，持续运行一个判断：获取当前时间，判断是否等于设定的需要自动打开的时间，如果是就执行命令，然后之后一段时间里不再执行。\n在Linux环境下，这个判断可以比较直接的实现：通过Bash脚本的方式。（本质就是Bash脚本自动化）\n这里明白了一点，一条路走不通很可能是这路条本身就不对，因为很多时候对一项事物也是处于一种了解皮毛的状态，所以遇到问题了要学会打破“自以为是”，从整体的层面来进行分析，对于这里的问题就是：“守护进程不行，为啥不行，那我把运行的日志打印出来，然后分析一下错误信息，再考虑这种方法是不是本身就不支持。”\n代码备忘录📝 #!/bin/bash TARGET_TIME=\u0026#34;09:00\u0026#34; while true; do CURRENT_TIME=$(date +%H:%M) if [ \u0026#34;$CURRENT_TIME\u0026#34; == \u0026#34;$TARGET_TIME\u0026#34; ]; then /home/metoak/Projects/RealTimeDensePointCloud/C++/build/tensorrt_inference_one_camera /home/metoak/Projects/RealTimeDensePointCloud/C++/models/model_mobilev2_960_512.trt 960 512 sleep 60 # 避免在目标时间多次执行 fi sleep 30 # 每30秒检查一次时间 done 自关闭：脑子是越用越灵光的，多想想，不要固化，不要陷入路径依赖 在这里遇到的问题和自启动时差不多。在最开始实现时，也想到了要实现手动关闭，所以就设置了一个通过键盘关闭的方法。我在想能不能自动关闭时，也就顺着这个思路走下去了：“能不能用指令来模拟键盘输入，来达到跟手动按下键盘一样的效果呢？\n想法是好的，也通过chatGPT进行“询问”和尝试，是有这种方法的，但是无法应用在这个问题的解决上。原因简单分析如下：\n通过一个指令或者一个程序模拟键盘输入，它所生效的位置是这个指令或者程序运行的空间；而我通过键盘控制关闭时，实际上是做了两件事：一、先选中窗口，二、按下键盘上的q键；模拟键盘输入可以完成第二步，但是完成不了第一步，因此这种方法在这里不起作用。\n至少，我在思考问题上，会多想一步了。但也陷进了路径依赖中！\n想让程序自己关闭的最快捷方式难道不应该是在程序内部实现嘛？而且很方便的只需要一个判断就行了，不然要你编码做何用？\n是啊，我忘记了，整个演示程序的代码都是我写的，那我想控制什么时候关闭，不是很容易嘛！（什么时候开启不太行，但用了上面的持续运行判断是可以的，因为开启需要从外界开启。断电的电脑怎么自动开机呢？但开机的电脑可以设置定时关闭，如此常识，自己之前咋就忘了呢。。。）\n所以，有时候可以让自己适当放空，然后重新梳理，一步一步来分析解决。\n路径依赖，说到底也是因为懒，能不能打破懒，还得看自己够不够狠心和韧性了，愈挫愈勇，这个方法不行，大不了从头来，用新的思路来解决！\n代码备忘录📝 // 获取当前时间 auto now = std::chrono::system_clock::now(); std::time_t now_c = std::chrono::system_clock::to_time_t(now); std::tm now_tm = *std::localtime(\u0026amp;now_c); // 检查时间是否超过19:00 if (now_tm.tm_hour \u0026gt;= 19) { std::cout \u0026lt;\u0026lt; \u0026#34;Current time is \u0026#34; \u0026lt;\u0026lt; std::put_time(\u0026amp;now_tm, \u0026#34;%F %T\u0026#34;) \u0026lt;\u0026lt; \u0026#34;, the machine need to rest, See you tomorrow!\u0026#34; \u0026lt;\u0026lt; std::endl; running = false; } // 原来的手动关闭操作 int key = cv::waitKey(1); if (key == \u0026#39;q\u0026#39; || key == \u0026#39;Q\u0026#39;) { running = false; } 结束语：继续坚持，从1到2到3，到100，到一直能坚持 人类最可贵的，不就是会思考嘛，机器智能只会越来越强盛的今后，尤其显得珍贵！\n继续坚持，明天再继续～\n2024年2月19日\n","permalink":"https://ahaknow.com/posts/think/master-of-innovation-or-slave-of-repetition/","summary":"引子： 做了一个实时展示的小程序，一开始做的比较粗糙，每次呢，也就是每天的早上，都需要手动去执行，然后用鼠标去一点点调整展示窗口的大小和排列，","title":"创新的主人还是重复的奴隶？"},{"content":" 让自己不后悔的话，那就动起来！\n动起来就能转起来了！\n—— 2024年4月12日补充\n话说，重新拾起要再次记录的念头，应该是一年前！\n最早开始想要记录，应该是六年前！六年啊！一恍惚就过去了？并且最可怕的事情，对比现在的自己和六年前的自己，似乎，还不如了？！！！\n六年，2190天，每天退步一点点，0.99的2190次方： $$ 0.99^{6\\times365} = 2.7610621 \\times 10^{-10} = 0.00000000028 $$ 真的是，退步的不能再退步了，也真的太可怕了。\n时间无情的走了，而我呢，日复一日，年复一年，忙忙碌碌，重重复复，一路滑向深渊。\n能不能再做到，每天思考并记录呢？以前做到过，但是中断了，能不能在捡起来，再继续做下去！\n一直对自己说，自己是内驱的，自己是自律，结果事实却在打自己脸。\n一样会沉迷于电视剧，一样会沉沦在概率游戏中。\n总之，不知好歹！！\n","permalink":"https://ahaknow.com/posts/diary/2024_first/","summary":"让自己不后悔的话，那就动起来！ 动起来就能转起来了！ —— 2024年4月12日补充 话说，重新拾起要再次记录的念头，应该是一年前！ 最早开始想要记录","title":"2024年的第一篇记录"},{"content":"💊Linux药剂 command-not-found：遇见各种Command not found时服用\n🌊艺术细胞 uhdpaper：当需要使用超高清壁纸时服用\n无聊了？：无聊的时候点看有惊喜！\n🥣日常服用 markdown权威指南：基础和拓展两部分语法\n","permalink":"https://ahaknow.com/toolkits/","summary":"💊Linux药剂 command-not-found：遇见各种Command not found时服用 🌊艺术细胞 uhdpaper：当需要使用超高清壁纸","title":"🧰 医疗箱"}]