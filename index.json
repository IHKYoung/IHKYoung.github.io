[{"content":" 前人栽树，后人乘凉。 或者说，不造轮子要造车。\n总之，就是有些东西，在互联网上已经有记录了，可以收集起来为己用！\nGithub添加Waka记录 可以参考以下两个文档，官方文档的说明更清晰一些，初学者指南可以用来对照自己有没有做对～\n官方文档\n初学者指南\n","permalink":"https://ahaknow.com/posts/know/notes-one-sows-and-another-reaps/","summary":"前人栽树，后人乘凉。 或者说，不造轮子要造车。 总之，就是有些东西，在互联网上已经有记录了，可以收集起来为己用！ Github添加Waka记录 可以","title":"站在前人的肩膀上：笔记收集录"},{"content":"很久没有写日记了呢！\n这个国庆结束的最后一天开始早睡的，今晚是第三次。\n补充一次昨天的感想：当你想要去做的时候，你就是最有力量的！所以预约了半马，张罗了聚餐。\n今天开始早早回家，似乎天黑也更早了。\n怎么说呢，睡觉8小时，工作11小时，留给自己回家的时间只有5小时，晚上6点到11点，算上吃饭，跑步锻炼，这又去掉了1小时，有效时间可能只有4小时，用这个4小时，总结总结今天的收获，也多学点，要给自己留一条后路，因为一旦工作了，很容易就懈怠了，这是前两年吃过的亏。\n感觉有一个想法在酝酿了，我应该要把我的思考、认知，经历、体会，和已经存在这个世界上的知识打通起来，形式一个自己的知识库，借助大模型的力量\n今天的工作记录 工作还是跟三维重建相关的，但是目前遇到一些问题，然后心态也有一些不好，很崩溃吧。\n其实，如果自己能够慢慢来，按照步骤一个一个来解决和分析问题，应根也是能找到突破口的。\n最重要的还是要做好即时的记录，之前飞书文档那种感觉不成体系，需要慢慢把记录-总结-回顾的认知路径打通。\n主要就是说：上班记录的文档太随意，没咋过脑子，没怎么消化，吃多了还容易消化不良，全拉了。。。\n从工作的角度来看：\n遇到问题，慢慢来理，之前写过了没记录忘记了，没关系，大不了重新写，但是这次写的就要好好记录，每前进一步都要踏踏实实。 论文里的思想可以学习，复现的话也不要着急，慢慢看细细想！ 明早可以试试，大不了重新梳理一下嘛，梳理好了就记录，第一次确实能创造，但创造出来了得保存啊，不然总是原地打转了。\n学习思考 人工智能的工具完全可以辅助自己的，都怪之前自己一点都不考虑。\n关于大模型，目前对于我来说，应该是用为主，边用边学嘛～\n","permalink":"https://ahaknow.com/posts/diary/2024-10-09/","summary":"很久没有写日记了呢！ 这个国庆结束的最后一天开始早睡的，今晚是第三次。 补充一次昨天的感想：当你想要去做的时候，你就是最有力量的！所以预约了半马","title":"慢慢来，比较快！"},{"content":"前言 怎么样从一个Python脚本一步一步变成一个可以在多平台上独立使用的App呢？\n在这一部分之前，是改进和优化Python的训练脚本，其中涉及到很多知识点，也有很多心得和体悟，这些需要之后总结补充。\n不记录，肯定是会忘记的，以前干了很多次这样的事，到最后就只剩下一个标题，内容啥的完全想不起来了，所以要实时记录，时常温习。\n教，也是一种学习；输出，温故而知新。\n整体感受 想要把一个Python的脚本转换成一个App，比如在Windows平台上双击即可使用的exe程序，怎么做呢？\n首先，应该是有成熟的工具可以直接使用的，所以先收集信息看看有哪些，做一个整体的了解； 然后，做成App后，需要有交互，并且是基于图形界面的交互（GUI），因此就不能再是简单粗暴的命令行传递参数了； 再者，在设计时，要考虑美观，也要考虑用户体验，因此有很多细节上的需要注意，同时很多功能逻辑上的严谨也需要顾及； 这么来看，在一开始想做的时候，心里大概是有一个数的，知道一步一步分解之后需要怎么做，也能够凭借已有的经验来预估哪些逻辑需要设计，从这一点呢，其实也能学到一个好用的技巧（虽然这个道理以前就已经知道了）：\n拿一张白纸或者一面白板，一步一步写列出思路和提纲，具体往后做的时候就不怕自己脑子里给忘掉了； 而且一旦有灵感之后，还能直接补充到这个白纸或者白板上，有时候就需要这种外置的记忆，想到了就记下来很重要； 不应该纠结于工具本身，而应该落实在具体的做上面； 一次性想明白所有当然是最好的，但更多的时候可能是，一边做，一边更新迭代。 那现在开始做吧！\n工具篇 Windows上的CMake编译 好像是晕到死（Windows）要配合Visual Studio开发打包，但我就是不信这个邪，因为在Linux平台上就是一行命令就能解决的事，凭啥到Windows上要搞一套臃肿的软件呢？！\n确实，想要在Windows上实现cmake+make，很难，但不是不可能！\n首先也是收集了一些信息：\n在Windows上使用 CMake 和 make 通常比在Linux上更复杂，这是由于两者的架构和工具链有根本性的差异。以下是Windows与Linux在构建系统方面的不同之处，以及为什么在Windows上不能像在Linux上直接运行 cmake 和 make。\n1. 工具链的差异 Linux：Linux系统有一个非常标准化的开发环境，几乎所有发行版都预装了GNU工具链，包括gcc编译器和make构建工具。因此，开发人员只需要安装一些基本的开发工具包（如build-essential）即可轻松编译C/C++程序。 CMake 作为跨平台的构建系统，能生成Makefile，然后通过 make 工具来进行编译、链接等任务。\nWindows：Windows系统没有预装类似于Linux的GNU工具链，而是主要依赖于Microsoft Visual Studio 和 MSVC 编译器（Microsoft Visual C++）。Windows的开发环境与Linux存在本质区别，没有默认的标准构建工具如 make。因此，要在Windows上使用CMake生成和构建项目，通常需要依赖Visual Studio或第三方工具。\n2. CMake 与 Make 的工作原理 CMake 是一个跨平台的构建系统生成工具，但它本身并不执行编译或构建工作。CMake 的任务是根据项目配置文件（CMakeLists.txt）生成相应平台的构建文件，例如： Linux：CMake 通常生成 Makefile，然后通过 make 进行构建。 Windows：CMake 通常生成 Visual Studio项目文件 或 NMake Makefiles。Visual Studio 是 Windows 上常用的编译器和构建环境，NMake 是Windows下的一种 make 工具，虽然和GNU make 不完全兼容，但功能类似。 因此，CMake 在Windows上默认生成Visual Studio解决方案文件 (.sln) 或者 NMake Makefiles，而不是传统的GNU Makefile。\n3. 编译器的差异 Linux：Linux系统广泛使用GNU编译器（gcc、g++）和 clang，并且这些工具能够直接与make等构建工具配合工作。编译器和构建工具可以通过统一的方式来调用，CMake也支持生成 Makefile 并与 gcc 配合使用。\nWindows：Windows的默认编译器是 MSVC，它的命令行工具（如 cl.exe、link.exe）与GNU工具链有较大区别。Windows上并没有内置的 gcc 或 clang，这意味着如果不使用Visual Studio，开发人员需要手动安装并配置编译器（如 MinGW-w64 或 Cygwin）和构建工具（如 MSYS2）来提供GNU工具链的支持。\n4. Make 与 NMake 的区别 GNU Make：这是Linux上的默认构建工具，结合Makefile进行依赖管理和构建过程。它与GNU工具链高度集成。 NMake：这是微软提供的 make 工具，专为Windows开发环境设计，通常与MSVC配合使用。虽然NMake的基本功能类似于GNU Make，但它的语法和行为与GNU Make有所不同，NMake不能直接使用GNU风格的Makefile。 5. 跨平台兼容工具 如果不想使用Visual Studio，可以在Windows上通过安装GNU工具链来实现类似Linux的构建体验：\nMinGW-w64：提供了Windows上的GNU编译工具链（gcc 和 g++），并且能够与 CMake 配合使用生成 GNU Makefile，然后可以使用 make 进行构建。MinGW-w64 使你可以在Windows上使用类似Linux的编译环境。 MSYS2：这是一个兼容性更强的环境，基于MinGW和Cygwin，允许在Windows上运行许多Linux工具，包括 bash、gcc、make 等。MSYS2提供了一个接近Linux的终端环境，可以通过CMake生成GNU Makefile，然后使用GNU make 来编译项目。 Cygwin：Cygwin 提供了类似于Linux的环境，支持使用 gcc 和 make 进行开发，但其模拟层较重，性能不如MinGW，并且有时会引入一些额外的兼容性问题。 6. Windows Subsystem for Linux (WSL) Windows Subsystem for Linux (WSL) 提供了一个原生的Linux子系统，允许在Windows上运行Linux二进制程序。你可以在WSL中直接使用 CMake 和 make，因为WSL是一个完整的Linux环境，使用Ubuntu等发行版，你可以完全按照Linux的开发流程进行操作，而无需安装Visual Studio或其他工具链。\n使用WSL的步骤：\n安装WSL和Linux发行版（如Ubuntu）。 在WSL中安装 build-essential 包，包含 gcc、make 等工具。 在WSL中运行 cmake 和 make 完成项目的构建。 7. 不用Visual Studio可以吗？ 答案是可以，但需要选择合适的工具链。你可以通过以下方式在Windows上避免使用Visual Studio： 使用MinGW-w64 或 MSYS2 来提供GNU工具链，配合CMake生成GNU Makefile，然后使用 make 进行编译。 使用WSL，直接在Windows中运行Linux的CMake和Make工具。 使用NMake，如果仍然想使用MSVC编译器，但不希望依赖Visual Studio IDE，CMake也可以生成适用于NMake的Makefile。 8. 总结 Windows和Linux在构建系统上的差异主要体现在工具链和编译器上。Linux拥有标准的GNU工具链和 make，而Windows默认使用Visual Studio和MSVC编译器，导致在Windows上开发时，通常需要依赖Visual Studio或其他第三方工具。 如果你不想使用Visual Studio，可以通过安装MinGW-w64、MSYS2、Cygwin或WSL来获得类似于Linux的开发体验，在Windows上直接使用 cmake 和 make。 实际尝试后发现：\nMSYS2是个好东西，通过设置Path可以在PowerShell中使用，但单独使用MSYS2自带的终端会更好用，因为完全是类Unix风格； MSYS2安装的时候应该是自带MinGW的； MinGW也能单独安装，但好像安装完不知道咋用才好。 用到最后发现核心是这两句：\ncmake -DCMAKE_PREFIX_PATH=\u0026#34;C:/msys64/mingw64\u0026#34; -G \u0026#34;MinGW Makefiles\u0026#34; .. -Wno-dev mingw32-make 以及对于各种依赖和安装包，可以通过pacman来安装，这个其实就是arch linux上面那套，虽然可能没有apt那么完全。\n然后，我发现今天新点亮了一颗技能点，就是在使用搜索时，可以同时回答中英文，甚至加上一些调皮的话，比如下面这样的：\nGot it! Let\u0026rsquo;s create a detailed guide on using MSYS2 and pacman, which will include the steps for setting up the environment and using pacman to install dependencies efficiently. I\u0026rsquo;ll provide the instructions in both English and Chinese for each step, as requested. 😊\nUsing MSYS2 and Pacman for Installing Dependencies 在 MSYS2 中使用 Pacman 安装依赖\n1. Introduction to MSYS2 and Pacman MSYS2 和 Pacman 介绍\nMSYS2 is a powerful platform that brings a Unix-like environment to Windows. It provides a complete package management system through pacman (the same package manager used in Arch Linux) to install and manage software and libraries easily.\nMSYS2 是一个强大的平台，它为 Windows 带来了类似 Unix 的环境。它通过 pacman 提供了一个完整的包管理系统（与 Arch Linux 相同的包管理工具），可以轻松安装和管理软件和库。\nPacman allows you to quickly install packages and manage dependencies. Instead of manually compiling software from source, you can use pacman to install pre-built binaries, making the setup process much smoother.\nPacman 允许你快速安装软件包并管理依赖项。与手动从源代码编译软件相比，你可以使用 pacman 安装预编译的二进制文件，这使得设置过程更加顺畅。\n2. Step-by-Step Installation and Setup 分步安装和设置\n2.1 Download and Install MSYS2 下载并安装 MSYS2\nGo to the official MSYS2 website and download the installer for Windows.\n访问 MSYS2 官网 并下载适用于 Windows 的安装程序。\nRun the installer and follow the default installation path (C:\\msys64 is recommended).\n运行安装程序，并选择默认的安装路径（推荐使用 C:\\msys64）。\n2.2 Update Pacman and System 更新 Pacman 和系统\nAfter installation, you need to update the package database and core packages to ensure you’re working with the latest versions.\n安装完成后，需要更新包数据库和核心包，以确保你使用的是最新版本。\nOpen MSYS2 (either from the Start menu or from the installation folder).\n打开 MSYS2（可以通过开始菜单或从安装文件夹打开）。\nRun the following command to update the package database and the core system:\n运行以下命令以更新包数据库和核心系统：\npacman -Syu You may need to close and reopen MSYS2 to continue the update.\n你可能需要关闭并重新打开 MSYS2 来继续更新。\nAfter reopening, run the update again to ensure everything is up to date:\n重新打开后，再次运行更新命令以确保所有内容都是最新的：\npacman -Su 2.3 Install Essential Development Tools 安装必要的开发工具\nYou can install key development tools like GCC, G++, make, and CMake using pacman.\n你可以通过 pacman 安装关键的开发工具，如 GCC、G++、make 和 CMake。\nTo install the 64-bit toolchain (for compiling 64-bit applications):\n安装 64 位工具链（用于编译 64 位应用程序）：\npacman -S mingw-w64-x86_64-toolchain To install CMake (a common build system generator):\n安装 CMake（一个常用的构建系统生成器）：\npacman -S mingw-w64-x86_64-cmake To install other useful tools (such as Git or Python):\n安装其他有用的工具（如 Git 或 Python）：\npacman -S git python 2.4 Using Pacman to Search and Install Packages 使用 Pacman 搜索并安装软件包\nTo search for a package:\n搜索软件包：\npacman -Ss \u0026lt;package-name\u0026gt; Example:\n例如：\npacman -Ss cmake To install a package:\n安装软件包：\npacman -S \u0026lt;package-name\u0026gt; Example:\n例如：\npacman -S mingw-w64-x86_64-cmake To remove a package:\n删除软件包：\npacman -R \u0026lt;package-name\u0026gt; 2.5 Check Installed Packages 检查已安装的软件包\nTo list all installed packages, run:\n要列出所有已安装的软件包，运行：\npacman -Q 2.6 Compiling Code Using MinGW in MSYS2 在 MSYS2 中使用 MinGW 编译代码\nOnce you’ve installed the MinGW toolchain, you can compile C/C++ code using the standard tools like gcc and g++.\n一旦你安装了 MinGW 工具链，你就可以使用 gcc 和 g++ 等标准工具编译 C/C++ 代码。\nTo compile a C++ file:\n编译 C++ 文件：\ng++ -o output main.cpp To use CMake for a project:\n使用 CMake 进行项目构建：\nmkdir build cd build cmake -G \u0026#34;MSYS Makefiles\u0026#34; .. make 2.7 Using MSYS2 Shells 使用 MSYS2 Shell\nMSYS2 provides different shells for different purposes. The most common shells are:\nMSYS2 Shell: For using Unix-like tools but not for compiling Windows applications. MinGW 64-bit Shell: For compiling 64-bit Windows applications using MinGW-w64. MinGW 32-bit Shell: For compiling 32-bit Windows applications. MSYS2 提供了不同用途的 Shell。常见的 Shell 有：\nMSYS2 Shell：用于使用类 Unix 工具，但不适合编译 Windows 应用程序。 MinGW 64-bit Shell：用于使用 MinGW-w64 编译 64 位 Windows 应用程序。 MinGW 32-bit Shell：用于编译 32 位 Windows 应用程序。 Make sure you open the correct shell depending on what you\u0026rsquo;re building.\n确保你根据要构建的内容打开正确的 Shell。\n3. Conclusion 总结\nMSYS2 combined with pacman provides a powerful and convenient development environment on Windows, bringing the simplicity of package management and tool installation from Linux-like systems. By using pacman, you can quickly install dependencies and libraries without the need to manually compile them from source unless absolutely necessary.\nMSYS2 与 pacman 相结合，为 Windows 提供了一个强大且方便的开发环境，带来了类似 Linux 系统的包管理和工具安装的简便性。通过使用 pacman，你可以快速安装依赖和库，除非万不得已，否则不需要手动从源代码编译。\nWith this guide, you should now be able to install and configure MSYS2, use pacman to manage packages, and set up a working development environment.\n通过本指南，你现在应该能够安装和配置 MSYS2，使用 pacman 管理软件包，并设置一个可用的开发环境。\nThat\u0026rsquo;s it! 🎉 I hope the bilingual style helps you with both your development and language learning.\n总的来说结合使用MSYS2，MinGW，pacman这些，是可以不依赖Visual Studio来实现exe的编译。\n其实一开始也遇到很多小问题，比如没有PCL库，然后PCL又依赖各种库，一开始的想法就是各种尝试嘛，甚至想到了手动安装，然后手动编译安装也是一个巨大的坑啊，后来是配合pacman一起服用了，虽然不及apt那么强大，但至少常用的库都有的，然后再编译需要的库就会顺畅很多。\nPython打包exe 理论上讲，应该是有直接将Python打包成exe程序的工具的，所以我的第一想法是先收集一些信息，比如得到下面这些：\n将Python打包成exe可执行文件的常见需求是为了将Python项目分发给没有Python环境的用户。以下是几种常用的打包工具，并且每种工具都有其优势和适用场景。\n1. PyInstaller 优势：最广泛使用的Python打包工具之一，支持多平台（Windows、Linux、Mac），能够将整个Python项目及其依赖包打包为一个单独的可执行文件。 安装：pip install pyinstaller 使用： pyinstaller --onefile your_script.py --onefile 参数会将所有依赖打包到一个可执行文件中。生成的exe文件通常位于 dist/ 文件夹中。 优点： 支持多平台。 配置灵活，可以指定隐藏控制台窗口（通过 --noconsole），或者包含额外的资源文件。 缺点： 打包后文件较大，因为会打包所有依赖。 对于动态加载的模块或资源文件，需要额外配置。 2. cx_Freeze 优势：与PyInstaller类似，支持多平台打包，尤其适合需要将Python程序打包为Windows可执行文件的场景。它更注重跨平台的兼容性和可扩展性。 安装：pip install cx-Freeze 使用： 需要编写一个 setup.py 文件来定义打包配置： from cx_Freeze import setup, Executable setup( name=\u0026#34;your_app_name\u0026#34;, version=\u0026#34;1.0\u0026#34;, description=\u0026#34;Description of your app\u0026#34;, executables=[Executable(\u0026#34;your_script.py\u0026#34;)] ) 然后运行： python setup.py build 优点： 比PyInstaller更灵活，适合复杂项目。 支持不同的目标平台。 缺点： 配置复杂度较高。 需要手动设置依赖项。 3. Py2exe 优势：专为Windows平台开发的工具，可以将Python程序打包成Windows可执行文件。 安装：pip install py2exe 使用： 同样需要编写 setup.py： from distutils.core import setup import py2exe setup(console=[\u0026#39;your_script.py\u0026#39;]) 然后运行： python setup.py py2exe 优点： 针对Windows进行优化，适合Windows应用程序。 缺点： 仅支持Windows。 相对较旧，不如PyInstaller和cx_Freeze活跃。 4. Nuitka 优势：除了打包功能外，Nuitka还将Python代码编译为C代码，生成的可执行文件通常比PyInstaller和cx_Freeze生成的要小，并且在运行时性能更好。 安装：pip install nuitka 使用： nuitka --standalone --onefile your_script.py 优点： 生成的可执行文件运行效率更高。 文件大小较小。 缺点： 对于依赖复杂的项目，需要更多的配置。 打包速度较慢。 5. PyOxidizer 优势：较新的工具，强调快速的启动时间和轻量级的打包结果。可以将Python解释器和应用程序一起打包，并且支持创建独立的Rust二进制文件。 安装：可以通过Rust的包管理工具 cargo 安装： cargo install pyoxidizer 使用： 编写一个 pyoxidizer.bzl 配置文件，并运行 pyoxidizer 命令。 优点： 能够打包出更小、更快的可执行文件。 缺点： 需要学习Rust工具链的基础。 生态不如PyInstaller和cx_Freeze成熟。 6. Briefcase 优势：是BeeWare项目的一部分，支持跨平台打包，并且能够将Python应用打包为原生平台应用（例如：Windows的exe，macOS的.dmg，甚至是Android和iOS应用）。 安装：pip install briefcase 使用： briefcase create briefcase build briefcase run 优点： 支持多种平台打包。 非常适合开发桌面应用。 缺点： 主要用于GUI应用，命令行工具的打包支持较弱。 总结 PyInstaller 是目前最流行和最通用的选择，尤其适合跨平台和快速开发需求。 cx_Freeze 提供了更多的灵活性和跨平台兼容性，但需要更多的配置。 Nuitka 则更适合追求性能优化的场景，生成的文件更小。 Py2exe 是Windows专用的工具，适合Windows平台开发者。 PyOxidizer 和 Briefcase 则是一些新兴的工具，适合对性能和特定平台有特殊需求的场景。 根据你的需求，可以选择最合适的工具进行打包。如果你需要灵活且简单的方案，PyInstaller 是推荐的首选。如果你对文件大小和执行效率有要求，可以考虑 Nuitka。\n搜索之后，大致有了了解，就可以开始尝试了，看着比较简单的是：cx_Freeze，于是就先试了它，采取什么策略来尝试呢？\n比如，从最小可实现的方式出发吧，调用opencv读取图像并显示出来。尝试可行，似乎路能走通，并且发现了一些在Windows开发的一些规律：\nexe点击运行后都是通过.dll方式来找需要的依赖（动态链接库），如果没有就会出错 如果程序一打开就崩溃了，第一想到是不是链接库没有（这里想到小时候玩的盗版游戏，打不开游戏到网上找一找原因，或者是不是程序自己弹出来缺少哪个.dll，这时候再去下载一个放进文件夹） 在这个过程中，也摸索到了怎么来排查.dll缺失的问题，简单来说就是先看少哪个，少了那就复制过去，但怎么排查呢？也是有工具能直接用的，我还是采用先收集信息再尝试的策略\ncx_Freeze本身是可以用的，但是后来，我产生了一个不成熟的需求：\n能不能将所有的dll和exe一起打包成一个独立exe文件？\n尝试cx_Freeze发现似乎不太行，所以后面就转战了PyInstaller，但是实际用起来，PyInstaller要更好用一些，**因为可以设定的参数更详细，**原本我以为就是命令行参数的输入那么简单，后来因为想到：这种打包工具，应该是有专门的配置文件可以设置的吧？于是就摸清楚了流程。而且如果带着问题和需求出发，可以设置的选项还有很多，比如：\n手动选择哪些dll是额外打包的 是否要显示终端（在cx_Freeze中叫做Win32GUI，显示终端配合打印语句，可以调试；同样，如果想要去除终端创建，那么一定不能出现打印输出到终端） 配置图标，版本信息等等等 实际使用的例子 对于cx_Freeze可以使用install_exe.py写一个打包配置：\nfrom cx_Freeze import setup, Executable import os # 额外的ddl文件 extra_dll_files = [ (\u0026#39;extra_dll/libomp140.x86_64.dll\u0026#39;, \u0026#39;libomp140.x86_64.dll\u0026#39;), (\u0026#39;extra_dll/libomp140d.x86_64.dll\u0026#39;, \u0026#39;libomp140d.x86_64.dll\u0026#39;) ] # 合并所有需要包含的文件 include_files = extra_dll_files # 添加打包选项 options = { \u0026#39;build_exe\u0026#39;: { \u0026#39;build_exe\u0026#39;: \u0026#39;mt3d_2.0\u0026#39;, \u0026#39;include_files\u0026#39;: include_files, \u0026#39;include_msvcr\u0026#39;: True # 包含 Microsoft Visual C++ 运行时库 } } # 配置可执行文件 executables = [ Executable(\u0026#39;main.py\u0026#39;, base=\u0026#39;Win32GUI\u0026#39;, target_name=\u0026#39;mt3d.exe\u0026#39;) ] # 设置打包 setup( name=\u0026#39;MT3D\u0026#39;, version=\u0026#39;1.0\u0026#39;, description=\u0026#39;Manifold Tech Limited 3D Rendererer\u0026#39;, options=options, executables=executables ) 实际运行就是：\npython .\\install_exe.py build 而对于PyInstaller，则可以使用更复杂的配置文件，比如install.spec，这个spec文件本质上也可以看作是Python文件：\n# -*- mode: python ; coding: utf-8 -*- import os # 其他额外考虑的dll文件 extra_dll_files = [ (os.path.abspath(\u0026#39;extra_dll/libomp140.x86_64.dll\u0026#39;), \u0026#39;.\u0026#39;), # 这里的 \u0026#39;.\u0026#39; 表示目标路径是打包后的根目录 (os.path.abspath(\u0026#39;extra_dll/libomp140d.x86_64.dll\u0026#39;), \u0026#39;.\u0026#39;), ] pre_run_pkg_path = os.path.abspath(\u0026#39;PreOps\u0026#39;) pre_run_dlls = [(os.path.join(pre_run_pkg_path, dll), \u0026#39;.\u0026#39;) for dll in os.listdir(pre_run_pkg_path) if dll.endswith(\u0026#39;.dll\u0026#39;)] exe_files = [ (\u0026#39;PreOps.exe\u0026#39;, \u0026#39;.\u0026#39;) ] # 设置附加文件 binaries = extra_dll_files + pre_run_dlls + exe_files # 定义 assets 文件夹的路径 assets_dir = os.path.abspath(\u0026#39;assets\u0026#39;) # 遍历 assets 目录及其子目录 data_files = [] for root, dirs, files in os.walk(assets_dir): for file in files: # 获取文件的绝对路径 file_path = os.path.join(root, file) # 在打包时，将文件放入 assets 文件夹内保持层次结构 target_path = os.path.join(\u0026#39;assets\u0026#39;, os.path.relpath(root, assets_dir)) # 将每个文件的源路径和目标路径添加到 data_files 列表 data_files.append((file_path, target_path)) # 定义 lib 文件夹的路径（包含 .js 文件） lib_dir = os.path.abspath(\u0026#39;lib\u0026#39;) # 遍历 lib 目录及其子目录 for root, dirs, files in os.walk(lib_dir): for file in files: # 获取文件的绝对路径 file_path = os.path.join(root, file) # 在打包时，将文件放入 lib 文件夹内保持层次结构 target_path = os.path.join(\u0026#39;lib\u0026#39;, os.path.relpath(root, lib_dir)) # 将每个文件的源路径和目标路径添加到 data_files 列表 data_files.append((file_path, target_path)) block_cipher = None # EXE 配置 a = Analysis( [\u0026#39;train.py\u0026#39;], pathex=[\u0026#39;.\u0026#39;], binaries=binaries, datas=data_files, hiddenimports=[], hookspath=[], runtime_hooks=[], excludes=[], win_no_prefer_redirects=False, win_private_assemblies=False, cipher=block_cipher, noarchive=False, ) # PYZ 配置 pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher) # EXE 配置 exe = EXE( pyz, a.scripts, [], exclude_binaries=True, # 设置为 True，表示 EXE 中不包含 binaries，因为 binaries 将在 COLLECT 阶段处理 name=\u0026#39;MindCloud Renderer\u0026#39;, debug=False, bootloader_ignore_signals=False, strip=False, upx=True, upx_exclude=[], runtime_tmpdir=None, console=False, # 设置为 False 隐藏控制台窗口 icon=\u0026#39;C:/Users/Quite/CKCode/3DGSMT/assets/logo.ico\u0026#39;, version=\u0026#39;mt3d_version.txt\u0026#39;, # 从文件中读取版本信息 ) # COLLECT 配置 coll = COLLECT( exe, a.binaries, a.zipfiles, a.datas, strip=False, upx=True, upx_exclude=[], name=\u0026#39;MindCloud Renderer\u0026#39; ) #### 以下是单独的一个exe方式 #### #### 32位系统单文件不能大于4G #### # # EXE 配置 # exe = EXE( # pyz, # a.scripts, # a.binaries, # a.zipfiles, # a.datas, # [], # name=\u0026#39;MindCloud Renderer\u0026#39;, # debug=False, # bootloader_ignore_signals=False, # strip=False, # upx=False, # upx_exclude=[], # runtime_tmpdir=None, # console=False, # 设置为 False 隐藏控制台窗口 # icon=\u0026#39;C:/Users/Quite/CKCode/3DGSMT/assets/logo.ico\u0026#39;, # version=\u0026#39;mt3d_version.txt\u0026#39;, # 从文件中读取版本信息 # onefile=True # 设置为 True 以生成单文件 # ) 使用的话就是：\npyinstaller .\\install.spec 其实从这里的注释可以看出，当时遇到了打包一个独立exe程序的问题：文件大小不能超过4G，底层原因可能和32位系统有关系，但如果打包成一个_internal文件夹，就是正常的。写到这里，想到了当时制作晕到死安装盘时候也是，那个晕到死的镜像文件大于4G了，用官网的工具压根复制不完全，结果都4202年了，问题还没有解决，最好是手动选择NTFS文件系统，手动复制进去的，也是折腾了老半天。。。refus+手动复制吧\n以上只能算是一次初步的使用和感受记录，后面如果再用到，可以在此基础上再往前迈进一步了。\nWindows的dll分析工具 说实话，一开始去搜索有哪些dll分析工具的时候，遇到下载失败，github显示的时间是10年前，我都在想，是不是这玩意不能用了，后面才知道是自己不会用。。。纯属傻，比较搞笑的是，点开Dependencies闪退就以为程序不行，但是人家还有个DependenciesGui呢，我给直接忽视掉，导致我一开始直接陷入自闭状态很长一段时间。。。\n搜集的信息是这样的：\n在Windows上检查一个程序的DLL依赖并判断是否有缺失的现代工具可以帮助开发者更好地解决动态链接库（DLL）加载问题。随着Windows系统的发展，传统工具如 Dependency Walker 逐渐无法适应现代系统的新特性，诸如API Set Schema和SxS（side-by-side）依赖等机制。因此，以下是一些最新、成熟且常用的工具，涵盖了从静态到动态分析的不同需求：\n1. Dependencies (lucasg/Dependencies) 简介：Dependencies 是一个现代化的DLL依赖分析工具，专为替代老旧的 Dependency Walker 而设计，能处理Windows 10及以后的API Set Schema和SxS依赖问题。 功能特点： 识别和解析Windows 10的API Set Schema。 支持SxS并行依赖分析。 显示DLL导入导出表，列出函数依赖。 支持静态和动态依赖分析，提供实时的DLL加载信息。 适用场景：处理现代Windows操作系统上的DLL加载问题，特别是涉及动态加载、并行依赖和重定向API的场景。 下载：Dependencies - GitHub 使用方法： 下载并运行 Dependencies.exe。 打开目标可执行文件或DLL，查看依赖树，缺失的DLL会标红。 支持导入表和导出表的查看，帮助你找到具体的函数依赖。 2. Process Monitor (ProcMon) 简介：Process Monitor 是由Microsoft Sysinternals提供的高级系统监控工具，用于实时跟踪所有文件、注册表操作以及DLL加载情况。它可以在应用程序运行时监控并记录DLL的加载过程。 功能特点： 实时监控DLL加载过程。 详细记录每个DLL的加载路径、状态、加载失败的原因。 支持设置复杂过滤器，聚焦DLL加载相关的操作（如 Load Image）。 适用场景：适合分析程序在运行时加载的DLL，调试缺失或加载失败的DLL，解决动态依赖问题。 下载：Process Monitor - Microsoft 使用方法： 启动ProcMon并设置进程过滤器。 运行目标程序，观察DLL的加载情况。 使用 Load Image 过滤器查看所有DLL加载操作，分析是否有加载失败的DLL。 3. ListDLLs 简介：ListDLLs 是一个轻量级命令行工具，来自Microsoft Sysinternals，用于列出正在运行的进程所加载的所有DLL。它能帮助你快速查看应用程序实际加载了哪些DLL以及这些DLL的路径。 功能特点： 列出所有正在运行的进程所加载的DLL。 显示DLL加载的路径和版本信息。 适用场景：快速查看某个进程当前使用的DLL，排查可能的DLL版本冲突或加载错误。 下载：ListDLLs - Microsoft 使用方法： 在命令行中运行 listdlls.exe [进程名或PID]。 查看该进程加载的所有DLL及其路径，排查问题。 4. CFF Explorer 简介：CFF Explorer 是一个强大的PE文件分析工具，允许你查看Windows可执行文件（如EXE、DLL）的结构和依赖。 功能特点： 允许查看PE文件的导入表和导出表。 分析文件的依赖DLL及其加载路径。 支持编辑PE文件的某些部分。 适用场景：适合需要深入分析可执行文件的PE结构、导入表、导出表及依赖关系的开发者。 下载：CFF Explorer - NTCore 使用方法： 打开CFF Explorer，载入目标可执行文件或DLL。 查看“Import Directory”以获取该文件的DLL依赖。 5. PE Explorer 简介：另一个功能强大的PE文件分析工具，类似于CFF Explorer。它专注于查看可执行文件的依赖和内部结构。 功能特点： 查看导入表、导出表以及依赖DLL。 支持编辑文件内部结构。 适用场景：对PE文件结构进行详细分析，解决复杂的DLL依赖问题。 下载：PE Explorer - Heaventools 6. Sigcheck 简介：Sigcheck 是Sysinternals的另一个工具，主要用于检查文件的数字签名，但它也可以列出文件的依赖DLL及其签名信息，适用于排查潜在的DLL安全问题。 功能特点： 列出文件的依赖DLL及其签名信息。 检查DLL是否未签名或有安全风险。 适用场景：适合用于安全分析，检查应用程序依赖的DLL的签名状态，确保没有不安全的依赖。 下载：Sigcheck - Microsoft 使用方法： 在命令行中运行 sigcheck -e [可执行文件或DLL]。 工具会列出依赖的DLL以及它们的签名状态。 7. DLL Export Viewer 简介：这是一个轻量工具，用于查看DLL文件导出的所有函数，帮助你分析DLL内部函数是否完整或者是否被正确调用。 功能特点： 列出DLL的所有导出函数。 支持保存导出列表。 适用场景：适合检查某些DLL是否缺少导出函数，或者导出函数是否与预期一致。 下载：DLL Export Viewer - NirSoft 8. Nirsoft LoadedDllsView 简介：LoadedDllsView 是来自NirSoft的工具，它可以列出指定进程中加载的所有DLL文件及其完整路径。 功能特点： 列出所有加载的DLL文件及其路径。 支持导出DLL列表为文本文件。 适用场景：类似于ListDLLs，适合查看某个进程加载的DLL，解决加载冲突和依赖问题。 下载：LoadedDllsView - NirSoft 9. LDG (Load Dependency Graph) 简介：LDG 是一个新的工具，专门用于生成可执行文件的依赖关系图，帮助开发者可视化文件与DLL之间的关系。 功能特点： 可视化依赖关系图。 支持生成依赖图的文件输出。 适用场景：适合需要可视化文件依赖的场景，帮助更直观地分析复杂依赖树。 下载：LDG - GitHub 总结 在现代Windows环境中，Dependencies 是当前最适合替代 Dependency Walker 的工具，尤其对于Windows 10的API Set Schema和SxS支持，它具有极佳的处理能力。如果你需要动态分析DLL加载情况，Process Monitor 提供了实时监控功能，适合调试复杂的依赖问题。对于轻量级和特定场景的需求，ListDLLs、Sigcheck、CFF Explorer 等工具则可以快速、有效地帮助你分析问题。\n根据你的具体需求，选择合适的工具可以帮助你更快地找到和解决DLL缺失、加载失败或依赖冲突问题。\n以上都不重要，关键是能用，所以第一步要做的是先上手，后来实际发现Dependencies挺好用的，在其他Windows上运行程序时，如果出现一打开就直接挂掉，那么直接用DependenciesGUI分析一下，一般就能找到是哪个dll缺失，然后再把缺失的dll放到程序运行的目录就能解决了。\n查找exe的所有dll依赖并复制在一起 实际开发过程中，我还产生了一个新的需求：比如我cmake编译的exe，运行时所依赖的dll在哪？我想把这些dll 都放到一起，那么这样在其他Windows上，不就可以运行这个exe了吗？\n我最后使用的是这种方法：\n# PowerShell 脚本：Copy-AllDependencies.ps1 param ( [string]$ExePath, # 可执行文件的路径 [string]$OutputDir # 输出目录的路径 ) # 检查输入参数是否有效 if (-not (Test-Path $ExePath)) { Write-Error \u0026#34;Error: The specified EXE file does not exist: $ExePath\u0026#34; exit 1 } if (-not (Test-Path $OutputDir)) { Write-Output \u0026#34;Output directory does not exist. Creating directory: $OutputDir\u0026#34; New-Item -Path $OutputDir -ItemType Directory } # 启动进程以获取所有 DLL 依赖项 $process = Start-Process -FilePath $ExePath -PassThru -WindowStyle Hidden # 暂停几秒钟，以便进程加载所有 DLL Start-Sleep -Seconds 2 # 获取所有加载的 DLL $loadedModules = $process.Modules | Where-Object { $_.FileName -like \u0026#34;*.dll\u0026#34; } # 复制 EXE 文件到输出目录 Copy-Item -Path $ExePath -Destination $OutputDir -Force Write-Output \u0026#34;Copied: $(Split-Path -Leaf $ExePath) to $OutputDir\u0026#34; # 遍历所有找到的 DLL 文件并复制 foreach ($module in $loadedModules) { $dllPath = $module.FileName $dllName = [System.IO.Path]::GetFileName($dllPath) # 构建目标路径 $targetPath = Join-Path -Path $OutputDir -ChildPath $dllName # 复制 DLL 文件到输出目录 try { Copy-Item -Path $dllPath -Destination $targetPath -Force Write-Output \u0026#34;Copied: $dllName to $OutputDir\u0026#34; } catch { Write-Warning \u0026#34;Failed to copy: $dllName\u0026#34; } } # 检查进程是否仍在运行 if (-not $process.HasExited) { # 尝试结束进程 try { Stop-Process -Id $process.Id -Force Write-Output \u0026#34;Process terminated: $process.Id\u0026#34; } catch { Write-Warning \u0026#34;Could not terminate process: $_\u0026#34; } } else { Write-Output \u0026#34;The process has already exited.\u0026#34; } Write-Output \u0026#34;All DLL dependencies copied to: $OutputDir\u0026#34; 或者下面的这种可以重试的写法也行：\nparam ( [string]$ExePath, # 可执行文件的路径 [string]$OutputDir # 输出目录的路径 ) # 检查输入参数是否有效 if (-not (Test-Path $ExePath)) { Write-Error \u0026#34;Error: The specified EXE file does not exist: $ExePath\u0026#34; exit 1 } if (-not (Test-Path $OutputDir)) { Write-Output \u0026#34;Output directory does not exist. Creating directory: $OutputDir\u0026#34; New-Item -Path $OutputDir -ItemType Directory } # 定义最多尝试的次数 $maxRetries = 3 $retryCount = 0 # 复制 EXE 文件到输出目录 Copy-Item -Path $ExePath -Destination $OutputDir -Force Write-Output \u0026#34;Copied: $(Split-Path -Leaf $ExePath) to $OutputDir\u0026#34; # 循环尝试重启进程 do { # 启动进程并确保它在后台运行，防止它被快速终止 $process = Start-Process -FilePath $ExePath -PassThru -WindowStyle Hidden # 暂停几秒钟，以确保 DLL 加载完成 Start-Sleep -Seconds 5 # 检查进程是否仍在运行 if (-not $process.HasExited) { # 获取加载的模块（DLL） $loadedModules = $process.Modules | Where-Object { $_.FileName -like \u0026#34;*.dll\u0026#34; } # 遍历所有找到的 DLL 文件并复制 foreach ($module in $loadedModules) { $dllPath = $module.FileName $dllName = [System.IO.Path]::GetFileName($dllPath) # 构建目标路径 $targetPath = Join-Path -Path $OutputDir -ChildPath $dllName # 复制 DLL 文件到输出目录 try { Copy-Item -Path $dllPath -Destination $targetPath -Force Write-Output \u0026#34;Copied: $dllName to $OutputDir\u0026#34; } catch { Write-Warning \u0026#34;Failed to copy: $dllName\u0026#34; } } # 停止进程 try { Stop-Process -Id $process.Id -Force Write-Output \u0026#34;Process terminated: $process.Id\u0026#34; } catch { Write-Warning \u0026#34;Could not terminate process: $_\u0026#34; } # 退出循环 break } else { Write-Error \u0026#34;Error: The process has already exited before capturing dependencies. Retrying...\u0026#34; $retryCount++ Start-Sleep -Seconds 2 # 等待几秒钟后再试 } } while ($retryCount -lt $maxRetries) if ($retryCount -ge $maxRetries) { Write-Error \u0026#34;Failed to capture dependencies after multiple attempts.\u0026#34; } Write-Output \u0026#34;All DLL dependencies copied to: $OutputDir\u0026#34; 但是这里有一个关键，程序运行后不能直接退出，所以我在代码里加了一个线程等待，还有一个输入等待，算是一个取巧的做法吧~\n// 延时 10 秒 printf(\u0026#34;Delay 10 seconds...\\n\u0026#34;); std::this_thread::sleep_for(std::chrono::seconds(10)); std::cout \u0026lt;\u0026lt; \u0026#34;Press Enter to continue...\u0026#34; \u0026lt;\u0026lt; std::endl; std::cin.get(); // 等待用户输入，按下 Enter 键继续 实际情况说明，如果只是输入等待，有时候是不行的，就是程序直接跳出了，什么dll也没复制，所以后面又强行加入了线程等待。\n我是之前没有及时记录，结果发现：确实，都忘了！\n好记性不如好记下啊！！！\nWindows打包安装程序 其实PyInstaller这种打包了就能用，如果缺少什么dll依赖，直接复制放进去就行。\n这种就已经是纯净绿色免安装版了，用起来挺方便，分发的话，进行压缩后就可以。\n但是呢，既然都已经做到这一步了，那就再往前多探一步吧。\n将 .exe 和 .dll 文件打包成安装包形式是软件发布的常见需求，特别是对于Windows平台的应用程序。为了实现这一点，可以使用多种工具来打包和生成安装程序，这些工具可以帮助你将可执行文件、依赖的动态链接库（.dll 文件）、资源文件等一起打包为可安装的格式，如 .msi 或 .exe 安装程序。以下是一些常见且成熟的打包工具，详细说明了它们的功能及适用场景。\n1. Inno Setup 简介：Inno Setup 是一个功能强大且易于使用的免费安装程序创建工具，适用于 Windows 平台。它允许你将应用程序的 .exe、.dll、配置文件等打包为单个 .exe 安装程序。\n主要特点：\n支持将多个文件和目录打包成单个 .exe 安装文件。 支持自定义安装向导界面、许可协议、安装路径等。 提供脚本功能，用于编写复杂的安装逻辑。 支持安装和卸载时的注册表操作、DLL注册等。 适用场景：适合需要简单到中等复杂度的安装包创建需求，适用于个人项目和小型到中型的软件分发。\n使用方法：\n下载 Inno Setup 并安装。 创建 .iss 脚本文件，定义要打包的文件、安装路径等。 使用 Inno Setup 编译生成安装程序。 示例 .iss 文件：\n[Setup] AppName=My Application AppVersion=1.0 DefaultDirName={pf}\\MyApplication OutputBaseFilename=setup Compression=lzma SolidCompression=yes [Files] Source: \u0026#34;bin\\MyApp.exe\u0026#34;; DestDir: \u0026#34;{app}\u0026#34;; Flags: ignoreversion Source: \u0026#34;bin\\*.dll\u0026#34;; DestDir: \u0026#34;{app}\u0026#34;; Flags: ignoreversion [Icons] Name: \u0026#34;{group}\\My Application\u0026#34;; Filename: \u0026#34;{app}\\MyApp.exe\u0026#34; 2. NSIS (Nullsoft Scriptable Install System) 简介：NSIS 是一个非常灵活的开源安装程序创建工具，广泛用于创建 Windows 安装程序。它允许自定义安装逻辑和界面，并支持安装包压缩和多种格式的打包。\n主要特点：\n高度可自定义的安装过程，通过脚本编写安装逻辑。 支持多种安装模式（静默安装、标准安装等）。 内置的压缩算法，能生成体积较小的安装包。 支持多语言安装界面、注册表修改、DLL注册等操作。 适用场景：适用于需要高度定制化安装包的开发者和项目，通常用于大型项目或复杂的安装需求。\n使用方法：\n下载 NSIS 并安装。 创建 .nsi 脚本文件，编写打包逻辑和安装流程。 使用 NSIS 编译器生成安装程序。 示例 .nsi 文件：\nOutFile \u0026#34;setup.exe\u0026#34; InstallDir \u0026#34;$PROGRAMFILES\\MyApp\u0026#34; Section SetOutPath $INSTDIR File \u0026#34;bin\\MyApp.exe\u0026#34; File \u0026#34;bin\\MyLibrary.dll\u0026#34; CreateShortcut \u0026#34;$DESKTOP\\MyApp.lnk\u0026#34; \u0026#34;$INSTDIR\\MyApp.exe\u0026#34; SectionEnd 3. WiX Toolset (Windows Installer XML) 简介：WiX Toolset 是一个用于创建 Windows 安装包的工具集，专注于生成 .msi 文件。它通过 XML 配置文件定义安装逻辑，是一个高度可定制的工具，常用于企业级软件安装包。\n主要特点：\n生成标准的 Windows Installer 安装包（.msi 文件）。 支持复杂的安装方案，包括服务安装、注册表修改、文件权限设置等。 可集成到 CI/CD 管道，适合大型项目的安装包自动化生成。 支持多语言安装、安装时依赖检查等功能。 适用场景：适合大型企业级项目，特别是那些需要生成 .msi 安装包的场景。由于其复杂性，它常用于高级用户和团队开发。\n使用方法：\n下载 WiX Toolset 并安装。 编写 .wxs XML 文件，定义安装包结构和逻辑。 使用 WiX 编译工具生成 .msi 安装包。 示例 .wxs 文件：\n\u0026lt;Wix xmlns=\u0026#34;http://schemas.microsoft.com/wix/2006/wi\u0026#34;\u0026gt; \u0026lt;Product Id=\u0026#34;*\u0026#34; Name=\u0026#34;MyApp\u0026#34; Version=\u0026#34;1.0.0.0\u0026#34; Manufacturer=\u0026#34;MyCompany\u0026#34; UpgradeCode=\u0026#34;PUT-GUID-HERE\u0026#34;\u0026gt; \u0026lt;Package InstallerVersion=\u0026#34;200\u0026#34; Compressed=\u0026#34;yes\u0026#34; InstallScope=\u0026#34;perMachine\u0026#34; /\u0026gt; \u0026lt;Media Id=\u0026#34;1\u0026#34; Cabinet=\u0026#34;media1.cab\u0026#34; EmbedCab=\u0026#34;yes\u0026#34; /\u0026gt; \u0026lt;Directory Id=\u0026#34;TARGETDIR\u0026#34; Name=\u0026#34;SourceDir\u0026#34;\u0026gt; \u0026lt;Directory Id=\u0026#34;ProgramFilesFolder\u0026#34;\u0026gt; \u0026lt;Directory Id=\u0026#34;INSTALLFOLDER\u0026#34; Name=\u0026#34;MyApp\u0026#34; /\u0026gt; \u0026lt;/Directory\u0026gt; \u0026lt;/Directory\u0026gt; \u0026lt;Feature Id=\u0026#34;MainFeature\u0026#34; Title=\u0026#34;MyApp\u0026#34; Level=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;ComponentGroupRef Id=\u0026#34;ProductComponents\u0026#34; /\u0026gt; \u0026lt;/Feature\u0026gt; \u0026lt;/Product\u0026gt; \u0026lt;Fragment\u0026gt; \u0026lt;DirectoryRef Id=\u0026#34;INSTALLFOLDER\u0026#34;\u0026gt; \u0026lt;Component Id=\u0026#34;MyAppExe\u0026#34; Guid=\u0026#34;PUT-GUID-HERE\u0026#34;\u0026gt; \u0026lt;File Source=\u0026#34;bin\\MyApp.exe\u0026#34; /\u0026gt; \u0026lt;/Component\u0026gt; \u0026lt;Component Id=\u0026#34;MyAppDll\u0026#34; Guid=\u0026#34;PUT-GUID-HERE\u0026#34;\u0026gt; \u0026lt;File Source=\u0026#34;bin\\MyLibrary.dll\u0026#34; /\u0026gt; \u0026lt;/Component\u0026gt; \u0026lt;/DirectoryRef\u0026gt; \u0026lt;/Fragment\u0026gt; \u0026lt;/Wix\u0026gt; 4. Advanced Installer 简介：Advanced Installer 是一个商业化的安装包创建工具，它提供了图形用户界面 (GUI)，不需要编写脚本，适合那些希望快速生成安装包的开发者。它支持生成 .msi 和 .exe 安装程序，并提供多种安装包配置选项。 主要特点： 提供易于使用的图形界面，适合不熟悉脚本编写的用户。 支持 .exe 和 .msi 两种格式的安装包。 内置丰富的安装选项，包括许可证协议、UI 定制、依赖项检查等。 提供免费版和高级版（付费），高级版支持更多功能。 适用场景：适合不希望编写脚本的开发者，适用于快速生成安装包的需求，尤其适合小型项目。 使用方法： 下载 Advanced Installer 并安装。 使用 GUI 工具定义要打包的文件和安装逻辑。 生成安装包，无需手动编写脚本。 5. InstallShield 简介：InstallShield 是一款商业化的高级安装包生成工具，广泛应用于企业级项目。它支持生成复杂的安装逻辑，并支持创建 .exe、.msi、跨平台的安装包。InstallShield 常用于需要高级安装选项和大规模分发的场景。 主要特点： 支持创建复杂的安装逻辑，并提供企业级特性（如许可证管理、数据库安装等）。 图形化的用户界面和丰富的功能集，适合大型项目的安装包生成。 支持多语言、多平台安装包的生成。 适用场景：适合需要复杂安装功能的企业项目，特别是那些需要高度自定义安装流程的场景。 使用方法：需要购买商业许可证，使用 GUI 工具创建安装程序。 总结 Inno Setup 和 NSIS 是两款非常流行的开源工具，适合绝大多数中小型项目，且支持高度自定义。 WiX Toolset 非常适合需要创建企业级 .msi 安装包的场景，但其学习曲线较陡。 Advanced Installer 和 InstallShield 则提供了图形界面，更适合那些不希望编写脚本的开发者或需要高级功能的企业项目。 根据项目的规模和复杂度选择合适的打包工具，可以显著提高打包效率并优化安装流程。\n实际使用的感受发现： Inno Setup很好用。\n因为在后面的测试中发现，由于我安装位置需要发生读写，一般而来，C盘软件的默认安装位置的文件删除、更改等操作是需要管理员权限的，其实这个挺费劲，当然可以以管理员权限重新打开程序（晕到死上很多盗版软件需要这么操作吧？）但更好的方式应该是可以手动设置一个文件夹，这个文件夹是可以支持读写的。\n当然，我觉得还有更多的功能可以探索，这个可以需要的时候再去搜索了。\n（人可能越来越像发出指令和命令的终端了，因为有人工智能为你实现检索和定位以及回答。。。。）\n下面这个是使用Inno Setup的配置文件：\n[Setup] AppName=MindCloud Renderer AppVersion=1.0 AppPublisher=Manifold Tech Limited PrivilegesRequired=admin AppPublisherURL=https://www.manifoldtech.cn/ ; AppSupportURL=https://www.manifoldtech.cn/support ; AppUpdatesURL=https://www.manifoldtech.cn/update DefaultDirName={pf}\\MindCloud Renderer DefaultGroupName=MindCloud Renderer OutputBaseFilename=MindCloud Renderer Installer Compression=lzma SolidCompression=yes VersionInfoVersion=1.0.0.0 VersionInfoCompany=Manifold Tech Limited VersionInfoDescription=MindCloud Renderer Application VersionInfoCopyright=© 2024 Manifold Tech Ltd. All rights reserved. VersionInfoProductName=MindCloud Renderer VersionInfoProductVersion=1.0.0.0 [Dirs] ; 创建 _internal\\datas 目录，并授予 Users 组修改权限 Name: \u0026#34;{app}\\_internal\\datas\u0026#34;; Permissions: users-modify [Files] ; 递归地复制 dist\\MindCloud Renderer 文件夹下的所有内容到安装目录 {app} Source: \u0026#34;C:\\Users\\Quite\\CKCode\\3DGSMT\\dist\\MindCloud Renderer\\*\u0026#34;; DestDir: \u0026#34;{app}\u0026#34;; Flags: ignoreversion recursesubdirs createallsubdirs [Icons] ; 在开始菜单中创建一个指向 MindCloud Renderer.exe 的快捷方式 Name: \u0026#34;{group}\\MindCloud Renderer\u0026#34;; Filename: \u0026#34;{app}\\MindCloud Renderer.exe\u0026#34; ; 在桌面创建一个指向 MindCloud Renderer.exe 的快捷方式 Name: \u0026#34;{commondesktop}\\MindCloud Renderer\u0026#34;; Filename: \u0026#34;{app}\\MindCloud Renderer.exe\u0026#34; [Run] ; Filename: \u0026#34;{app}\\MindCloud Renderer.exe\u0026#34;; Description: \u0026#34;Run MindCloud Renderer\u0026#34;; Flags: runasoriginaluser 图形化UI 一开始也是搜索得到的信息：\n在给 Python 项目添加图形化用户界面（GUI）时，有许多可用的工具和库。每个工具都有不同的特点、优缺点以及适用的场景。以下是常见的 Python GUI 库及其特点和差异：\n1. Tkinter 简介：Tkinter 是 Python 标准库自带的 GUI 库，因此不需要额外安装。它是构建简单 GUI 程序的不错选择，非常适合那些希望快速构建 GUI 界面的初学者。\n主要特点：\n易于学习：由于它是 Python 标准库的一部分，文档丰富且社区支持广泛，适合初学者。 跨平台：可以在 Windows、macOS 和 Linux 上运行。 轻量级：适合小型应用程序或简单的工具。 适用场景：构建简单的、基本的桌面应用程序。\n示例：\nimport tkinter as tk root = tk.Tk() root.title(\u0026#34;Simple GUI\u0026#34;) tk.Label(root, text=\u0026#34;Hello, World!\u0026#34;).pack() root.mainloop() 2. PyQt 简介：PyQt 是基于 Qt 库的 Python 绑定，提供了丰富的 GUI 组件。它是功能最全、最成熟的 Python GUI 库之一，可以构建复杂的桌面应用程序。\n主要特点：\n功能强大：支持复杂的 GUI 元素，如菜单、工具栏、状态栏、表格等，适合构建功能复杂的大型应用。 丰富的组件：Qt 本身就是一个强大的跨平台 GUI 框架，PyQt 继承了 Qt 库的所有功能。 跨平台：支持 Windows、macOS 和 Linux。 商业化：PyQt 在商业用途时需要购买许可证，虽然有免费版本，但要注意许可证问题。 适用场景：适合需要复杂 UI 和丰富组件的大型桌面应用程序。\n示例：\nimport sys from PyQt5.QtWidgets import QApplication, QLabel app = QApplication(sys.argv) label = QLabel(\u0026#39;Hello, PyQt!\u0026#39;) label.show() sys.exit(app.exec_()) 3. PySide (Qt for Python) 简介：PySide 和 PyQt 类似，都是 Qt 的 Python 绑定，区别在于 PySide 是由 Qt 官方维护的免费开源版本，并且商业用途也无需许可证。\n主要特点：\n与 PyQt 相似：与 PyQt 提供的功能几乎相同，API 也很相似。 开源：PySide 是 LGPL 许可证，因此对于商业用途更加友好。 跨平台：和 PyQt 一样，支持多平台。 适用场景：需要 Qt 的功能，但希望在商业项目中免费使用的场景。\n示例：\nimport sys from PySide2.QtWidgets import QApplication, QLabel app = QApplication(sys.argv) label = QLabel(\u0026#39;Hello, PySide!\u0026#39;) label.show() sys.exit(app.exec_()) 4. Kivy 简介：Kivy 是一个开源的 Python GUI 库，专注于跨平台开发，特别是移动应用开发。它可以用于构建具有响应式触摸界面的应用程序，支持 Windows、macOS、Linux、iOS 和 Android。\n主要特点：\n跨平台支持：支持桌面和移动平台，适合开发跨平台应用程序。 响应式界面：Kivy 允许创建可响应触摸输入的应用，适合平板和手机等触摸设备。 图形化界面定制：非常适合构建自定义界面和动画丰富的应用。 适用场景：适合移动端应用开发，或需要响应式设计的桌面应用。\n示例：\nfrom kivy.app import App from kivy.uix.label import Label class MyApp(App): def build(self): return Label(text=\u0026#39;Hello, Kivy!\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: MyApp().run() 5. wxPython 简介：wxPython 是一个封装了 wxWidgets 的 Python GUI 库。wxWidgets 是一个成熟的 C++ 库，提供了大量的原生 UI 组件，wxPython 则使 Python 程序可以调用这些组件。\n主要特点：\n原生组件：使用系统的原生控件，因此生成的界面与平台的本地应用界面一致（特别是在 Windows 和 macOS 上）。 跨平台：支持 Windows、macOS 和 Linux。 功能全面：拥有大量的控件和布局管理器，适合构建复杂的桌面应用。 适用场景：适合需要本地化外观、复杂 GUI 布局的大型应用程序。\n示例：\nimport wx app = wx.App(False) frame = wx.Frame(None, wx.ID_ANY, \u0026#34;Hello wxPython\u0026#34;) frame.Show(True) app.MainLoop() 6. Dear PyGui 简介：Dear PyGui 是一个现代的、基于 GPU 的 Python GUI 库，专注于高效、快速的渲染，特别适合需要高性能的应用，如数据可视化、游戏开发或实时控制应用。\n主要特点：\nGPU 加速：使用 GPU 渲染界面，因此性能非常好，适合需要大量绘图或动画的应用。 现代设计：提供了现代化的 UI 组件，如数据表格、绘图、图表等。 跨平台：支持 Windows、macOS 和 Linux。 适用场景：适合开发需要高性能渲染的应用程序，如图形可视化、数据展示和游戏开发。\n示例：\nimport dearpygui.dearpygui as dpg dpg.create_context() with dpg.window(label=\u0026#34;Example Window\u0026#34;): dpg.add_text(\u0026#34;Hello, Dear PyGui\u0026#34;) dpg.create_viewport(title=\u0026#39;Custom Title\u0026#39;, width=600, height=400) dpg.setup_dearpygui() dpg.show_viewport() dpg.start_dearpygui() dpg.destroy_context() 7. Flask + Electron (或 Flask + Pywebview) 简介：Flask 本身是一个 Python Web 框架，但是你可以结合 Electron 或 Pywebview 来开发桌面应用。Electron 可以将 Web 应用打包成桌面应用，Pywebview 则提供了一个更轻量的方案。\n主要特点：\n跨平台：可以通过 Electron 或 Pywebview 构建跨平台的桌面应用。 基于 Web 技术：使用 HTML、CSS 和 JavaScript 构建前端界面，后端逻辑由 Flask 提供。 灵活性高：前端开发者可以使用现有的 Web 技术栈，非常适合对 Web 开发熟悉的团队。 适用场景：适合需要使用 Web 技术栈构建桌面应用的项目，特别是希望利用现有的 Web 开发资源的场景。\n示例：\n# Flask 后端 from flask import Flask app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def index(): return \u0026#39;Hello, Flask + Electron!\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: app.run() 总结 Tkinter：入门简单，适合构建轻量级应用。 PyQt / PySide：功能强大，适合复杂桌面应用，PySide 适合商业用途。 Kivy：专注于跨平台和触摸界面，适合移动和桌面双端应用。 wxPython：提供原生外观控件，适合需要本地化 UI 的项目。 Dear PyGui：适合高性能的图形和数据可视化应用。 Flask + Electron/Pywebview：结合 Web 技术构建跨平台桌面应用。 根据项目的需求和你的技术栈，选择合适的工具可以帮助你更快地完成 GUI 的开发。\n但我记得，一开始偷懒，写的很low，使用的是tk，就是一个对话窗口，没有设计风格，土土的Windows98的感觉。\n然后呢，又发现python脚本启动慢，后面发现是和import有关系，import可以后置，然后灵机一动，还搞出来一个程序启动的logo，甚至还加了logo等待，等待import那么大的库完成之后，比如torch之类，再把logo去掉，用户体验上感觉是好多了。\n后来，觉得tk太土，尝试使用qt，qt确实好用，可以使用类似css的方式来美化界面，所以就可能搞出很多花里胡哨的设计了，比如什么:\n动态进度条； 悬置和按压都有效果的按钮； 黄金比例； 各种圆角； 以及好看不违和的表格； 扣细节能扣到头皮发麻的那种，并且最重要还不是UI的显示好看与否，而是qt的槽信号机制太好用了，可以实现很多想要的功能，比如：\n点击一次开始后，就不能点击第二次，除非等到一次运行完成；\n打开主界面，要能持续运行，点击一次开始，运行完，保存显示，再点击一次，又能重复；\n点击了恢复任务，就不能再点击其他恢复任务，更不能点击开始任务，反之也是一样；\n……\n可能这些点在app开发的老手来看都是家常便饭，不对确实对于比较系统地从设计到开发的初次尝试者，确实印象很深刻。\nNode和npm到底是个什么东西？ 在打通这个软件的最后一步，是实现点击查看，之前通过web端实现了demo，主要基于three.js的开源方案，在开发阶段这个demo的运行依赖node和npm，当时我是对这两个东西作为工具使用，但直接告诉我，已经用浏览器打开了呀，把html，css，js三个文件放在一起不就行了？如果不行，遇到问题解决问题就是咯！\n现在查询和搜索了一些关于node和npm的信息：\n什么是 Node.js 和 npm？ Node.js：\nNode.js 是一个基于 Chrome V8 JavaScript 引擎 构建的 JavaScript 运行时环境。它允许你在 服务器端 使用 JavaScript 编写代码，而不仅仅局限于在浏览器中运行 JavaScript。 特点： 它使得 JavaScript 可以用于编写服务器端的应用程序，如后端 API、Web 服务器等。 Node.js 是 单线程 的，但通过 事件驱动 和 异步非阻塞 I/O 模型，非常适合高并发的应用场景。 npm (Node Package Manager)：\nnpm 是 Node.js 的包管理器，用于下载、安装、管理 JavaScript 项目的依赖包。类似于 Python 的 pip 或 Java 的 Maven。 特点： 你可以使用 npm install 来安装第三方库和依赖包。 npm 也允许你运行项目中的脚本命令（如 npm run）。 npm run 以及与 Node.js 的关系 当你运行 npm run start 或类似的命令时，实际上是 npm 运行了一个 脚本，这个脚本通常会启动一个 开发服务器，比如使用 Webpack、Parcel、Vite 或 Next.js 等工具来打包、编译项目，并实时更新页面。\nnpm 和 Node.js 的作用主要在于 开发阶段，它们提供了一些工具帮助你快速构建和启动项目，但在实际生产环境中，构建好的项目（即 HTML、CSS、JavaScript 文件）可以独立运行，不再依赖 Node.js 和 npm。\n开发阶段使用 npm run 的原因：\n打包/编译：工具如 Webpack 或 Vite 会将项目中的 模块化代码 打包为浏览器可以直接执行的代码。 开发服务器：启动一个本地服务器，提供热更新（hot-reload）功能，每次你修改文件时，页面自动刷新。 处理静态资源：如图片、CSS、字体等，这些工具会自动优化和处理静态资源。 示例：\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;webpack serve --config webpack.config.js\u0026#34; } } 当你运行 npm run start 时，实际上是执行了 webpack serve，它启动了 Webpack 的开发服务器，用于开发阶段快速查看效果。\n理论上讲，不依赖 Node.js 和 npm 可以运行 Web 应用？ 是的，理论上讲，Web 应用并不依赖 Node.js 和 npm。因为最终的 Web 应用是基于浏览器的，浏览器只需要 HTML、CSS 和 JavaScript 文件。这意味着，生产环境中已经打包好的代码可以直接部署到任意 Web 服务器上，浏览器可以直接解析和运行这些文件。\n为什么在生产环境不需要 Node.js 和 npm？\nHTML、CSS 和 JavaScript 是静态文件，这些文件可以在任何 Web 服务器上运行，如 Apache、Nginx，甚至本地文件系统。 Node.js 和 npm 只是开发工具，它们帮助开发者在开发阶段进行模块打包、编译、代码分割、性能优化等工作。一旦这些工作完成，生成的文件可以独立运行。 实际使用场景对比 开发阶段（依赖 Node.js 和 npm）：\n使用 Node.js 和 npm 来管理依赖、启动开发服务器。 使用现代前端工具（如 Webpack、Vite、Babel 等）来处理模块化、编译和打包。 提供热更新（Hot Reloading）、ES6+ 编译、代码压缩等功能。 生产阶段（不依赖 Node.js 和 npm）：\n构建后的文件通常会生成一个静态文件夹（如 dist/ 或 build/），其中包含了 HTML、CSS 和编译后的 JavaScript 文件。 部署时，只需将这些静态文件上传到 Web 服务器（如 Apache、Nginx）或内容分发网络（CDN）中，浏览器即可直接加载并运行。 总结 Node.js 是用于在服务器端运行 JavaScript 的环境，适合开发服务器端应用，也在前端开发中用于构建工具。 npm 是 Node.js 的包管理器，用于管理项目中的依赖库，并运行构建脚本。 npm run 常用于启动开发服务器或执行构建任务。 Web 应用在生产环境中不需要依赖 Node.js 和 npm，只需要最终的 HTML、CSS 和 JavaScript 静态文件即可。 虽然 Node.js 和 npm 在开发阶段提供了许多便利，但在最终的生产环境中，前端项目通常只依赖静态资源，并不需要 Node.js 运行。因此，理论上来说，HTML + CSS + JavaScript 是不依赖于 Node.js 和 npm 的，除非你在使用某些需要服务器端支持的动态功能（如 SSR 或 API）。\n后来其实也是用了python来实现，启动了一个python的web服务，然后也遇到了CORS的问题，查阅收集的信息如下：\n如果不用 npm 来启动开发服务器，完全可以使用 Python 提供的轻量级服务器来启动 HTML 文件。Python 自带的 HTTP 服务器可以通过简单的命令快速启动，直接服务静态文件，例如 HTML、CSS 和 JavaScript。\n使用 Python 启动 HTML 应用 在 Python 3 中，你可以使用以下命令来启动一个简单的 HTTP 服务器，来服务你当前目录中的文件：\n## Python 3.x python -m http.server 8000 这个命令将在当前目录启动一个服务器，并在 http://localhost:8000/ 提供访问。通过这个简单的 HTTP 服务器，浏览器可以访问你的 HTML 文件。\n然而，使用这种方法在开发过程中，可能会遇到一个常见的问题——CORS (跨域资源共享) 问题。\n什么是 CORS (Cross-Origin Resource Sharing)? CORS 是浏览器的一种安全机制，防止一个网页在浏览器上从另一个域名、协议或端口请求资源。也就是说，如果网页的资源（例如：JavaScript、CSS、图片）来自与页面不同的域名，浏览器就会根据 CORS 策略限制跨域请求。这种限制防止了潜在的安全风险，比如跨站脚本攻击（XSS）。\nCORS 问题的触发条件： CORS 问题通常在以下场景下会触发：\n跨域请求：例如，你的网页在 localhost:8000 上运行，而你请求的 API 在 http://api.example.com，这是两个不同的源，因此浏览器会限制该请求。 AJAX 请求：当使用 JavaScript 发起 XMLHttpRequest 或 fetch 请求时，目标服务器需要允许跨域请求，否则浏览器会阻止请求并报错。 常见的 CORS 错误信息： 当出现 CORS 问题时，你会在浏览器控制台中看到类似以下错误：\nAccess to fetch at \u0026#39;http://api.example.com/data\u0026#39; from origin \u0026#39;http://localhost:8000\u0026#39; has been blocked by CORS policy: No \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. 如何解决 CORS 问题？ CORS 的解决方案通常分为两种：服务端配置 和 前端解决方案。解决 CORS 问题的关键在于服务器如何响应请求，并设置适当的 HTTP 头信息来允许跨域。\n1. 服务端解决方案（推荐方式） CORS 问题的最佳解决方式是 在服务器端配置正确的 CORS 头信息。服务器需要在响应头中添加 Access-Control-Allow-Origin，明确允许哪些域可以访问该资源。\n添加 CORS 头信息： 服务器需要在响应头中返回以下内容：\nAccess-Control-Allow-Origin: * 这里的 * 表示允许所有来源的跨域请求。也可以将 * 替换为指定的域名，例如：\nAccess-Control-Allow-Origin: http://localhost:8000 其他常见的 CORS 头信息：\nAccess-Control-Allow-Methods：指定允许的 HTTP 请求方法（如 GET、POST）。 Access-Control-Allow-Headers：指定允许的自定义请求头。 Access-Control-Allow-Credentials：是否允许客户端发送 cookies。 示例：假设你使用的是一个 Flask API，可以使用以下代码来启用 CORS：\nfrom flask import Flask from flask_cors import CORS app = Flask(__name__) CORS(app) @app.route(\u0026#39;/\u0026#39;) def home(): return \u0026#39;Hello, CORS is enabled!\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: app.run() 通过 CORS(app)，你启用了 CORS 支持，使得不同来源的请求可以访问该服务器。\n2. 使用前端代理解决 CORS 如果你无法控制服务端配置，也可以通过 前端代理 的方式来绕过 CORS 问题。前端代理在本地运行一个服务器，将所有请求代理到目标服务器，以此来规避 CORS 限制。\n使用 Webpack 的 Dev Server 代理： 在开发过程中，你可以使用 Webpack 的开发服务器来代理 API 请求。例如，在 webpack.config.js 中添加以下配置：\ndevServer: { proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://api.example.com\u0026#39;, changeOrigin: true, pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; }, } } } 通过这种代理方式，前端发出的请求先由 Webpack 的本地服务器处理，再转发到目标 API，从而避免 CORS 限制。\n3. 在浏览器中禁用 CORS（开发环境中，不推荐用于生产） 在开发环境中，你可以通过一些浏览器扩展或命令行参数来 禁用 CORS，这样浏览器就不会阻止跨域请求。不过这种方法仅限于调试，不建议在生产环境中使用，因为它会增加安全风险。\nChrome 中禁用 CORS： 你可以通过启动 Chrome 时添加以下参数来禁用 CORS：\nchrome.exe --disable-web-security --user-data-dir=\u0026#34;C:/ChromeDev\u0026#34; 这种方式适合本地开发调试，但切记 不要在生产环境使用。\n总结 Node.js 和 npm 提供了开发阶段的便利，但实际上，使用 Python 的 HTTP 服务器等简单工具也能启动和查看 Web 应用。 CORS（跨域资源共享） 是浏览器的一种安全策略，主要用于防止网页跨域请求资源时的安全问题。 解决 CORS 问题的最佳方法是在服务器端设置合适的 CORS 头信息，允许客户端跨域访问资源。 如果无法修改服务端配置，前端代理也是一个有效的替代方案。 通过理解和正确处理 CORS 问题，你可以在开发和生产环境中避免不必要的跨域错误，从而更高效地开发和部署 Web 应用。\n代码记录 使用PyQT import os import re import json import hashlib from datetime import datetime from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QHeaderView, QSpacerItem, QSizePolicy, QLabel, QTableWidget, QTableWidgetItem, QDialog, QProgressBar, QFileDialog, QLineEdit, QComboBox) from PyQt5.QtCore import Qt, QTimer, QPoint, QThread from PyQt5.QtGui import QPixmap, QPainter, QColor, QFontDatabase, QIcon, QBrush from utils.path_utils import resource_path, get_local_data_directory from utils.viewer_utils import start_http_server class ServerThread(QThread): def __init__(self, file_path): super().__init__() self.file_path = file_path def run(self): \u0026#34;\u0026#34;\u0026#34;在后台运行 HTTP 服务器\u0026#34;\u0026#34;\u0026#34; start_http_server(self.file_path) class InputDialog(QDialog): def __init__(self, parent=None): super().__init__(parent) self.setWindowFlags(Qt.FramelessWindowHint | Qt.Dialog) # 无边框窗口，模态对话框 self.setWindowModality(Qt.ApplicationModal) # 设置为应用程序模态，阻止与其他窗口交互 self.setAttribute(Qt.WA_TranslucentBackground) # 确保背景透明 self.setFixedSize(680, 420) # 设置窗口大小 layout = QVBoxLayout(self) common_style = \u0026#34;\u0026#34;\u0026#34; background-color: #2a2a2a; color: white; font-size: 26px; border-radius: 10px; padding-left: 10px; \u0026#34;\u0026#34;\u0026#34; combo_box_style = \u0026#34;\u0026#34;\u0026#34; QComboBox {{ {common_style} }} QComboBox::drop-down {{ width: 0px; border: none; }} QComboBox::down-arrow {{ width: 0px; }} QComboBox QAbstractItemView {{ background-color: #2a2a2a; color: white; selection-background-color: rgb(87, 204, 153); selection-color: white; }} \u0026#34;\u0026#34;\u0026#34;.format(common_style=common_style) line_edit_style = \u0026#34;\u0026#34;\u0026#34; QLineEdit {{ {common_style} }} \u0026#34;\u0026#34;\u0026#34;.format(common_style=common_style) common_font_style = \u0026#34;\u0026#34;\u0026#34; font-size: 26px; font-weight: bold; color: white; \u0026#34;\u0026#34;\u0026#34; common_grenn_button_style = \u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: rgb(54, 176, 123); border-radius: 10px; color: white; font-size: 26px; } QPushButton:hover { background-color: rgb(87, 204, 153); } QPushButton:pressed { background-color: rgb(42, 137, 96); } \u0026#34;\u0026#34;\u0026#34; common_red_button_style = \u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: rgb(240, 113, 103); border-radius: 10px; color: white; font-size: 26px; } QPushButton:hover { background-color: rgb(244, 146, 139); } QPushButton:pressed { background-color: rgb(238, 80, 68); } \u0026#34;\u0026#34;\u0026#34; # 创建名称输入框 name_label = QLabel(\u0026#34;Data Name\u0026#34;) name_label.setStyleSheet(common_font_style) self.model_name_input = QLineEdit(\u0026#34;Untitled\u0026#34;) # 默认名称 self.model_name_input.setFixedHeight(50) # 设置输入框高度为50px self.model_name_input.setPlaceholderText(\u0026#34;Please enter the data name\u0026#34;) self.model_name_input.setStyleSheet(line_edit_style) name_layout = QHBoxLayout() name_layout.addWidget(name_label) name_layout.addWidget(self.model_name_input) # 文件选择按钮 file_label = QLabel(\u0026#34;Select File\u0026#34;) file_label.setStyleSheet(common_font_style) self.file_path_input = QLineEdit() # 展示路径 self.file_path_input.setFixedHeight(50) self.file_path_input.setReadOnly(True) self.file_path_input.setStyleSheet(line_edit_style) file_select_button = QPushButton(\u0026#34;Browse\u0026#34;) file_select_button.setFixedSize(131, 50) # 设置按钮的固定大小 file_select_button.setStyleSheet(common_grenn_button_style) file_select_button.clicked.connect(self.open_file_dialog) # 绑定点击事件 file_layout = QHBoxLayout() file_layout.addWidget(file_label) file_layout.addWidget(self.file_path_input) file_layout.addWidget(file_select_button) # 渲染迭代次数下拉列表 iteration_label = QLabel(\u0026#34;Iterations\u0026#34;) iteration_label.setStyleSheet(common_font_style) self.iteration_combo = QComboBox() self.iteration_combo.setFixedHeight(50) # 设置下拉框高度为50px self.iteration_combo.addItems([\u0026#34;3000\u0026#34;, \u0026#34;7000\u0026#34;, \u0026#34;15000\u0026#34;, \u0026#34;1000\u0026#34;, \u0026#34;50\u0026#34;]) self.iteration_combo.setStyleSheet(combo_box_style) iteration_layout = QHBoxLayout() iteration_layout.addWidget(iteration_label) iteration_layout.addWidget(self.iteration_combo) # 点云密度下拉列表 density_label = QLabel(\u0026#34;Resolution\u0026#34;) density_label.setStyleSheet(common_font_style) self.density_combo = QComboBox() self.density_combo.setFixedHeight(50) # 设置下拉框高度为50px self.density_combo.addItems([\u0026#34;0.02\u0026#34;, \u0026#34;0.01\u0026#34;]) self.density_combo.setStyleSheet(combo_box_style) density_layout = QHBoxLayout() density_layout.addWidget(density_label) density_layout.addWidget(self.density_combo) # 确定和取消按钮 buttons_layout = QHBoxLayout() self.confirm_button = QPushButton(\u0026#34;Confirm\u0026#34;) self.confirm_button.setFixedSize(131, 50) # 设置按钮的固定大小 self.confirm_button.setStyleSheet(common_grenn_button_style) self.confirm_button.setEnabled(False) # 初始禁用按钮 cancel_button = QPushButton(\u0026#34;Cancel\u0026#34;) cancel_button.setFixedSize(131, 50) # 设置按钮的固定大小 cancel_button.setStyleSheet(common_red_button_style) self.confirm_button.clicked.connect(self.accept) # 接受输入 cancel_button.clicked.connect(self.reject) # 取消输入 buttons_layout.addWidget(self.confirm_button) buttons_layout.addWidget(cancel_button) # 添加到布局 layout.addLayout(name_layout) layout.addLayout(file_layout) layout.addLayout(iteration_layout) layout.addLayout(density_layout) layout.addLayout(buttons_layout) layout.setContentsMargins(30, 10, 30, 10) # 左上右下 # 监听路径变化以控制 Confirm 按钮的状态 self.file_path_input.textChanged.connect(self.check_confirm_button) def open_file_dialog(self): \u0026#34;\u0026#34;\u0026#34;打开文件选择对话框，选择 lx 文件\u0026#34;\u0026#34;\u0026#34; file_path, _ = QFileDialog.getOpenFileName(self, \u0026#34;Select File\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;lx Files (*.lx)\u0026#34;) if file_path: # 将路径转换为正斜杠 file_path = file_path.replace(\u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;) self.file_path_input.setText(file_path) def check_confirm_button(self): \u0026#34;\u0026#34;\u0026#34;检查是否选择了文件路径，以控制确认按钮的启用状态\u0026#34;\u0026#34;\u0026#34; if self.file_path_input.text(): self.confirm_button.setEnabled(True) else: self.confirm_button.setEnabled(False) def get_inputs(self): \u0026#34;\u0026#34;\u0026#34;获取用户输入的所有值\u0026#34;\u0026#34;\u0026#34; # 定义Windows不允许的字符 invalid_chars = r\u0026#39;[\u0026lt;\u0026gt;:\u0026#34;/\\\\|?*]\u0026#39; # 替换模型名称中的非法字符为下划线 model_name = re.sub(invalid_chars, \u0026#39;_\u0026#39;, self.model_name_input.text()) return { \u0026#34;model_name\u0026#34;: model_name, \u0026#34;file_path\u0026#34;: self.file_path_input.text(), \u0026#34;iterations\u0026#34;: self.iteration_combo.currentText(), \u0026#34;density\u0026#34;: self.density_combo.currentText() } def paintEvent(self, event): \u0026#34;\u0026#34;\u0026#34;自定义绘制背景以实现倒角\u0026#34;\u0026#34;\u0026#34; painter = QPainter(self) painter.setRenderHint(QPainter.Antialiasing) rect = self.rect() painter.setBrush(QColor(30, 30, 30)) # 背景颜色 painter.setPen(Qt.NoPen) painter.drawRoundedRect(rect, 10, 10) # 10px 倒角 class ConfirmDialog(QDialog): def __init__(self, message=\u0026#34;Proceed with this action?\u0026#34;, parent=None): super().__init__(parent) self.setWindowFlags(Qt.FramelessWindowHint | Qt.Dialog) # 去除边框，设置为对话框模式 self.setAttribute(Qt.WA_TranslucentBackground) # 透明背景 # 设置布局 layout = QVBoxLayout(self) # 设置窗口大小 self.setFixedSize(356, 220) # 创建提示标签 label = QLabel(message) label.setStyleSheet(\u0026#34;font-weight:bold; font-size: 28px;\u0026#34;) layout.addWidget(label, alignment=Qt.AlignCenter) # 创建按钮 button_layout = QHBoxLayout() yes_button = QPushButton(\u0026#34;Yes\u0026#34;) yes_button.setFixedSize(131, 50) # 设置固定的宽度和高度 yes_button.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: rgb(240, 113, 103); border-radius: 10px; } QPushButton:hover { background-color: rgb(244, 146, 139); } QPushButton:pressed { background-color: rgb(238, 80, 68); } \u0026#34;\u0026#34;\u0026#34;) yes_button.clicked.connect(self.accept) # 绑定确认事件 no_button = QPushButton(\u0026#34;No\u0026#34;) no_button.setFixedSize(131, 50) no_button.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: rgb(54, 176, 123); border-radius: 10px; } QPushButton:hover { background-color: rgb(87, 204, 153); } QPushButton:pressed { background-color: rgb(42, 137, 96); } \u0026#34;\u0026#34;\u0026#34;) no_button.clicked.connect(self.reject) # 绑定取消事件 button_layout.addWidget(yes_button) button_layout.addWidget(no_button) layout.addLayout(button_layout) layout.setContentsMargins(20, 20, 20, 40) # 调整底部间距为40 def show_confirmation(self): \u0026#34;\u0026#34;\u0026#34;显示对话框并返回用户选择\u0026#34;\u0026#34;\u0026#34; return self.exec_() # 0: reject, 1: accept def paintEvent(self, event): # 使用 QPainter 绘制整个窗口的背景 painter = QPainter(self) painter.setRenderHint(QPainter.Antialiasing) # 抗锯齿 painter.setBrush(QColor(30, 30, 30)) # 墨黑色背景 painter.setPen(Qt.NoPen) # 无边框 painter.drawRoundedRect(self.rect(), 10, 10) # 设置圆角半径为 10 # 自定义无边框窗口类 class MainWindow(QWidget): def __init__(self, comm): super().__init__() self.comm = comm # 传入 Communicator 实例 self.is_training = False # 训练状态标志 self.restore_disabled_row = -1 # 用于记录禁用恢复按钮的行号 ### 主窗口 ### # 实现鼠标拖动 self._is_dragging = False self._drag_start_position = QPoint() # 设置窗口始终置顶 # self.setWindowFlag(Qt.WindowStaysOnTopHint) self.setWindowTitle(\u0026#34;MindCloud Renderer\u0026#34;) # 设置窗口标题 self.setWindowIcon(QIcon(resource_path(\u0026#34;assets/logo.ico\u0026#34;))) self.setWindowFlag(Qt.FramelessWindowHint) # 去除窗口边框 self.setAttribute(Qt.WA_TranslucentBackground) # 设置透明背景以实现无边框设计 # 设置主窗口大小，黄金比例 self.resize(1618, 1000) self.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QWidget { font-family: \u0026#39;LXGW WenKai GB Screen\u0026#39;, iconfont; /* 同时设置文本和图标字体 */ font-size: 26px; /* 设置全局默认字体大小 */ color: rgb(250, 250, 240); /* 暖白色 设置全局字体颜色 */ } \u0026#34;\u0026#34;\u0026#34;) # 加载字体 font_id_icon = QFontDatabase.addApplicationFont(resource_path(\u0026#34;assets/iconfont.ttf\u0026#34;)) # 动态加载字体 font_family_icon = QFontDatabase.applicationFontFamilies(font_id_icon)[0] # 获取字体的名称 font_id_text = QFontDatabase.addApplicationFont(resource_path(\u0026#34;assets/textfont.ttf\u0026#34;)) font_family_text = QFontDatabase.applicationFontFamilies(font_id_text)[0] # 设置整体布局 main_layout = QVBoxLayout(self) ### 标题栏区域 ### title_bar = QHBoxLayout() title_bar.setContentsMargins(0, 0, 0, 5) # 左上右下 # 创建应用程序名称 app_name_label = QLabel(\u0026#34;MindCloud Renderer v1.0\u0026#34;) # 应用程序的名称 app_name_label.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QLabel { color: white; font-size: 24px; font-weight: bold; } \u0026#34;\u0026#34;\u0026#34;) # 将应用程序名称添加到标题栏的左侧 title_bar.addWidget(app_name_label) # 创建最小化、最大化和关闭按钮 min_button = QPushButton(\u0026#34;\\uE1A6\u0026#34;) # \u0026amp;#xe1a6 -\u0026gt; \\uE1A6 16进制 Unicode max_button = QPushButton(\u0026#34;\\uE1A4\u0026#34;) close_button = QPushButton(\u0026#34;\\uE1A5\u0026#34;) # 设置按钮大小和样式 for button in [min_button, max_button, close_button]: button.setFixedSize(48, 48) button.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: transparent; /* 透明背景 */ color: white; border: none; } QPushButton:hover { background-color: #3a3a3a; } QPushButton:pressed { background-color: #333333; } \u0026#34;\u0026#34;\u0026#34;) title_bar.addSpacerItem(QSpacerItem(0, 0, QSizePolicy.Expanding, QSizePolicy.Minimum)) # 置于窗口最右侧 title_bar.addWidget(min_button) title_bar.addWidget(max_button) title_bar.addWidget(close_button) # 按钮点击事件绑定 min_button.clicked.connect(self.showMinimized) max_button.clicked.connect(self.toggle_max_restore) close_button.clicked.connect(self.confirm_close) # 追踪最大化状态 self.is_maximized = False # 添加标题栏到主布局 main_layout.addLayout(title_bar) ### 左侧按钮区域 ### left_panel = QVBoxLayout() left_panel.setContentsMargins(0, 0, 0, 0) # 去除内边距 # 添加 logo 的 QLabel logo_label = QLabel() logo_pixmap = QPixmap(resource_path(\u0026#34;assets/lx_logo.png\u0026#34;)) logo_pixmap = logo_pixmap.scaled(160, 160, Qt.KeepAspectRatio, Qt.SmoothTransformation) # 调整 logo 的大小 logo_label.setPixmap(logo_pixmap) # 将 logo QLabel 添加到左侧面板 left_panel.addWidget(logo_label, alignment=Qt.AlignTop | Qt.AlignHCenter) # 顶部对齐、水平居中对齐 # 添加一个可扩展空白项，保持按钮和logo之间的弹性空间 left_panel.addSpacerItem(QSpacerItem(0, 0, QSizePolicy.Minimum, QSizePolicy.Expanding)) # 上下扩展 # 创建按钮 self.new_task_button = QPushButton() self.new_task_button.setFixedSize(194, 120) # 设置按钮尺寸，宽 高，黄金比例 # 创建图标和文本标签 icon_label = QLabel(\u0026#34;\\uE1A3\u0026#34;) icon_label.setStyleSheet(\u0026#34;font-size: 48px; color: white; padding-top: 10px\u0026#34;) # 设置图标颜色 text_label = QLabel(\u0026#34;Create\u0026#34;) # 按钮下方的文字 text_label.setStyleSheet(\u0026#34;font-size: 28px; font-weight: bold; color: white; padding-bottom: 10px\u0026#34;) # 设置文字大小和颜色 # 创建垂直布局，将图标和文字添加到布局 button_layout = QVBoxLayout() button_layout.setContentsMargins(0, 0, 0, 0) # 去除内边距 # 设置图标和文字水平居中 button_layout.addWidget(icon_label, alignment=Qt.AlignHCenter) button_layout.addWidget(text_label, alignment=Qt.AlignHCenter) # 将布局设置为按钮的布局 self.new_task_button.setLayout(button_layout) # 设置按钮的样式 self.new_task_button.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: #2a2a2a; border-radius: 10px; } QPushButton:hover { background-color: #3a3a3a; } QPushButton:pressed { background-color: #333333; } \u0026#34;\u0026#34;\u0026#34;) # 按钮点击时，发射信号，并附带参数 self.new_task_button.clicked.connect(self.show_input_dialog) # 添加按钮到左侧面板并设置水平居中 left_panel.addWidget(self.new_task_button) ### 中间显示区域（右侧） ### progress_height = 50 button_width = 131 ### 进度条 ### self.progress_bar = QProgressBar(self) self.progress_bar.setMaximum(10000) # 扩大100倍，以便显示小数点后两位 self.progress_bar.setValue(0) # 初始值为0 self.progress_bar.setTextVisible(False) # 默认不显示文字（包含按钮文字） self.progress_bar.setVisible(False) # 默认不显示 self.progress_bar.setAlignment(Qt.AlignCenter) # 居中显示文字 self.progress_value = 0 # 浮点数值 self.progress_bar.setFixedHeight(progress_height) # 设置固定高度 # 自定义进度条样式 self.progress_bar.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QProgressBar { border-radius: 10px; text-align: center; color: white; background-color: #2a2a2a; } QProgressBar::chunk { border-radius: 5px; /* 圆角比较小，适应进度为1%的情况 */ background: qlineargradient( spread: pad, x1: 0, y1: 0, x2: 1, y2: 0, stop: 0 rgb(54, 176, 123), /* 渐变起点颜色 */ stop: 1 rgb(87, 204, 153) /* 渐变终点颜色 */ ); } \u0026#34;\u0026#34;\u0026#34;) # 创建取消按钮 self.cancel_button = QPushButton(\u0026#34;Cancel\u0026#34;, self) self.cancel_button.setFixedSize(button_width, progress_height) # 设置按钮大小 self.cancel_button.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: rgb(240, 113, 103); color: white; border-radius: 10px; } QPushButton:hover { background-color: rgb(244, 146, 139); } QPushButton:pressed { background-color: rgb(238, 80, 68); } \u0026#34;\u0026#34;\u0026#34;) self.cancel_button.clicked.connect(self.confirm_cancel_training) self.cancel_button.setVisible(False) # 默认隐藏按钮 # 创建确认按钮 self.confirm_button = QPushButton(\u0026#34;Confirm\u0026#34;, self) self.confirm_button.setFixedSize(button_width, progress_height) self.confirm_button.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: rgb(54, 176, 123); color: white; border-radius: 10px; } QPushButton:hover { background-color: rgb(87, 204, 153); } QPushButton:pressed { background-color: rgb(42, 137, 96); } \u0026#34;\u0026#34;\u0026#34;) self.confirm_button.clicked.connect(self.confirm_complete) self.confirm_button.setVisible(False) # 创建水平布局（包括进度条和取消按钮） progress_layout = QHBoxLayout() progress_layout.addWidget(self.progress_bar) progress_layout.addWidget(self.cancel_button) progress_layout.addWidget(self.confirm_button) progress_layout.setContentsMargins(0, 0, 0, 0) # 移除进度条所在布局的内边距 # 将水平布局包装到一个 QWidget 中 progress_widget = QWidget() progress_widget.setLayout(progress_layout) # 省略号效果 # 增加一个空格 self.ellipsis_states = [\u0026#34; ⠂⠄⠄\u0026#34;, \u0026#34; ⠄⠂⠄\u0026#34;, \u0026#34; ⠄⠄⠂\u0026#34;, \u0026#34; ⠄⠄⠄\u0026#34;] # Unicode 省略号效果 self.current_ellipsis_index = 0 # 创建一个 QTimer 定时器，每333ms更新一次省略号效果（程序开始时就启动） self.ellipsis_timer = QTimer(self) self.ellipsis_timer.timeout.connect(self.update_ellipsis) self.ellipsis_timer.start(333) # 333ms # 信号连接 comm.start_signal.connect(self.start_progress_bar) comm.progress_signal.connect(self.update_progress_bar) comm.training_complete.connect(self.training_complete) self.on_saving = False comm.saving_signal.connect(self.on_saving_trigger) ### 历史记录表格 ### # 创建表头和内容区域 self.header_table = QTableWidget(0, 5) # 只作为表头 self.content_table = QTableWidget(0, 5) # 放内容的表格 self.header_labels = [\u0026#34;\u0026#34;, \u0026#34;Data Name\u0026#34;, \u0026#34;Creation Time\u0026#34;, \u0026#34;Status\u0026#34;, \u0026#34;Actions\u0026#34;] self.header_table.setHorizontalHeaderLabels(self.header_labels) # 设置表格整体样式，包括表头和行号 self.header_table.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QTableWidget { background-color: #2a2a2a; /* 较亮的灰色背景 */ gridline-color: transparent; /* 隐藏表格的线条 */ border: none; /* 隐藏表格的边框 */ border-top-left-radius: 10px; /* 手柄底部左角圆角 */ border-top-right-radius: 10px; /* 手柄底部右角圆角 */ } QHeaderView { background-color: transparent; /* 设置表头背景透明 */ font-size: 28px; font-weight: bold; } QHeaderView::section { background-color: #3a3a3a; /* 设置表头和行号的背景颜色 */ border: none; padding: 15px; } /* 设置表头的左上角圆角 */ QHeaderView::section:first { border-top-left-radius: 10px; /* 设置左上角圆角 */ } /* 设置表头的右上角圆角 */ QHeaderView::section:last { border-top-right-radius: 10px; } QHeaderView::up-arrow, QHeaderView::down-arrow { image: none; } \u0026#34;\u0026#34;\u0026#34;) # 设置内容区域的样式 self.content_table.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QTableWidget { background-color: #2a2a2a; /* 较亮的灰色背景 */ gridline-color: transparent; /* 隐藏表格的线条 */ border: none; /* 隐藏表格的边框 */ border-bottom-left-radius: 10px; /* 手柄底部左角圆角 */ border-bottom-right-radius: 10px; /* 手柄底部右角圆角 */ } QTableWidget::item { border: none; /* 隐藏单元格的边框 */ } QScrollBar:vertical { background-color: transparent; /* 滚动条背景 */ width: 15px; /* 滚动条宽度 */ border-radius: 5px; /* 滚动条圆角 */ margin-top: 1px; /* 顶部留空 1px */ margin-bottom: 1px; /* 底部留空 1px */ } /* 滚动条手柄，默认状态 */ QScrollBar::handle:vertical { background-color: #3a3a3a; /* 手柄默认颜色 */ border-radius: 5px; /* 手柄的圆角 */ min-height: 20px; /* 手柄最小高度，防止变得太小 */ } /* 鼠标悬停时手柄的颜色 */ QScrollBar::handle:vertical:hover { background-color: #4a4a4a; } /* 鼠标点击拖动手柄时的颜色 */ QScrollBar::handle:vertical:pressed { background-color: #333333; } /* 滚动条两端的按钮（上箭头和下箭头），隐藏它们 */ QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { background: none; width: 0px; height: 0px; } /* 滚动条的上、下部分留白区域 */ QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical { background: none; width: 0px; height: 0px; } \u0026#34;\u0026#34;\u0026#34;) # 调整表头的高度 self.header_table.setFixedHeight(80) # 表头的高度固定为80px self.header_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) # 隐藏表头的第一列 self.header_table.setColumnHidden(0, True) # 设置表内容 self.content_table.horizontalHeader().setStyleSheet(\u0026#34;color: white;\u0026#34;) self.content_table.verticalHeader().setStyleSheet(\u0026#34;color: white;\u0026#34;) # 设置每行的默认高度 self.content_table.verticalHeader().setDefaultSectionSize(80) # 禁用内容表格的表头 self.content_table.horizontalHeader().setVisible(False) # 隐藏列序号 self.content_table.verticalHeader().setVisible(False) # 设置表格的列宽自适应 self.content_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) # 表头内容和内容表格列宽同步，保持水平滚动条同步 self.content_table.horizontalScrollBar().valueChanged.connect(self.header_table.horizontalScrollBar().setValue) # 设置表头可以点击排序 self.content_table.setSortingEnabled(True) # 使内容表格支持排序 self.header_table.setSortingEnabled(True) # 表头支持点击排序 # 捕捉表头点击事件 self.header_table.horizontalHeader().sectionClicked.connect(self.update_header_icons) # 布局：将表头和表格内容组合 table_layout = QVBoxLayout() table_layout.addWidget(self.header_table) table_layout.addWidget(self.content_table) table_layout.setContentsMargins(0, 0, 0, 0) table_layout.setSpacing(0) # 创建一个 QWidget 来包含 table_layout table_widget = QWidget() table_widget.setLayout(table_layout) ### 更新历史记录 ### self.history_content = self.populate_history_table(self.content_table) # 创建右侧布局，用来放置进度条和表格 right_panel = QVBoxLayout() # 添加进度条和表格到右侧布局 right_panel.addWidget(progress_widget) # 将进度条添加到表格上方 right_panel.addWidget(table_widget) # 将表格添加到进度条下方 right_panel.setContentsMargins(0, 0, 0, 0) # 移除右侧布局的内边距 ### 组合左侧面板和右侧显示区域 ### content_layout = QHBoxLayout() content_layout.addLayout(left_panel, 1) # 左侧的内容 content_layout.addLayout(right_panel, 3) # 右侧的内容，比例3：1 main_layout.addLayout(content_layout) #! 这里也取巧了，如果在这里绑定按钮，可以应用到上层的CSS效果 self.rebind_buttons(self.history_content) ### 绑定禁用按钮的信号 ### self.comm.disable_restore_buttons_signal.connect(self.disable_restore_buttons_in_row) def mousePressEvent(self, event): \u0026#34;\u0026#34;\u0026#34;鼠标按下事件：记录鼠标初始位置\u0026#34;\u0026#34;\u0026#34; if event.button() == Qt.LeftButton and not self.isMaximized(): # 禁止在最大化状态下拖动 # 检查鼠标是否点击在标题栏区域 if event.pos().y() \u0026lt;= 80: self._is_dragging = True self._drag_start_position = event.globalPos() - self.frameGeometry().topLeft() # 记录鼠标相对窗口的位置 event.accept() def mouseMoveEvent(self, event): \u0026#34;\u0026#34;\u0026#34;鼠标移动事件：当鼠标按下时，拖动窗口\u0026#34;\u0026#34;\u0026#34; if self._is_dragging and not self.isMaximized(): # 禁止在最大化状态下拖动 self.move(event.globalPos() - self._drag_start_position) # 计算并设置新的窗口位置 event.accept() def mouseReleaseEvent(self, event): \u0026#34;\u0026#34;\u0026#34;鼠标释放事件：停止拖动\u0026#34;\u0026#34;\u0026#34; if event.button() == Qt.LeftButton: self._is_dragging = False # 停止拖动 event.accept() def update_ellipsis(self): \u0026#34;\u0026#34;\u0026#34;更新省略号效果，根据不同的进度显示不同的文本\u0026#34;\u0026#34;\u0026#34; # 获取当前的省略号状态 ellipsis = self.ellipsis_states[self.current_ellipsis_index] if self.progress_value == -1: # 数据加载阶段 status_text = \u0026#34;Canceling\u0026#34; progress_text = \u0026#34;\u0026#34; # 不显示百分比 elif self.progress_value == 101: # 渲染完成状态 status_text = \u0026#34;Finished\u0026#34; progress_text = \u0026#34;\u0026#34; elif self.progress_value == 0: # 数据加载阶段 status_text = \u0026#34;Loading\u0026#34; progress_text = \u0026#34;\u0026#34; # 不显示百分比 elif self.progress_value \u0026lt; 100: if self.on_saving: # 保存阶段 status_text = \u0026#34;Saving\u0026#34; progress_text = \u0026#34;\u0026#34; # 不显示百分比 else: # 渲染阶段 status_text = \u0026#34;Rendering\u0026#34; progress_text = f\u0026#34;({self.progress_value:.2f}%)\u0026#34; # 显示百分比 else: # 进度为100%时，停止省略号效果，并显示完成状态 status_text = \u0026#34;Complete\u0026#34; progress_text = \u0026#34;(100%)\u0026#34; self.progress_bar.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QProgressBar { border-radius: 10px; text-align: center; color: white; background-color: #2a2a2a; } QProgressBar::chunk { border-radius: 10px; /* 圆角比较大，适应进度为100%的情况 */ background: rgb(87, 204, 153) } \u0026#34;\u0026#34;\u0026#34;) self.cancel_button.setVisible(False) # 隐藏取消按钮 self.confirm_button.setVisible(True) # 更新进度条的文本 self.progress_bar.setFormat(f\u0026#34;{status_text}{ellipsis if self.progress_value != 100 else \u0026#39;\u0026#39;}{progress_text}\u0026#34;) # 循环更新下一个省略号状态 self.current_ellipsis_index = (self.current_ellipsis_index + 1) % len(self.ellipsis_states) def on_saving_trigger(self): \u0026#34;\u0026#34;\u0026#34;保存状态触发\u0026#34;\u0026#34;\u0026#34; self.on_saving = True def start_progress_bar(self): \u0026#34;\u0026#34;\u0026#34;启动进度条\u0026#34;\u0026#34;\u0026#34; self.is_training = True # 设置训练状态为 True self.progress_value = 0 # 重置进度值 self.on_saving = False # 重置保存状态 self.progress_bar.setValue(0) # 重置进度条 self.progress_bar.setVisible(True) self.progress_bar.setTextVisible(True) # 显示文字 self.cancel_button.setVisible(True) # 显示取消按钮 self.cancel_button.setEnabled(True) # 取消按钮可用 self.confirm_button.setEnabled(True) # 确认按钮可用 #TODO def cancel_training(self): \u0026#34;\u0026#34;\u0026#34;取消训练任务\u0026#34;\u0026#34;\u0026#34; # 触发信号或操作以停止训练线程 print(\u0026#34;用户取消渲染\u0026#34;) self.is_training = False # 设置训练状态为 False self.cancel_button.setEnabled(False) # 禁用取消按钮 self.cancel_button.setVisible(False) # 隐藏取消按钮 self.comm.cancel_signal.emit() # 触发取消训练信号 self.progress_value = -1 # 设置进度为 -1，表示取消 QTimer.singleShot(2000, self.hide_progress_bar) self.history_content = self.populate_history_table(self.content_table) self.rebind_buttons(self.history_content) def confirm_cancel_training(self): \u0026#34;\u0026#34;\u0026#34;弹出确认框并在确认后取消训练\u0026#34;\u0026#34;\u0026#34; confirm_dialog = ConfirmDialog(\u0026#34;Cancel this action?\u0026#34;, self) if confirm_dialog.show_confirmation() == QDialog.Accepted: self.cancel_training() # 用户确认后取消训练 else: print(\u0026#34;取消操作取消\u0026#34;) #TODO def confirm_complete(self): \u0026#34;\u0026#34;\u0026#34;确认任务完成\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;用户确认完成\u0026#34;) self.is_training = False # 设置训练状态为 False self.confirm_button.setVisible(False) # 隐藏确认按钮 self.confirm_button.setEnabled(False) # 禁用确认按钮 self.progress_value = 101 # 设置进度为 101，表示完成 QTimer.singleShot(2000, self.hide_progress_bar) def hide_progress_bar(self): \u0026#34;\u0026#34;\u0026#34;隐藏进度条\u0026#34;\u0026#34;\u0026#34; self.progress_bar.setVisible(False) def update_progress_bar(self, value): \u0026#34;\u0026#34;\u0026#34;更新进度条\u0026#34;\u0026#34;\u0026#34; self.progress_value = value if (value \u0026lt;= 1): self.progress_bar.setValue(100) else: self.progress_bar.setValue(int(value * 100)) #TODO def training_complete(self): \u0026#34;\u0026#34;\u0026#34;训练完成后隐藏进度条\u0026#34;\u0026#34;\u0026#34; self.history_content = self.populate_history_table(self.content_table) self.rebind_buttons(self.history_content) def update_header_icons(self, logicalIndex): \u0026#34;\u0026#34;\u0026#34;根据排序顺序更新表头的 iconfont 图标\u0026#34;\u0026#34;\u0026#34; # 获取当前列的排序顺序（初始时没有排序状态时，默认为升序） if self.content_table.horizontalHeader().sortIndicatorSection() == logicalIndex: # 如果当前列是已经排序的列，那么获取其排序顺序并翻转它 sort_order = self.content_table.horizontalHeader().sortIndicatorOrder() sort_order = Qt.DescendingOrder if sort_order == Qt.AscendingOrder else Qt.AscendingOrder else: # 如果是新列，默认为升序 sort_order = Qt.AscendingOrder # 初始化原始表头标签 base_labels = [\u0026#34;\u0026#34;, \u0026#34;Data Name\u0026#34;, \u0026#34;Creation Time\u0026#34;, \u0026#34;Status\u0026#34;, \u0026#34;Actions\u0026#34;] # 复制 base_labels 以用于更新 self.header_labels = base_labels.copy() # 检查 logicalIndex 是否在 base_labels 的范围内 if logicalIndex \u0026lt; len(self.header_labels): # 动态更新点击的列，其他列保持原样 icon = \u0026#34;\\uE1A1\u0026#34; if sort_order == Qt.AscendingOrder else \u0026#34;\\uE1A2\u0026#34; # 更新 logicalIndex 对应列的图标 self.header_labels[logicalIndex] = f\u0026#34;{base_labels[logicalIndex]} {icon}\u0026#34; # 更新表头标签 self.header_table.setHorizontalHeaderLabels(self.header_labels) # 对内容表格进行排序 self.content_table.sortItems(logicalIndex, sort_order) # 让内容表格根据相同的列进行排序 # 设置当前表格的排序状态 self.content_table.horizontalHeader().setSortIndicator(logicalIndex, sort_order) else: print(f\u0026#34;Warning: logicalIndex {logicalIndex} is out of range for header labels.\u0026#34;) def show_input_dialog(self): \u0026#34;\u0026#34;\u0026#34;弹出输入对话框\u0026#34;\u0026#34;\u0026#34; dialog = InputDialog(self) if dialog.exec_() == QDialog.Accepted: inputs = dialog.get_inputs() print(f\u0026#34;用户输入：{inputs}\u0026#34;) self.emit_training_signal(inputs) def emit_training_signal(self, inputs): \u0026#34;\u0026#34;\u0026#34;通过信号发射用户输入的数据\u0026#34;\u0026#34;\u0026#34; model_name = inputs[\u0026#34;model_name\u0026#34;] source_path = inputs[\u0026#34;file_path\u0026#34;] iterations = int(inputs[\u0026#34;iterations\u0026#34;]) density = float(inputs[\u0026#34;density\u0026#34;]) # 获取当前时间戳，格式为：2024-08-22 23:43:29 timestamp = datetime.now().strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) unique_hash = hashlib.sha256(timestamp.encode(\u0026#39;utf-8\u0026#39;)).hexdigest() self.comm.training_params_signal.emit(timestamp, unique_hash, model_name, source_path, iterations, density, False) def populate_history_table_demo(self, table): #TODO 通过文件实际读取数据 (这里是样例数据) history_data = [ {\u0026#34;name\u0026#34;: \u0026#34;loft 2024-07-18 08:58:00 2024-07-18 08:58:00 2024-07-18 08:58:00\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-07-18 08:58:00\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A7 Completed\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/loft\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;room\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-08-22 23:43:29\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A7 Completed\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/room\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;playroom\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-09-10 18:18:20\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A8 Incomplete\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/playroom\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;loft\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-07-18 08:58:00\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A7 Completed\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/loft\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;room\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-08-22 23:43:29\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A7 Completed\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/room\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;playroom\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-09-10 18:18:20\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A8 Incomplete\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/playroom\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;loft\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-07-18 08:58:00\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A7 Completed\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/loft\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;room\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-08-22 23:43:29\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A7 Completed\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/room\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;playroom\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-09-10 18:18:20\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A8 Incomplete\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/playroom\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;loft\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-07-18 08:58:00\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A7 Completed\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/loft\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;room\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-08-22 23:43:29\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A7 Completed\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/room\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;playroom\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-09-10 18:18:20\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A8 Incomplete\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/playroom\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;loft\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-07-18 08:58:00\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A7 Completed\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/loft\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;room\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-08-22 23:43:29\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A7 Completed\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/room\u0026#34;}, {\u0026#34;name\u0026#34;: \u0026#34;playroom\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2024-09-10 18:18:20\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;\\uE1A8 Incomplete\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;C:/Users/Quite/CKCode/CKData/MT20240318-184924/mt_output/playroom\u0026#34;}, ] # 清空表格 table.setRowCount(0) table.setColumnCount(5) # 增加隐藏列 # 隐藏第一列 table.setColumnHidden(0, True) for row_data in history_data: row_position = table.rowCount() table.insertRow(row_position) # 创建并设置每一列的单元格 name_item = QTableWidgetItem(row_data[\u0026#34;name\u0026#34;]) timestamp_item = QTableWidgetItem(row_data[\u0026#34;timestamp\u0026#34;]) status_item = QTableWidgetItem(row_data[\u0026#34;status\u0026#34;]) # 设置状态单元格的颜色，根据不同状态来设置颜色 if \u0026#34;Completed\u0026#34; in row_data[\u0026#34;status\u0026#34;]: status_item.setForeground(QBrush(QColor(87, 204, 153))) # 设置字体颜色为舒适的绿色 elif \u0026#34;Incomplete\u0026#34; in row_data[\u0026#34;status\u0026#34;]: status_item.setForeground(QBrush(QColor(240, 113, 103))) # 设置字体颜色为柔和的红色 # 存储文件路径为 `Qt.UserRole` 数据 name_item.setData(Qt.UserRole, row_data[\u0026#34;path\u0026#34;]) # 设置每个单元格内容居中 name_item.setTextAlignment(Qt.AlignCenter) timestamp_item.setTextAlignment(Qt.AlignCenter) status_item.setTextAlignment(Qt.AlignCenter) name_item.setFlags(name_item.flags() \u0026amp; ~Qt.ItemIsSelectable \u0026amp; ~Qt.ItemIsEnabled) timestamp_item.setFlags(timestamp_item.flags() \u0026amp; ~Qt.ItemIsSelectable \u0026amp; ~Qt.ItemIsEnabled) status_item.setFlags(status_item.flags() \u0026amp; ~Qt.ItemIsSelectable \u0026amp; ~Qt.ItemIsEnabled) # 插入数据到表格 #! 这里取巧了，用了五列来避免第一列（索引0）插入导致后面的错误 table.setItem(row_position, 1, name_item) table.setItem(row_position, 2, timestamp_item) table.setItem(row_position, 3, status_item) return table def populate_history_table(self, table): # 清空表格 table.setRowCount(0) table.setColumnCount(6) # 增加隐藏列 # 隐藏第一列和第六列 table.setColumnHidden(0, True) table.setColumnHidden(5, True) \u0026#34;\u0026#34;\u0026#34;读取历史记录并填充表格\u0026#34;\u0026#34;\u0026#34; # 获取 LOCALAPPDATA 环境变量 local_app_data = get_local_data_directory() # 拼接历史记录文件路径 history_file = os.path.join(local_app_data, \u0026#39;MindCloud Renderer\u0026#39;, \u0026#39;history.json\u0026#39;) # 如果文件不存在，则直接返回 if not os.path.exists(history_file): print(f\u0026#34;历史记录文件不存在：{history_file}\u0026#34;) return table # 读取历史记录文件内容 with open(history_file, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: history_data = json.load(f) # 遍历历史记录并填充表格 for entry in history_data: model_name = entry[\u0026#34;model_name\u0026#34;] timestamp = entry[\u0026#34;timestamp\u0026#34;] file_path = entry[\u0026#34;file_path\u0026#34;] unique_id = entry.get(\u0026#34;id\u0026#34;, \u0026#34;\u0026#34;) # 检查文件是否存在，决定状态 if os.path.exists(file_path): print(f\u0026#34;文件存在：{file_path}\u0026#34;) status = \u0026#34;\\uE1A7 Completed\u0026#34; else: print(f\u0026#34;文件不存在：{file_path}\u0026#34;) status = \u0026#34;\\uE1A8 Incomplete\u0026#34; # 获取当前表格行数，插入新行 row_position = table.rowCount() table.insertRow(row_position) # 设置每一列的数据 id_item = QTableWidgetItem(unique_id) name_item = QTableWidgetItem(model_name) timestamp_item = QTableWidgetItem(timestamp) status_item = QTableWidgetItem(status) # 设置状态单元格的颜色，根据不同状态来设置颜色 if \u0026#34;Completed\u0026#34; in status: status_item.setForeground(QBrush(QColor(87, 204, 153))) # 设置字体颜色为绿色 elif \u0026#34;Incomplete\u0026#34; in status: status_item.setForeground(QBrush(QColor(240, 113, 103))) # 设置字体颜色为红色 # 存储文件路径为 `Qt.UserRole` 数据 name_item.setData(Qt.UserRole, file_path) # 设置每个单元格内容居中 name_item.setTextAlignment(Qt.AlignCenter) timestamp_item.setTextAlignment(Qt.AlignCenter) status_item.setTextAlignment(Qt.AlignCenter) # 禁用单元格的选择和编辑 name_item.setFlags(name_item.flags() \u0026amp; ~Qt.ItemIsSelectable \u0026amp; ~Qt.ItemIsEnabled) timestamp_item.setFlags(timestamp_item.flags() \u0026amp; ~Qt.ItemIsSelectable \u0026amp; ~Qt.ItemIsEnabled) status_item.setFlags(status_item.flags() \u0026amp; ~Qt.ItemIsSelectable \u0026amp; ~Qt.ItemIsEnabled) # 插入数据到表格 table.setItem(row_position, 1, name_item) table.setItem(row_position, 2, timestamp_item) table.setItem(row_position, 3, status_item) table.setItem(row_position, 5, id_item) return table def rebind_buttons(self, table, row=None, is_delete=False): \u0026#34;\u0026#34;\u0026#34; 绑定表格中的按钮点击事件。 - row: 如果提供了行号，则只绑定该行的按钮；否则重新绑定整个表格的按钮。 \u0026#34;\u0026#34;\u0026#34; row_count = table.rowCount() if row is not None: # 仅重新绑定特定行和之后的行 for r in range(row, row_count): self._bind_button_for_row(table, r) else: # 绑定所有行 for r in range(row_count): self._bind_button_for_row(table, r) # 禁用恢复按钮 if self.is_training: self.disable_restore_buttons_in_row(-1) if is_delete and self.restore_disabled_row \u0026gt;= 1: self.restore_disabled_row -= 1 self.disable_restore_buttons_in_row(self.restore_disabled_row) def _bind_button_for_row(self, table, row): \u0026#34;\u0026#34;\u0026#34; 绑定特定行的查看和删除按钮。 \u0026#34;\u0026#34;\u0026#34; # 获取状态项内容，用于判断按钮类型 status_item = table.item(row, 3) status_text = status_item.text() # 获取模型名称和任务ID model_name = table.item(row, 1).text() task_id = table.item(row, 5).text() # 判断是否为“已完成”还是“进行中” if \u0026#34;Completed\u0026#34; in status_text: action_button = QPushButton(\u0026#34;View\u0026#34;) action_button.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: rgb(54, 176, 123); /* 默认绿色背景 */ border-radius: 10px; /* 圆角 */ padding: 5px; } QPushButton:hover { background-color: rgb(87, 204, 153); /* 悬停时更亮的绿色 */ } QPushButton:pressed { background-color: rgb(42, 137, 96); /* 按下时更深的绿色 */ } \u0026#34;\u0026#34;\u0026#34;) # 绑定“查看”按钮的点击事件 action_button.clicked.connect(lambda checked, r=row: self.display_file_from_row(model_name, task_id)) else: # 进行中，设置为“继续”按钮 action_button = QPushButton(\u0026#34;Restore\u0026#34;) action_button.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: rgb(255, 159, 28); /* 橙色背景 */ border-radius: 10px; /* 圆角 */ padding: 5px; } QPushButton:hover { background-color: rgb(255, 191, 102); /* 悬停时变亮 */ } QPushButton:pressed { background-color: rgb(230, 134, 0); /* 按下时更深 */ } \u0026#34;\u0026#34;\u0026#34;) # 绑定“继续”按钮的点击事件 action_button.clicked.connect(lambda checked, r=row: self.continue_training_from_row(task_id, r)) # 删除按钮：红色背景 delete_button = QPushButton(\u0026#34;Delete\u0026#34;) delete_button.setFixedSize(131, 50) delete_button.setStyleSheet(\u0026#34;\u0026#34;\u0026#34; QPushButton { background-color: rgb(240, 113, 103); border-radius: 10px; /* 圆角 */ padding: 5px; } QPushButton:hover { background-color: rgb(244, 146, 139); } QPushButton:pressed { background-color: rgb(238, 80, 68); } \u0026#34;\u0026#34;\u0026#34;) # 重新绑定按钮的点击事件，更新每行的 row 索引 delete_button.clicked.connect(lambda checked, r=row: self.confirm_delete_file_from_row(table, r)) # 设置按钮大小 action_button.setFixedSize(131, 50) delete_button.setFixedSize(131, 50) # 创建水平布局（左右） button_layout = QHBoxLayout() button_layout.setSpacing(20) # 设置按钮之间的间距 button_layout.setContentsMargins(0, 0, 0, 0) # 设置内边距为0 button_layout.setAlignment(Qt.AlignCenter) # 左右居中 button_layout.addWidget(action_button) button_layout.addWidget(delete_button) # 创建垂直布局，将水平布局包裹以实现上下左右居中 outer_layout = QVBoxLayout() outer_layout.addLayout(button_layout) outer_layout.setContentsMargins(0, 0, 0, 0) # 设置内边距为0 outer_layout.setAlignment(Qt.AlignCenter) # 上下居中 # 将布局添加到 QWidget 并设置为表格的单元格内容 button_widget = QWidget() button_widget.setLayout(outer_layout) # 禁止按钮所在单元格的点击 item = QTableWidgetItem() item.setFlags(item.flags() \u0026amp; ~Qt.ItemIsSelectable \u0026amp; ~Qt.ItemIsEnabled) table.setItem(row, 4, item) # 操作列为第4列 # 将按钮布局到表格 table.setCellWidget(row, 4, button_widget) # 操作列为第4列 def delete_file_from_row(self, table, row): \u0026#34;\u0026#34;\u0026#34;根据行号删除文件记录，更新历史记录并删除本地文件夹\u0026#34;\u0026#34;\u0026#34; # 获取第1列的内容，包含文件路径 item = table.item(row, 1) if item is not None: file_path = item.data(Qt.UserRole) # 获取文件路径 print(f\u0026#34;删除行: {row}\u0026#34;) print(f\u0026#34;删除文件: {file_path}\u0026#34;) model_name = table.item(row, 1).text() unique_id = table.item(row, 5).text() # 删除历史记录中的对应记录 self.delete_from_history_json(unique_id) #TODO 不转换splat了 # 删除与 unique_id 关联的 .mt3d 文件 view_file_path = resource_path(os.path.join(\u0026#34;datas\u0026#34;, model_name, f\u0026#34;{unique_id}.mt3d\u0026#34;)) if os.path.exists(view_file_path): try: os.remove(view_file_path) print(f\u0026#34;成功删除 .mt3d 文件：{view_file_path}\u0026#34;) except FileNotFoundError: print(f\u0026#34;文件未找到，可能已经被删除：{view_file_path}\u0026#34;) except PermissionError: print(f\u0026#34;没有权限删除文件：{view_file_path}\u0026#34;) except OSError as e: print(f\u0026#34;删除文件时发生错误：{view_file_path}, 错误: {e}\u0026#34;) else: print(f\u0026#34;.mt3d 文件不存在：{view_file_path}\u0026#34;) # 从表格中删除该行 table.removeRow(row) # 重新绑定删除行后的行，因为行号会递减 remaining_rows = table.rowCount() if row \u0026lt; remaining_rows: # 确保删除行不是最后一行 self.rebind_buttons(table, row, is_delete=True) # 重新绑定按钮 else: print(f\u0026#34;Error: Row {row} does not contain valid data.\u0026#34;) def delete_from_history_json(self, unique_id): \u0026#34;\u0026#34;\u0026#34;从历史记录 JSON 文件中删除对应的记录\u0026#34;\u0026#34;\u0026#34; # 获取 LOCALAPPDATA 环境变量 local_app_data = get_local_data_directory() # 拼接历史记录文件路径 history_file = os.path.join(local_app_data, \u0026#39;MindCloud Renderer\u0026#39;, \u0026#39;history.json\u0026#39;) # 如果文件存在，读取并修改历史记录 if os.path.exists(history_file): with open(history_file, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: history_data = json.load(f) # 过滤掉与 unique_id 匹配的记录 updated_history = [entry for entry in history_data if entry.get(\u0026#34;id\u0026#34;) != unique_id] # 保存更新后的历史记录 with open(history_file, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: json.dump(updated_history, f, ensure_ascii=False, indent=4) print(f\u0026#34;历史记录已更新，删除了ID为 {unique_id} 的记录。\u0026#34;) else: print(f\u0026#34;历史记录文件不存在：{history_file}\u0026#34;) def confirm_delete_file_from_row(self, table, row): \u0026#34;\u0026#34;\u0026#34;弹出确认框并在确认后删除文件\u0026#34;\u0026#34;\u0026#34; confirm_dialog = ConfirmDialog(\u0026#34;Delete this item?\u0026#34;, self) if confirm_dialog.show_confirmation() == QDialog.Accepted: self.delete_file_from_row(table, row) # 用户确认后删除文件 else: print(\u0026#34;删除操作取消\u0026#34;) # def subprocess_start_http_server(self, file_path): # \u0026#34;\u0026#34;\u0026#34;启动 HTTP 服务器并打开指定文件的网页\u0026#34;\u0026#34;\u0026#34; # import subprocess # import sys # # 获取 viewer.exe 的路径 # server_script_path = resource_path(\u0026#34;viewer.py\u0026#34;) # if not os.path.exists(server_script_path): # print(f\u0026#34;Error: {server_script_path} not found!\u0026#34;) # return # # 使用当前 Python 解释器来运行 viewer.py，并传递参数 # python_executable = sys.executable # 获取当前 Python 解释器的路径 # subprocess.Popen([python_executable, server_script_path, \u0026#34;--file\u0026#34;, file_path]) # print(f\u0026#34;启动HTTP服务器并打开文件: {file_path}\u0026#34;) def thread_start_http_server(self, file_path): \u0026#34;\u0026#34;\u0026#34;启动 HTTP 服务器并打开指定文件的网页（使用 QThread）\u0026#34;\u0026#34;\u0026#34; self.server_thread = ServerThread(file_path) self.server_thread.start() print(f\u0026#34;启动HTTP服务器并打开文件: {file_path}\u0026#34;) def open_file_from_row(self, table, row): \u0026#34;\u0026#34;\u0026#34;根据行号获取文件路径并打开所在的文件夹\u0026#34;\u0026#34;\u0026#34; item = table.item(row, 1) # 获取第一列（name_item）的内容 file_path = item.data(Qt.UserRole) # 通过 UserRole 获取文件路径 if file_path and os.path.exists(file_path): folder_path = os.path.dirname(file_path) # 获取文件夹路径 # Windows: 打开文件所在的文件夹 if os.name == \u0026#39;nt\u0026#39;: os.startfile(folder_path) print(f\u0026#34;已打开文件所在位置: {folder_path}\u0026#34;) else: print(f\u0026#34;文件路径无效或文件不存在: {file_path}\u0026#34;) # 不转换spalt文件 def display_file_from_row(self, model_name, task_id): view_file_path = resource_path(os.path.join(\u0026#34;datas\u0026#34;, model_name, \u0026#34;{}.mt3d\u0026#34;.format(task_id))) if os.path.exists(view_file_path): self.thread_start_http_server(view_file_path) else: print(f\u0026#34;文件不存在：{view_file_path}\u0026#34;) def confirm_close(self): \u0026#34;\u0026#34;\u0026#34;显示自定义的确认对话框，确认是否退出\u0026#34;\u0026#34;\u0026#34; dialog = ConfirmDialog(\u0026#34;Exit the application?\u0026#34;, self) if dialog.show_confirmation() == QDialog.Accepted: # 用户点击了“是”，彻底退出 os._exit(0) def disable_restore_buttons_in_row(self, current_row): \u0026#34;\u0026#34;\u0026#34; 禁用所有行的“恢复”按钮，同时禁用当前行的“删除”按钮。 \u0026#34;\u0026#34;\u0026#34; row_count = self.content_table.rowCount() for row in range(row_count): # 获取操作列的按钮容器 widget = self.content_table.cellWidget(row, 4) if widget: # 遍历容器中的按钮 for btn in widget.findChildren(QPushButton): # 禁用“恢复”按钮 if btn.text() == \u0026#34;Restore\u0026#34;: btn.setEnabled(False) # 禁用当前行的“删除”按钮 if btn.text() == \u0026#34;Delete\u0026#34; and row == current_row: btn.setEnabled(False) def continue_training_from_row(self, task_id, row): \u0026#34;\u0026#34;\u0026#34; 继续未完成的训练任务，根据表格中的 ID 从 JSON 中获取训练参数。 \u0026#34;\u0026#34;\u0026#34; # 发射信号禁用按钮 self.comm.disable_restore_buttons_signal.emit(row) self.restore_disabled_row = row # 保存当前行以便恢复按钮 print(f\u0026#34;Curent row: {row}\u0026#34;) # 获取 LOCALAPPDATA 路径 local_app_data = get_local_data_directory() history_file = os.path.join(local_app_data, \u0026#39;MindCloud Renderer\u0026#39;, \u0026#39;history.json\u0026#39;) # 读取历史记录文件内容 if os.path.exists(history_file): with open(history_file, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: history_data = json.load(f) # 根据 task_id 找到对应的记录 for entry in history_data: if entry[\u0026#39;id\u0026#39;] == task_id: timestamp = entry[\u0026#39;timestamp\u0026#39;] model_name = entry[\u0026#39;model_name\u0026#39;] source_path = entry[\u0026#39;source_path\u0026#39;] iterations = entry[\u0026#39;iterations\u0026#39;] density = entry[\u0026#39;density\u0026#39;] # 发射信号开始恢复训练 self.comm.training_params_signal.emit(timestamp, task_id, model_name, source_path, int(iterations), float(density), True) print(f\u0026#34;恢复训练:{task_id}, {model_name}, {source_path}, {iterations}, {density}\u0026#34;) break else: print(f\u0026#34;未找到ID为 {task_id} 的任务记录\u0026#34;) else: print(\u0026#34;历史记录文件不存在\u0026#34;) def toggle_max_restore(self): \u0026#34;\u0026#34;\u0026#34;最大化或恢复窗口大小\u0026#34;\u0026#34;\u0026#34; if self.is_maximized: self.showNormal() self.is_maximized = False else: self.showMaximized() self.is_maximized = True # 重写绘制事件，设置无边框黑色背景 def paintEvent(self, event): painter = QPainter(self) painter.setRenderHint(QPainter.Antialiasing) painter.setBrush(QColor(30, 30, 30)) # 墨黑色背景 painter.setPen(Qt.NoPen) painter.drawRoundedRect(self.rect(), 10, 10) # 圆角矩形 之前使用tk的方式 import os import sys import queue import subprocess from tkinter import Tk, Toplevel, Label, Button, filedialog, Entry from tkinter.ttk import Progressbar, Frame import tkinter.font as tkFont class GUIUtils: \u0026#34;\u0026#34;\u0026#34; Utility class for GUI-related common operations. \u0026#34;\u0026#34;\u0026#34; @staticmethod def initialize_window(title, topmost=True): \u0026#34;\u0026#34;\u0026#34; Initialize a new top-level window with common settings. :param title: The title of the window. :param topmost: Boolean indicating whether the window should stay on top. :return: Initialized Toplevel window instance. \u0026#34;\u0026#34;\u0026#34; window = Toplevel() window.title(title) window.resizable(False, False) # Disable maximize button if topmost: window.attributes(\u0026#34;-topmost\u0026#34;, True) # Keep the window on top return window @staticmethod def set_bold_font(size=16): \u0026#34;\u0026#34;\u0026#34; Create a bold font with a given size. :param size: Font size. :return: Font object with bold weight. \u0026#34;\u0026#34;\u0026#34; return tkFont.Font(size=size, weight=\u0026#39;bold\u0026#39;) @staticmethod def center_window(window): \u0026#34;\u0026#34;\u0026#34; Center a given window on the screen. :param window: The window to center. \u0026#34;\u0026#34;\u0026#34; window.update_idletasks() width = window.winfo_width() height = window.winfo_height() screen_width = window.winfo_screenwidth() screen_height = window.winfo_screenheight() x = (screen_width // 2) - (width // 2) y = (screen_height // 2 - height // 2) window.geometry(f\u0026#39;{width}x{height}+{x}+{y}\u0026#39;) def gui_user_input(): \u0026#34;\u0026#34;\u0026#34; Get user input for training parameters (iterations) and the point cloud file path. :return: Dictionary containing user input parameters. \u0026#34;\u0026#34;\u0026#34; # Create root window to handle Tkinter initialization root = Tk() root.withdraw() # Hide main window # Create a custom input window (but don\u0026#39;t show it yet) custom_window = GUIUtils.initialize_window(\u0026#34;渲染设置\u0026#34;) custom_window.withdraw() # First hide custom window bold_font = GUIUtils.set_bold_font() # Store user choice and parameters in dictionaries user_choice = {\u0026#39;confirmed\u0026#39;: False} params = {\u0026#39;iterations\u0026#39;: 10000, \u0026#39;source_path\u0026#39;: None} # Default values # Instructions label label = Label(custom_window, text=\u0026#34;请输入渲染次数，点击确认后选择lx文件。\u0026#34;, font=bold_font) label.pack(padx=40, pady=(30, 0)) # Frame for input fields and buttons input_frame = Frame(custom_window) input_frame.pack(pady=10) # Input for iterations Label(input_frame, text=\u0026#34;渲染次数（建议值10000）\u0026#34;, font=bold_font).grid(row=0, column=0, pady=10, padx=(20, 0), sticky=\u0026#34;e\u0026#34;) iteration_entry = Entry(input_frame, font=bold_font) iteration_entry.grid(row=0, column=1, pady=10, padx=(0, 20)) # Confirm button callback function def on_confirm(): try: params[\u0026#39;iterations\u0026#39;] = int(iteration_entry.get()) if params[\u0026#39;iterations\u0026#39;] \u0026lt;= 0: raise ValueError except ValueError: sys.exit(\u0026#34;输入的渲染次数无效，程序退出。\u0026#34;) # Directly exits on invalid input # File dialog for directory selection # source_path = filedialog.askdirectory(title=\u0026#34;选择点云数据路径\u0026#34;, parent=custom_window) source_path = filedialog.askopenfilename( title=\u0026#34;选择lx文件\u0026#34;, parent=custom_window, filetypes=[(\u0026#34;LX Files\u0026#34;, \u0026#34;*.lx\u0026#34;), (\u0026#34;All Files\u0026#34;, \u0026#34;*.*\u0026#34;)] # 可选：仅显示特定文件类型 ) if not source_path: # Handle cancelation sys.exit(\u0026#34;程序已退出，因为用户未选择路径。\u0026#34;) params[\u0026#39;source_path\u0026#39;] = source_path user_choice[\u0026#39;confirmed\u0026#39;] = True custom_window.destroy() # Cancel button callback function def on_cancel(): root.destroy() # Close all windows sys.exit(\u0026#34;程序已退出，因为用户选择了取消或关闭了窗口。\u0026#34;) # Confirm and cancel buttons button_confirm = Button(custom_window, text=\u0026#34;确认\u0026#34;, font=bold_font, width=10, command=on_confirm) button_confirm.pack(side=\u0026#39;left\u0026#39;, padx=(40, 80), pady=(10, 30)) button_cancel = Button(custom_window, text=\u0026#34;取消\u0026#34;, font=bold_font, width=10, command=on_cancel) button_cancel.pack(side=\u0026#39;right\u0026#39;, padx=(80, 40), pady=(10, 30)) # Handling window close action (X button) custom_window.protocol(\u0026#34;WM_DELETE_WINDOW\u0026#34;, on_cancel) GUIUtils.center_window(custom_window) # Center the window custom_window.deiconify() # Show the custom window after centering it custom_window.wait_window() # Wait for user interaction if user_choice[\u0026#39;confirmed\u0026#39;]: return params else: sys.exit(\u0026#34;程序已退出，因为用户未确认。\u0026#34;) class TrainingProgressBar: def __init__(self, max_iterations, stop_event, progress_queue): \u0026#34;\u0026#34;\u0026#34; Initialize the training progress bar window. \u0026#34;\u0026#34;\u0026#34; self.stop_event = stop_event self.progress_queue = progress_queue # Initialize loading dots state self.dots = 0 self.loading_variants = [\u0026#34;⠄⠄⠄\u0026#34;, \u0026#34;⠄⠂⠄\u0026#34;, \u0026#34;⠄⠄⠂\u0026#34;, \u0026#34;⠄⠄⠄\u0026#34;] # 动态加载的不同文本 Unicode 字符 # Create main window for progress bar self.root = Tk() self.root.title(\u0026#34;渲染进度\u0026#34;) self.root.resizable(False, False) self.root.attributes(\u0026#34;-topmost\u0026#34;, True) bold_font = GUIUtils.set_bold_font(size=18) # Progress bar widget self.progress = Progressbar(self.root, orient=\u0026#34;horizontal\u0026#34;, length=300, mode=\u0026#39;determinate\u0026#39;) self.progress.pack(padx=30, pady=(30, 0)) self.progress[\u0026#34;maximum\u0026#34;] = max_iterations # Percentage label self.percent_label = Label(self.root, text=\u0026#34;奋力加载中⠄⠄⠄\u0026#34;, font=bold_font) self.percent_label.pack(pady=(10, 30)) # Stop button close_button = Button(self.root, text=\u0026#34;停止渲染\u0026#34;, command=self.stop_training, font=bold_font) close_button.pack(pady=(0, 30)) GUIUtils.center_window(self.root) # Center window # Disable the window close button (X) self.root.protocol(\u0026#34;WM_DELETE_WINDOW\u0026#34;, lambda: None) # Start the GUI main loop self.root.update_idletasks() self.root.update() def stop_training(self): \u0026#34;\u0026#34;\u0026#34; Stops the training and closes the progress bar. \u0026#34;\u0026#34;\u0026#34; self.stop_event.set() self.root.after_cancel(self.check_queue_id) # Cancel all pending after calls self.root.destroy() os._exit(0) def update_text(self, text): \u0026#34;\u0026#34;\u0026#34; 更新显示文本。 \u0026#34;\u0026#34;\u0026#34; self.percent_label.config(text=text) self.root.update_idletasks() def update_loading_text(self, text): \u0026#34;\u0026#34;\u0026#34; 动态更新加载中的文本。 \u0026#34;\u0026#34;\u0026#34; loading_text = text + self.loading_variants[self.dots % len(self.loading_variants)] self.update_text(loading_text) self.dots += 1 def update_progress(self, iteration): \u0026#34;\u0026#34;\u0026#34; Update the progress bar and percentage label. \u0026#34;\u0026#34;\u0026#34; self.progress[\u0026#34;value\u0026#34;] = iteration percent = (iteration / self.progress[\u0026#34;maximum\u0026#34;]) * 100 self.percent_label.config(text=f\u0026#34;进度: {percent:.2f}%\u0026#34;) self.root.update_idletasks() def check_queue(self): \u0026#34;\u0026#34;\u0026#34; Check for updates in the progress queue. \u0026#34;\u0026#34;\u0026#34; try: while not self.progress_queue.empty(): msg = self.progress_queue.get_nowait() if msg[0] == \u0026#34;update\u0026#34;: self.update_progress(msg[1]) elif msg[0] == \u0026#34;save\u0026#34;: self.update_text(\u0026#34;正在保存结果⠄⠄⠄\u0026#34;) elif msg[0] == \u0026#34;close\u0026#34;: self.close(msg[1]) except queue.Empty: pass self.check_queue_id = self.root.after(100, self.check_queue) def close(self, result_path): \u0026#34;\u0026#34;\u0026#34; Close the progress bar and show the result message. \u0026#34;\u0026#34;\u0026#34; self.root.destroy() self.show_result_message(result_path) os._exit(0) def show_result_message(self, result_path): \u0026#34;\u0026#34;\u0026#34; Show a message window with the result path and an option to open the file manager. \u0026#34;\u0026#34;\u0026#34; message_window = GUIUtils.initialize_window(\u0026#34;温馨提示\u0026#34;) bold_font = GUIUtils.set_bold_font() result_label = Label(message_window, text=f\u0026#34;渲染结果已保存到\\n\\n {result_path}\u0026#34;, font=bold_font) result_label.pack(padx=30, pady=30) def on_confirm(): self.open_file_manager(result_path) message_window.destroy() confirm_button = Button(message_window, text=\u0026#34;确认\u0026#34;, command=on_confirm, font=bold_font) confirm_button.pack(pady=(0, 30)) GUIUtils.center_window(message_window) message_window.wait_window() def open_file_manager(self, path): \u0026#34;\u0026#34;\u0026#34; Open the file manager at the given path. \u0026#34;\u0026#34;\u0026#34; if os.path.exists(path): try: if os.name == \u0026#39;nt\u0026#39;: # Windows os.startfile(path) elif os.name == \u0026#39;posix\u0026#39;: # macOS or Linux subprocess.Popen([\u0026#39;xdg-open\u0026#39;, path]) except Exception as e: print(f\u0026#34;无法打开文件管理器: {e}\u0026#34;) else: print(f\u0026#34;路径不存在: {path}\u0026#34;) 使用QT之后的main函数写法 import os import sys from utils.path_utils import resource_path, save_user_params #! 需要输出才能保存GUI进度条的输出 # 重定向标准输出和标准错误到黑洞 # log_blackhole = \u0026#39;nul\u0026#39; if os.name == \u0026#39;nt\u0026#39; else \u0026#39;/dev/null\u0026#39; # sys.stdout = open(log_blackhole, \u0026#39;w\u0026#39;) # sys.stderr = open(log_blackhole, \u0026#39;w\u0026#39;) def training(model_params, opt_params, pipe_params, saving_iterations, checkpoint_iterations, checkpoint, debug_from, parameters_storage, shuffle, point_density, unique_hash, progress_signal, saving_signal): import torch import subprocess from tqdm import tqdm from scene import Scene, GaussianModel from utils.loss_utils import l1_loss, ssim from gaussian_renderer import render from datetime import datetime # 从这里开始 first_iter = 0 model_params.model_path = resource_path(os.path.join(\u0026#34;datas\u0026#34;, model_params.model_path)) # 检查 render_path 下是否存在 success.txt lx_file_path = model_params.source_path render_path = os.path.join(os.path.dirname(lx_file_path), \u0026#39;render_db\u0026#39;) success_file_path = os.path.join(render_path, \u0026#39;success.txt\u0026#39;) # 更新 source_path model_params.source_path = render_path # 如果 success.txt 存在，直接跳过处理 if os.path.exists(success_file_path): print(f\u0026#34;Processing already completed. Skipping execution of PreOps.exe.\u0026#34;) else: # 第一步：预处理 # 执行 PreOps.exe exe_path = resource_path(\u0026#34;PreOps.exe\u0026#34;) print(f\u0026#34;Executing PreOps.exe at {exe_path}...\u0026#34;) arguments = [exe_path, lx_file_path, \u0026#39;1\u0026#39;, str(point_density)] try: result = subprocess.run(arguments, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) print(result.stdout.decode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;PreOps.exe executed successfully.\u0026#34;) # 创建 success.txt 并写入完成时间 with open(success_file_path, \u0026#39;w\u0026#39;) as success_file: success_file.write(f\u0026#34;Process completed successfully at {datetime.now().strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;)}\\n\u0026#34;) print(f\u0026#34;Success file created at {success_file_path}.\u0026#34;) except subprocess.CalledProcessError as e: print(f\u0026#34;An error occurred while executing PreOps.exe: {e.stderr.decode(\u0026#39;utf-8\u0026#39;)}\u0026#34;) sys.exit(1) # 退出程序 # 第二步：初始化模型和场景 gaussians = GaussianModel(model_params.sh_degree, parameters_storage) scene = Scene(model_params, gaussians, parameters_storage, shuffle=shuffle) gaussians.training_setup_init(opt_params) if checkpoint: (model_params, first_iter) = torch.load(checkpoint) gaussians.restore(model_params, opt_params) bg_color = [1, 1, 1] if model_params.white_background else [0, 0, 0] background = torch.tensor(bg_color, dtype=torch.float32, device=\u0026#34;cuda\u0026#34;) ema_loss_for_log = 0.0 progress_bar = tqdm(range(first_iter, opt_params.iterations), desc=\u0026#34;Training progress\u0026#34;) first_iter += 1 for iteration in range(first_iter, opt_params.iterations + 1): # Every 1000 iterations increase the levels of SH up to a maximum degree if iteration % 1000 == 0: gaussians.oneupSHdegree() resolution_scale = 1.0 viewpoint_cam = scene.get_random_train_camera(resolution_scale, model_params) if len(viewpoint_cam.visible_voxel_indices) == 0: continue current_points = gaussians.load_voxel_parameters_train(scene.parameter_manager, viewpoint_cam.visible_voxel_indices) gaussians.update_learning_rate(iteration) # Render if (iteration - 1) == debug_from: pipe_params.debug = True bg = torch.rand((3), device=\u0026#34;cuda\u0026#34;) if opt_params.random_background else background render_pkg = render(viewpoint_cam, gaussians, pipe_params, bg) image, viewspace_point_tensor, visibility_filter, radii = render_pkg[\u0026#34;render\u0026#34;], render_pkg[\u0026#34;viewspace_points\u0026#34;], render_pkg[\u0026#34;visibility_filter\u0026#34;], render_pkg[\u0026#34;radii\u0026#34;] # Loss gt_image = viewpoint_cam.original_image.cuda() Ll1 = l1_loss(image, gt_image) loss = (1.0 - opt_params.lambda_dssim) * Ll1 + opt_params.lambda_dssim * (1.0 - ssim(image, gt_image)) loss.backward() torch.cuda.empty_cache() with torch.no_grad(): has_densified = False if iteration \u0026lt; opt_params.densify_until_iter: gaussians.max_radii2D[visibility_filter] = torch.max(gaussians.max_radii2D[visibility_filter], radii[visibility_filter]) gaussians.add_densification_stats(viewspace_point_tensor, visibility_filter) if iteration \u0026gt; opt_params.densify_from_iter and iteration % opt_params.densification_interval == 0: size_threshold = 20 if iteration \u0026gt; opt_params.opacity_reset_interval else None gaussians.densify_and_prune(opt_params.densify_grad_threshold, 0.005, scene.cameras_extent, size_threshold) has_densified = True if iteration % opt_params.opacity_reset_interval == 0 or (model_params.white_background and iteration == opt_params.densify_from_iter): gaussians.reset_opacity() if iteration \u0026lt; opt_params.iterations: gaussians.optimizer.step() gaussians.optimizer.zero_grad(set_to_none=True) if iteration in checkpoint_iterations: print(f\u0026#34;\\n[ITER {iteration}] Saving Checkpoint\u0026#34;) torch.save((gaussians.capture(), iteration), scene.model_path + \u0026#34;/chkpnt\u0026#34; + str(iteration) + \u0026#34;.pth\u0026#34;) if has_densified: gaussians.save_densification_voxel_parameters(scene.parameter_manager, viewpoint_cam) else: gaussians.save_voxel_parameters(scene.parameter_manager, viewpoint_cam.visible_voxel_indices) if iteration in saving_iterations: saving_signal.emit() # scene.parameter_manager.sync_to_db() scene.save_memory(iteration, unique_hash, scene.parameter_manager) # Progress bar ema_loss_for_log = 0.4 * loss.item() + 0.6 * ema_loss_for_log progress_bar.set_postfix({\u0026#34;Loss\u0026#34;: f\u0026#34;{ema_loss_for_log:.{7}f}\u0026#34;}) progress_bar.update(1) progress_percent = round((iteration / opt_params.iterations) * 100, 2) # 发射进度更新信号 progress_signal.emit(progress_percent) # 更新 GUI 进度条 if iteration == opt_params.iterations: progress_bar.close() from PyQt5.QtWidgets import QApplication, QSplashScreen, QDesktopWidget from PyQt5.QtCore import Qt, QThread, pyqtSignal, QObject from PyQt5.QtGui import QPixmap class Communicator(QObject): # 定义一个信号，发射时会附带timestamp, unique_hash, model_name, source_path, iterations, density, resume_training training_params_signal = pyqtSignal(str, str, str, str, int, float, bool) # 定义一个信号来关闭启动画面 splash_close_splash = pyqtSignal() # 定义一个信号，用于表示训练完成 training_complete = pyqtSignal() # 定义一个信号，用于更新进度条 progress_signal = pyqtSignal(float) # 定义一个信号，用于启动训练 start_signal = pyqtSignal() # 定义一个信号，用于取消训练 cancel_signal = pyqtSignal() # 定义一个信号，用于禁用按钮 disable_restore_buttons_signal = pyqtSignal(int) # 定义一个信号，用于显示正在保存 saving_signal = pyqtSignal() def __init__(self): super().__init__() def show_splash_screen(): \u0026#34;\u0026#34;\u0026#34;显示启动画面\u0026#34;\u0026#34;\u0026#34; pixmap_path = resource_path(\u0026#34;assets/lx_start.png\u0026#34;) pixmap = QPixmap(pixmap_path) # 获取用户的屏幕分辨率 screen = QDesktopWidget().screenGeometry() screen_width = screen.width() screen_height = screen.height() # 根据屏幕大小调整比例 scale_factor = 0.2 # 比例因子 scaled_pixmap = pixmap.scaled(int(screen_width * scale_factor), int(screen_height * scale_factor), Qt.KeepAspectRatio, Qt.SmoothTransformation) splash = QSplashScreen(scaled_pixmap) splash.setWindowFlag(Qt.WindowStaysOnTopHint) # 启动画面保持在最前 splash.show() return splash class TrainingThread(QThread): def __init__(self, user_params, comm): super().__init__() self.user_params = user_params self.comm = comm def run(self): \u0026#34;\u0026#34;\u0026#34;训练任务的执行逻辑，放在子线程的 run 方法中\u0026#34;\u0026#34;\u0026#34; import torch import tempfile from shutil import rmtree from utils.general_utils import safe_state from argparse import ArgumentParser from arguments import ModelParams, PipelineParams, OptimizationParams self.comm.start_signal.emit() temp_dir = tempfile.gettempdir() print(f\u0026#34;Temporary directory: {temp_dir}\u0026#34;) default_parameters_storage = os.path.join(temp_dir, \u0026#34;parameters_storage\u0026#34;) parser = ArgumentParser(description=\u0026#34;Training script parameters\u0026#34;) model_params = ModelParams(parser, source_path=self.user_params[\u0026#39;source_path\u0026#39;], model_name=self.user_params[\u0026#39;model_name\u0026#39;]) opt_params = OptimizationParams(parser, iterations=self.user_params[\u0026#39;iterations\u0026#39;]) pipe_params = PipelineParams(parser) parser.add_argument(\u0026#39;--debug_from\u0026#39;, type=int, default=-1) parser.add_argument(\u0026#39;--detect_anomaly\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False) parser.add_argument(\u0026#34;--test_iterations\u0026#34;, nargs=\u0026#34;+\u0026#34;, type=int, default=[3_000, 7_000, 12_000, 20_000, 30_000]) parser.add_argument(\u0026#34;--save_iterations\u0026#34;, nargs=\u0026#34;+\u0026#34;, type=int, default=[30_000]) parser.add_argument(\u0026#34;--quiet\u0026#34;, action=\u0026#34;store_true\u0026#34;) parser.add_argument(\u0026#34;--checkpoint_iterations\u0026#34;, nargs=\u0026#34;+\u0026#34;, type=int, default=[]) parser.add_argument(\u0026#34;--start_checkpoint\u0026#34;, type=str, default=None) parser.add_argument(\u0026#34;--parameters_storage\u0026#34;, type=str, default=default_parameters_storage) parser.add_argument(\u0026#34;--shuffle\u0026#34;, action=\u0026#34;store_true\u0026#34;, default=True) parser.add_argument(\u0026#34;--point_density\u0026#34;, type=float, default=self.user_params[\u0026#39;density\u0026#39;]) parser.add_argument(\u0026#34;--unique_hash\u0026#34;, type=str, default=self.user_params[\u0026#39;unique_hash\u0026#39;]) args = parser.parse_args() args.save_iterations.append(self.user_params[\u0026#39;iterations\u0026#39;]) # 初始化系统状态 safe_state(args.quiet) # 是否开启异常检测 torch.autograd.set_detect_anomaly(args.detect_anomaly) # 开始训练 training(model_params.extract(args), opt_params.extract(args), pipe_params.extract(args), args.save_iterations, args.checkpoint_iterations, args.start_checkpoint, args.debug_from, args.parameters_storage, args.shuffle, args.point_density, args.unique_hash, self.comm.progress_signal, self.comm.saving_signal) # 删除缓存 if os.path.exists(args.parameters_storage): try: rmtree(args.parameters_storage) print(f\u0026#34;Successfully deleted the folder: {args.parameters_storage}\u0026#34;) except Exception as e: print(f\u0026#34;Error while deleting the folder {args.parameters_storage}: {e}\u0026#34;) print(\u0026#34;\\nTraining complete.\u0026#34;) # 任务完成后发射信号 self.comm.training_complete.emit() def main(comm): #! 这里也取巧了，提前加载需要的模块 import torch import tempfile from shutil import rmtree from utils.general_utils import safe_state from argparse import ArgumentParser from arguments import ModelParams, PipelineParams, OptimizationParams from utils.system_utils import select_cuda_device # 涉及torch加载，会有等待时间 from PyQt5.QtCore import QEventLoop from utils.qt_gui_utils import MainWindow select_cuda_device() # 发送信号来关闭启动画面 comm.splash_close_splash.emit() # 创建主窗口 main_window = MainWindow(comm) # 显示主界面 main_window.show() ### GUI主界面 ### # 用于存储信号发出的值 user_params = {} # 创建一个事件循环，用于等待信号 loop = QEventLoop() def get_train_args(timestamp, unique_hash, model_name, source_path, iterations, density, resume_training): \u0026#34;\u0026#34;\u0026#34;槽函数，用于接收信号发出的参数\u0026#34;\u0026#34;\u0026#34; user_params[\u0026#39;timestamp\u0026#39;] = timestamp user_params[\u0026#39;unique_hash\u0026#39;] = unique_hash user_params[\u0026#39;model_name\u0026#39;] = model_name user_params[\u0026#39;source_path\u0026#39;] = source_path user_params[\u0026#39;iterations\u0026#39;] = iterations user_params[\u0026#39;density\u0026#39;] = density if resume_training: print(\u0026#34;继续训练...\u0026#34;) else: save_user_params(user_params) # 保存用户参数 loop.quit() # 信号发出后，退出事件循环 # 连接信号和槽：当信号发出时，调用 get_train_args 函数 comm.training_params_signal.connect(get_train_args) while True: # 持续循环，等待用户输入 print(\u0026#34;等待新任务...\u0026#34;) loop.exec_() # 等待新任务信号，同时阻塞当前线程，需要loop.quit()来退出 ### 开始训练 ### main_window.new_task_button.setDisabled(True) # 禁用按钮 comm.disable_restore_buttons_signal.emit(-1) # 禁用所有的恢复按钮和所在行的删除按钮 # 启动训练线程，作为 main_window 的成员变量 training_thread = TrainingThread(user_params, comm) main_window.training_thread = training_thread training_thread.start() # 当训练任务完成时，恢复按钮 comm.training_complete.connect(lambda: main_window.new_task_button.setEnabled(True)) # 当收到取消信号时，停止当前训练任务 def stop_training(): print(\u0026#34;停止当前训练任务\u0026#34;) training_thread.terminate() # 停止训练线程 main_window.new_task_button.setEnabled(True) # 恢复按钮可用 # 监听取消信号，执行停止任务的逻辑 comm.cancel_signal.connect(stop_training) print(\u0026#34;继续等待新任务...\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: # 创建 QApplication 实例 app = QApplication(sys.argv) # 创建 Communicator 实例 comm = Communicator() # 显示启动画面 splash = show_splash_screen() # 连接信号到关闭启动画面的槽函数 comm.splash_close_splash.connect(lambda: splash.finish(None)) # 在主线程中运行主逻辑 main(comm) # 等待应用程序退出 sys.exit(app.exec_()) 使用tk时没有那么复杂的main函数写法 import os import sys import time import queue import threading # 创建一个全局队列用于线程间通信 progress_queue = queue.Queue() stop_event = threading.Event() # 用于控制线程停止的事件 def resource_path(relative_path): \u0026#34;\u0026#34;\u0026#34;获取资源文件的绝对路径\u0026#34;\u0026#34;\u0026#34; if getattr(sys, \u0026#39;frozen\u0026#39;, False): # 检查是否是打包的可执行文件 base_path = sys._MEIPASS # PyInstaller 会把文件解压到这个临时目录 else: base_path = os.path.abspath(\u0026#34;.\u0026#34;) # 否则使用当前目录 return os.path.join(base_path, relative_path) def training(model_params, opt_params, pipe_params, saving_iterations, checkpoint_iterations, checkpoint, debug_from, parameters_storage, shuffle, progress_bar_gui): import torch import subprocess from tqdm import tqdm from scene import Scene, GaussianModel from utils.loss_utils import l1_loss, ssim from gaussian_renderer import render def prepare_output(model_params): \u0026#34;\u0026#34;\u0026#34;准备输出文件夹并返回模型保存路径。\u0026#34;\u0026#34;\u0026#34; base_output_path = os.path.join(os.path.dirname(model_params.source_path), \u0026#39;mt_output\u0026#39;) if not model_params.model_path: # 如果没有指定 model_path，使用时间戳作为唯一字符串 unique_str = time.strftime(\u0026#34;%Y%m%d-%H%M%S\u0026#34;) model_params.model_path = os.path.join(base_output_path, unique_str) else: # 如果指定了 model_path，则基于 base_output_path 拼接路径 model_params.model_path = os.path.join(base_output_path, model_params.model_path) print(\u0026#34;Output folder:\u0026#34;, model_params.model_path) os.makedirs(model_params.model_path, exist_ok=True) return os.path.abspath(model_params.model_path) def initialize_and_execute(model_params, parameters_storage, shuffle, opt_params, results): \u0026#34;\u0026#34;\u0026#34; 执行预处理步骤，然后初始化模型和场景，并在过程中更新进度条。 \u0026#34;\u0026#34;\u0026#34; try: # 注意这里的source_path发生了替换 lx_file_path = model_params.source_path render_path = os.path.join(os.path.dirname(lx_file_path), \u0026#39;render_db\u0026#39;) model_params.source_path = render_path # 第一步：预处理 # 执行 PreOps.exe exe_path = resource_path(\u0026#34;PreOps.exe\u0026#34;) print(f\u0026#34;Executing PreOps.exe at {exe_path}...\u0026#34;) arguments = [exe_path, lx_file_path, \u0026#39;1\u0026#39;, \u0026#39;0.02\u0026#39;] try: result = subprocess.run(arguments, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) print(result.stdout.decode(\u0026#39;utf-8\u0026#39;)) # 打印标准输出 except subprocess.CalledProcessError as e: print(f\u0026#34;An error occurred while executing PreOps.exe: {e.stderr.decode(\u0026#39;utf-8\u0026#39;)}\u0026#34;) sys.exit(1) # 第二步：初始化模型和场景 gaussians = GaussianModel(model_params.sh_degree, parameters_storage) scene = Scene(model_params, gaussians, parameters_storage, shuffle=shuffle) gaussians.training_setup_init(opt_params) # 将结果存储在共享列表中 results.append((gaussians, scene)) except Exception as e: print(f\u0026#34;Initialization error: {e}\u0026#34;) sys.exit(1) # 从这里开始 first_iter = 0 model_save_path = prepare_output(model_params) # 创建初始化线程 results = [] init_thread = threading.Thread(target=initialize_and_execute, args=(model_params, parameters_storage, shuffle, opt_params, results)) init_thread.start() # 等待初始化线程完成，并在此期间更新进度条 while init_thread.is_alive(): if stop_event.is_set(): # 检查是否收到停止信号 print(\u0026#34;User stopped the training.\u0026#34;) os._exit(0) # 强制退出所有线程 # 每隔0.33秒更新一次进度条 progress_bar_gui.update_loading_text(\u0026#34;奋力加载中\u0026#34;) time.sleep(0.33) # 等待初始化线程完成 init_thread.join() progress_bar_gui.update_text(\u0026#34;进度: 0%\u0026#34;) # 初始化完成后更新进度条 # 检查结果是否存在 if results: gaussians, scene = results[0] else: print(\u0026#34;Initialization failed. Exiting...\u0026#34;) os._exit(0) if checkpoint: (model_params, first_iter) = torch.load(checkpoint) gaussians.restore(model_params, opt_params) bg_color = [1, 1, 1] if model_params.white_background else [0, 0, 0] background = torch.tensor(bg_color, dtype=torch.float32, device=\u0026#34;cuda\u0026#34;) ema_loss_for_log = 0.0 progress_bar = tqdm(range(first_iter, opt_params.iterations), desc=\u0026#34;Training progress\u0026#34;) first_iter += 1 for iteration in range(first_iter, opt_params.iterations + 1): if stop_event.is_set(): # 检查是否收到停止信号 print(\u0026#34;User stopped the training while iterating.\u0026#34;) break # Every 1000 iterations increase the levels of SH up to a maximum degree if iteration % 1000 == 0: gaussians.oneupSHdegree() resolution_scale = 1.0 viewpoint_cam = scene.get_random_train_camera(resolution_scale, model_params) if len(viewpoint_cam.visible_voxel_indices) == 0: continue current_points = gaussians.load_voxel_parameters_train(scene.parameter_manager, viewpoint_cam.visible_voxel_indices) gaussians.update_learning_rate(iteration) # Render if (iteration - 1) == debug_from: pipe_params.debug = True bg = torch.rand((3), device=\u0026#34;cuda\u0026#34;) if opt_params.random_background else background render_pkg = render(viewpoint_cam, gaussians, pipe_params, bg) image, viewspace_point_tensor, visibility_filter, radii = render_pkg[\u0026#34;render\u0026#34;], render_pkg[\u0026#34;viewspace_points\u0026#34;], render_pkg[\u0026#34;visibility_filter\u0026#34;], render_pkg[\u0026#34;radii\u0026#34;] # Loss gt_image = viewpoint_cam.original_image.cuda() Ll1 = l1_loss(image, gt_image) loss = (1.0 - opt_params.lambda_dssim) * Ll1 + opt_params.lambda_dssim * (1.0 - ssim(image, gt_image)) loss.backward() torch.cuda.empty_cache() with torch.no_grad(): has_densified = False if iteration \u0026lt; opt_params.densify_until_iter: gaussians.max_radii2D[visibility_filter] = torch.max(gaussians.max_radii2D[visibility_filter], radii[visibility_filter]) gaussians.add_densification_stats(viewspace_point_tensor, visibility_filter) if iteration \u0026gt; opt_params.densify_from_iter and iteration % opt_params.densification_interval == 0: size_threshold = 20 if iteration \u0026gt; opt_params.opacity_reset_interval else None gaussians.densify_and_prune(opt_params.densify_grad_threshold, 0.005, scene.cameras_extent, size_threshold) has_densified = True if iteration % opt_params.opacity_reset_interval == 0 or (model_params.white_background and iteration == opt_params.densify_from_iter): gaussians.reset_opacity() if iteration \u0026lt; opt_params.iterations: gaussians.optimizer.step() gaussians.optimizer.zero_grad(set_to_none=True) if iteration in checkpoint_iterations: print(f\u0026#34;\\n[ITER {iteration}] Saving Checkpoint\u0026#34;) torch.save((gaussians.capture(), iteration), scene.model_path + \u0026#34;/chkpnt\u0026#34; + str(iteration) + \u0026#34;.pth\u0026#34;) if has_densified: gaussians.save_densification_voxel_parameters(scene.parameter_manager, viewpoint_cam) else: gaussians.save_voxel_parameters(scene.parameter_manager, viewpoint_cam.visible_voxel_indices) if iteration in saving_iterations: progress_queue.put((\u0026#34;save\u0026#34;, iteration)) scene.save_memory(iteration, scene.parameter_manager) # Progress bar ema_loss_for_log = 0.4 * loss.item() + 0.6 * ema_loss_for_log progress_bar.set_postfix({\u0026#34;Loss\u0026#34;: f\u0026#34;{ema_loss_for_log:.{7}f}\u0026#34;}) progress_bar.update(1) # 更新 GUI 进度条 progress_queue.put((\u0026#34;update\u0026#34;, iteration)) # 将进度更新放入队列 if iteration == opt_params.iterations: progress_bar.close() progress_queue.put((\u0026#34;close\u0026#34;, model_save_path)) # 将关闭消息放入队列 from PyQt5.QtWidgets import QApplication, QSplashScreen, QDesktopWidget from PyQt5.QtCore import Qt, pyqtSignal, QObject from PyQt5.QtGui import QPixmap class Communicator(QObject): close_splash = pyqtSignal() # 定义一个信号来关闭启动画面 def show_splash_screen(): \u0026#34;\u0026#34;\u0026#34;显示启动画面\u0026#34;\u0026#34;\u0026#34; app = QApplication(sys.argv) pixmap_path = resource_path(\u0026#34;assets/lx_start.png\u0026#34;) pixmap = QPixmap(pixmap_path) # 获取用户的屏幕分辨率 screen = QDesktopWidget().screenGeometry() screen_width = screen.width() screen_height = screen.height() # 根据屏幕大小调整比例，例如设置为屏幕宽度的 30% 和高度的 30% scale_factor = 0.2 # 比例因子 scaled_pixmap = pixmap.scaled(int(screen_width * scale_factor), int(screen_height * scale_factor), Qt.KeepAspectRatio, Qt.SmoothTransformation) splash = QSplashScreen(scaled_pixmap) splash.setWindowFlag(Qt.WindowStaysOnTopHint) # 启动画面保持在最前 splash.show() return app, splash def main(comm): import torch import tempfile from shutil import rmtree from utils.general_utils import safe_state from argparse import ArgumentParser from arguments import ModelParams, PipelineParams, OptimizationParams from utils.tk_gui_utils import TrainingProgressBar from utils.system_utils import select_cuda_device # 涉及torch加载，会有等待时间 select_cuda_device() # 发送信号来关闭启动画面 comm.close_splash.emit() from utils.tk_gui_utils import gui_user_input user_params = gui_user_input() # 预处理的路径准备 source_path = os.path.normpath(user_params[\u0026#39;source_path\u0026#39;]) print(f\u0026#34;Source path: {source_path}\u0026#34;) temp_dir = tempfile.gettempdir() print(f\u0026#34;Temporary directory: {temp_dir}\u0026#34;) # 设置默认的参数存储路径 default_parameters_storage = os.path.join(temp_dir, \u0026#34;parameters_storage\u0026#34;) # 设置命令行参数解析器 parser = ArgumentParser(description=\u0026#34;Training script parameters\u0026#34;) model_params = ModelParams(parser, source_path=source_path) opt_params = OptimizationParams(parser, iterations=user_params[\u0026#39;iterations\u0026#39;]) pipe_params = PipelineParams(parser) parser.add_argument(\u0026#39;--debug_from\u0026#39;, type=int, default=-1) parser.add_argument(\u0026#39;--detect_anomaly\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False) parser.add_argument(\u0026#34;--test_iterations\u0026#34;, nargs=\u0026#34;+\u0026#34;, type=int, default=[3_000, 7_000, 12_000, 20_000, 30_000]) parser.add_argument(\u0026#34;--save_iterations\u0026#34;, nargs=\u0026#34;+\u0026#34;, type=int, default=[]) parser.add_argument(\u0026#34;--quiet\u0026#34;, action=\u0026#34;store_true\u0026#34;) parser.add_argument(\u0026#34;--checkpoint_iterations\u0026#34;, nargs=\u0026#34;+\u0026#34;, type=int, default=[]) parser.add_argument(\u0026#34;--start_checkpoint\u0026#34;, type=str, default=None) parser.add_argument(\u0026#34;--parameters_storage\u0026#34;, type=str, default=default_parameters_storage) parser.add_argument(\u0026#34;--shuffle\u0026#34;, action=\u0026#34;store_true\u0026#34;, default=True) args = parser.parse_args(sys.argv[1:]) args.save_iterations.append(user_params[\u0026#39;iterations\u0026#39;]) print(\u0026#34;save iterations:\u0026#34;, args.save_iterations) # 初始化系统状态（随机数生成器） safe_state(args.quiet) # 是否开启异常检测 torch.autograd.set_detect_anomaly(args.detect_anomaly) # 创建 GUI 进度条实例 progress_bar_gui = TrainingProgressBar(max_iterations=args.iterations, stop_event=stop_event, progress_queue=progress_queue) # 启动训练线程 training_thread = threading.Thread(target=training, args=(model_params.extract(args), opt_params.extract(args), pipe_params.extract(args), args.save_iterations, args.checkpoint_iterations, args.start_checkpoint, args.debug_from, args.parameters_storage, args.shuffle, progress_bar_gui)) training_thread.start() progress_bar_gui.root.after(100, progress_bar_gui.check_queue) progress_bar_gui.root.mainloop() print(\u0026#34;\\nTraining complete.\u0026#34;) # 删除缓存 if os.path.exists(args.parameters_storage): try: rmtree(args.parameters_storage) print(f\u0026#34;Successfully deleted the folder: {args.parameters_storage}\u0026#34;) except Exception as e: print(f\u0026#34;Error while deleting the folder {args.parameters_storage}: {e}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: # 创建 Communicator 实例 comm = Communicator() # 显示启动画面 app, splash = show_splash_screen() # 连接信号到关闭启动画面的槽函数 comm.close_splash.connect(lambda: splash.finish(None)) #! 需要输出才能保存GUI进度条的输出 # 重定向标准输出和标准错误到黑洞 log_blackhole = \u0026#39;nul\u0026#39; if os.name == \u0026#39;nt\u0026#39; else \u0026#39;/dev/null\u0026#39; sys.stdout = open(log_blackhole, \u0026#39;w\u0026#39;) sys.stderr = open(log_blackhole, \u0026#39;w\u0026#39;) # 在主线程中运行主逻辑 main(comm) 通过python打开含js网页的写法 import http.server import socketserver import webbrowser import os import argparse import signal import sys from urllib.parse import urlparse, parse_qs from utils.path_utils import resource_path, resource_path_http PORT = 0 # 设置为 0，让系统自动分配端口 # 动态生成 HTML 文件 def generate_html(cloud_path): html_content = f\u0026#34;\u0026#34;\u0026#34; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;MindCloud 3DViewer\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body, html {{ margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; color: #fff; display: flex; justify-content: center; align-items: center; }} .loading-icon {{ display: none; width: 80px; padding: 15px; background: #36b07b; aspect-ratio: 1; border-radius: 50%; --_m: conic-gradient(#0000, #000), linear-gradient(#000 0 0) content-box; -webkit-mask: var(--_m); mask: var(--_m); -webkit-mask-composite: source-out; mask-composite: subtract; box-sizing: border-box; animation: ply-load 1s linear infinite; margin: 20px auto 0; }} canvas {{ position: absolute; top: 0; left: 0; }} @keyframes ply-load {{ to {{ transform: rotate(1turn) }} }} \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;importmap\u0026#34;\u0026gt; {{ \u0026#34;imports\u0026#34;: {{ \u0026#34;three\u0026#34;: \u0026#34;./lib/three.min.js\u0026#34;, \u0026#34;gaussian-splats-3d\u0026#34;: \u0026#34;./lib/mt3d.min.js\u0026#34; }} }} \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;canvas id=\u0026#34;bgCanvas\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;div id=\u0026#34;viewStatus\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;viewError\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;view-loading-icon\u0026#34; class=\u0026#34;loading-icon\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import * as GaussianSplats3D from \u0026#39;gaussian-splats-3d\u0026#39;; import * as THREE from \u0026#39;three\u0026#39;; function fileBufferToSplatBuffer(fileBufferData, format, alphaRemovalThreshold, compressionLevel, sectionSize, sceneCenter, blockSize, bucketSize, outSphericalHarmonicsDegree = 0) {{ if (format === GaussianSplats3D.SceneFormat.Ply) {{ return GaussianSplats3D.PlyLoader.loadFromFileData(fileBufferData.data, alphaRemovalThreshold, compressionLevel, outSphericalHarmonicsDegree, sectionSize, sceneCenter, blockSize, bucketSize); }} else if (format === GaussianSplats3D.SceneFormat.Splat) {{ return GaussianSplats3D.SplatLoader.loadFromFileData(fileBufferData.data, alphaRemovalThreshold, compressionLevel, sectionSize, sceneCenter, blockSize, bucketSize); }} else {{ return GaussianSplats3D.KSplatLoader.loadFromFileData(fileBufferData.data); }} }} function setViewError(msg) {{ setViewLoadingIconVisibility(false); document.getElementById(\u0026#34;viewStatus\u0026#34;).innerHTML = \u0026#34;\u0026#34;; document.getElementById(\u0026#34;viewError\u0026#34;).innerHTML = msg; }} function setViewStatus(msg) {{ setViewLoadingIconVisibility(true); document.getElementById(\u0026#34;viewError\u0026#34;).innerHTML = \u0026#34;\u0026#34;; document.getElementById(\u0026#34;viewStatus\u0026#34;).innerHTML = msg; }} function setViewLoadingIconVisibility(visible) {{ document.getElementById(\u0026#39;view-loading-icon\u0026#39;).style.display = visible ? \u0026#39;block\u0026#39; : \u0026#39;none\u0026#39;; }} const path = \u0026#39;{cloud_path}\u0026#39;; const format = GaussianSplats3D.LoaderUtils.sceneFormatFromPath(path); const alphaRemovalThreshold = 2; const cameraUpArray = [0, 0, 1]; const cameraPositionArray = [0, 1, 0]; const cameraLookAtArray = [1, 0, 0]; const antialiased = false; const sceneIs2D = false; const sphericalHarmonicsDegree = 0; fetch(path) .then(response =\u0026gt; response.arrayBuffer()) .then(buffer =\u0026gt; {{ const viewerOptions = {{ \u0026#39;cameraUp\u0026#39;: cameraUpArray, \u0026#39;initialCameraPosition\u0026#39;: cameraPositionArray, \u0026#39;initialCameraLookAt\u0026#39;: cameraLookAtArray, \u0026#39;halfPrecisionCovariancesOnGPU\u0026#39;: false, \u0026#39;antialiased\u0026#39;: antialiased || false, \u0026#39;splatRenderMode\u0026#39;: sceneIs2D ? GaussianSplats3D.SplatRenderMode.TwoD : GaussianSplats3D.SplatRenderMode.ThreeD, \u0026#39;sphericalHarmonicsDegree\u0026#39;: sphericalHarmonicsDegree }}; const splatBufferOptions = {{ \u0026#39;splatAlphaRemovalThreshold\u0026#39;: alphaRemovalThreshold }}; const splatBufferPromise = fileBufferToSplatBuffer({{ data: buffer }}, format, alphaRemovalThreshold, 0, undefined, undefined, undefined, undefined, sphericalHarmonicsDegree); splatBufferPromise.then((splatBuffer) =\u0026gt; {{ document.body.style.backgroundColor = \u0026#34;#000000\u0026#34;; const allCanvases = document.querySelectorAll(\u0026#39;canvas\u0026#39;); allCanvases.forEach(canvas =\u0026gt; canvas.remove()); const viewer = new GaussianSplats3D.Viewer(viewerOptions); viewer.addSplatBuffers([splatBuffer], [splatBufferOptions]) .then(() =\u0026gt; {{ viewer.start(); setViewLoadingIconVisibility(false); }}); }}); }}) .catch(err =\u0026gt; {{ console.error(\u0026#34;Error loading the file:\u0026#34;, err); setViewError(\u0026#34;Error loading the file.\u0026#34;); }}); setViewLoadingIconVisibility(true); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; return html_content class CustomHandler(http.server.SimpleHTTPRequestHandler): def do_GET(self): # 对于 .js 文件，直接提供 if self.path.endswith(\u0026#34;.js\u0026#34;): js_file_path = resource_path_http(self.path.lstrip(\u0026#39;/\u0026#39;)) print(f\u0026#34;Serving JavaScript file: {js_file_path}\u0026#34;) if os.path.exists(js_file_path): self.send_response(200) self.send_header(\u0026#34;Content-type\u0026#34;, \u0026#34;application/javascript\u0026#34;) self.end_headers() with open(js_file_path, \u0026#39;rb\u0026#39;) as js_file: self.wfile.write(js_file.read()) else: self.send_error(404, f\u0026#34;File not found: {js_file_path}\u0026#34;) return # 对于 .html 文件，解析 URL 参数，获取文件路径 elif self.path.endswith(\u0026#34;.html\u0026#34;): print(f\u0026#34;Serving HTML file: {self.path}\u0026#34;) query_components = parse_qs(urlparse(self.path).query) file_path = query_components.get(\u0026#34;file\u0026#34;, [default_file])[0] # 检查文件是否存在 if not os.path.exists(file_path): self.send_error(404, f\u0026#34;File not found: {file_path}\u0026#34;) return # 将文件复制到 exe 所在的 datas 目录 file_name = os.path.basename(file_path) file_http_path = resource_path_http(f\u0026#34;./datas/{file_name}\u0026#34;) # file_http_path = f\u0026#34;./datas/{file_name}\u0026#34; print(\u0026#34;file_http_path\u0026#34;, file_http_path) # if not os.path.exists(file_http_path): # os.makedirs(os.path.dirname(file_http_path), exist_ok=True) # with open(file_path, \u0026#39;rb\u0026#39;) as src_file, open(file_http_path, \u0026#39;wb\u0026#39;) as dest_file: # dest_file.write(src_file.read()) # print(f\u0026#34;Copying from {file_path} to {file_http_path}\u0026#34;) # 生成动态 HTML self.send_response(200) self.send_header(\u0026#34;Content-type\u0026#34;, \u0026#34;text/html\u0026#34;) self.end_headers() html_content = generate_html(file_http_path) self.wfile.write(html_content.encode(\u0026#34;utf-8\u0026#34;)) # 处理 favicon.ico 文件 elif self.path.endswith(\u0026#34;.ico\u0026#34;): # 这里手动指定 .ico 文件的路径 ico_file_path = resource_path(\u0026#34;assets/favicon.ico\u0026#34;) # 假设 ico 文件在 assets 文件夹下 print(f\u0026#34;Serving icon file: {ico_file_path}\u0026#34;) if os.path.exists(ico_file_path): self.send_response(200) self.send_header(\u0026#34;Content-type\u0026#34;, \u0026#34;image/x-icon\u0026#34;) self.end_headers() with open(ico_file_path, \u0026#39;rb\u0026#39;) as ico_file: self.wfile.write(ico_file.read()) else: self.send_error(404, f\u0026#34;File not found: {ico_file_path}\u0026#34;) return # 其他未单独考虑的静态文件处理 else: print(f\u0026#34;Serving static file: {self.path}\u0026#34;) super().do_GET() def end_headers(self): # 添加 HTTP 头部，确保跨域策略 if self.path.endswith(\u0026#34;.js\u0026#34;): self.send_header(\u0026#34;Content-type\u0026#34;, \u0026#34;application/javascript\u0026#34;) else: self.send_header(\u0026#34;Cross-Origin-Opener-Policy\u0026#34;, \u0026#34;same-origin\u0026#34;) self.send_header(\u0026#34;Cross-Origin-Embedder-Policy\u0026#34;, \u0026#34;require-corp\u0026#34;) super().end_headers() # 命令行参数解析 parser = argparse.ArgumentParser( description=\u0026#34;Start a simple HTTP server with dynamic file handling.\u0026#34; ) parser.add_argument(\u0026#34;--file\u0026#34;, type=str, required=True, help=\u0026#34;The file path to be used\u0026#34;) args = parser.parse_args() # 传递的文件路径 default_file = args.file def start_server(): with socketserver.TCPServer((\u0026#34;\u0026#34;, PORT), CustomHandler) as httpd: assigned_port = httpd.server_address[1] print(f\u0026#34;Serving at port {assigned_port}\u0026#34;) html_name = os.path.splitext(os.path.basename(default_file))[0] dynamic_html_file = f\u0026#34;http://localhost:{assigned_port}/{html_name}.html\u0026#34; webbrowser.open(dynamic_html_file) def signal_handler(sig, frame): print(\u0026#34;\\nShutting down server...\u0026#34;) httpd.server_close() sys.exit(0) signal.signal(signal.SIGINT, signal_handler) httpd.serve_forever() if __name__ == \u0026#34;__main__\u0026#34;: start_server() log_blackhole = \u0026#39;nul\u0026#39; if os.name == \u0026#39;nt\u0026#39; else \u0026#39;/dev/null\u0026#39; sys.stdout = open(log_blackhole, \u0026#39;w\u0026#39;) sys.stderr = open(log_blackhole, \u0026#39;w\u0026#39;) ","permalink":"https://ahaknow.com/posts/know/dev-python-to-app/","summary":"前言 怎么样从一个Python脚本一步一步变成一个可以在多平台上独立使用的App呢？ 在这一部分之前，是改进和优化Python的训练脚本，其中涉","title":"全栈开发：从Python脚本到独立的App（初稿）"},{"content":"反正就是，日常生产力的Mac，不要升级！\n这不升级了嘛，然后多了“查找本地网络设备”的选项，我没开，结果Mac作为超级终端本的ssh大法直接懵逼。。。\n以及，proxy软件直接报废（clash都下架了，不该升级系统啊，现在用不了吧！）\n自求多福吧！\nmacos14到15，没有感受到一点变化，结果现在一堆问题，甚至现在打字的软件都出问题了。。。\n","permalink":"https://ahaknow.com/posts/know/macos-do-not-upgrade/","summary":"反正就是，日常生产力的Mac，不要升级！ 这不升级了嘛，然后多了“查找本地网络设备”的选项，我没开，结果Mac作为超级终端本的ssh大法直接懵","title":"Mac：闲得没事不要升级系统"},{"content":" 一顿操作猛如虎，鬼使神差来了个git add .\n并不想这样的，因为压根不是想要git管理的目录😂\n怎么ctrl+z一下呢？\n具体操作 在Git中，有两个常见的操作可以撤销误操作的 git add . ：取消暂存（unstage）和取消缓存（uncache）。这两个操作有些区别，下面将详细解释它们的区别和具体用法。\n1. 取消暂存（Unstage） 取消暂存是指将文件从暂存区移除，使其回到工作区的修改状态。这意味着这些文件的修改将不会包含在下一个提交中，但文件本身及其修改仍然存在于工作目录中。\n用法 使用 git restore --staged \u0026lt;file\u0026gt; 命令可以将文件从暂存区移除：\ngit restore --staged README.md git restore --staged models/model_mobilev2_960_512.onnx git restore --staged onnx_inference.py git restore --staged onnx_runtime_base.py 或者一次性取消暂存所有文件：\ngit restore --staged . 适用场景 当误操作执行 git add . 之后，但不想提交某些文件的修改时，可以使用取消暂存操作。取消暂存不会丢失文件的任何修改，只是将它们从暂存区移除。\n2. 取消缓存（Uncache） 取消缓存是指将文件从Git的索引中移除，但不会删除工作目录中的文件。这通常用于将文件从版本控制中排除，但文件仍保留在本地。\n用法 使用 git rm --cached \u0026lt;file\u0026gt; 命令可以将文件从Git的索引中移除：\ngit rm --cached README.md git rm --cached models/model_mobilev2_960_512.onnx git rm --cached onnx_inference.py git rm --cached onnx_runtime_base.py 适用场景 当误操作执行 git add . 之后，并且希望将某些文件从版本控制中排除时（例如，不小心添加了不应被版本控制的文件，比如敏感数据或临时文件），可以使用取消缓存操作。 当想要停止跟踪某个文件但保留它在工作目录中时，这也是一个常见的使用场景。 总结 取消暂存（Unstage）：使用 git restore --staged \u0026lt;file\u0026gt; 将文件从暂存区移除，但文件及其修改仍然存在于工作目录中。适用于希望保留文件的修改但不包括在下一个提交中的情况。\n取消缓存（Uncache）：使用 git rm --cached \u0026lt;file\u0026gt; 将文件从Git的索引中移除，但不会删除工作目录中的文件。适用于希望将文件从版本控制中排除但保留在本地的情况。\n示例 假设误操作执行了 git add . ，并且想撤销这个操作：\n查看当前Git状态：\ngit status 输出示例：\nChanges to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: README.md new file: models/model_mobilev2_960_512.onnx new file: onnx_inference.py new file: onnx_runtime_base.py 取消暂存所有文件：\ngit restore --staged . 或者取消特定文件的暂存：\ngit restore --staged README.md 取消缓存特定文件（如果不想再跟踪这些文件）：\ngit rm --cached models/model_mobilev2_960_512.onnx 🌟更直白的理解 如果只是git add . 之后没有其他操作了，git restore --staged 和 git rm --cached 效果是一样的。\n如果git add . 之后又git commit 了，那就需要git rm --cached了～\n如果只是 git add . 之后没有其他操作：\n使用 git restore --staged 和 git rm --cached 的效果是一样的，都会将文件从暂存区移除，使其回到工作区的修改状态。 git restore --staged README.md git rm --cached README.md 这两者在这种情况下效果相同。\n如果 git add . 之后又 git commit 了：\n这时已经提交了更改，如果希望不再跟踪某些文件，需要使用 git rm --cached。这会将文件从版本控制中移除，但保留在工作目录中。然后你需要再次提交这个更改。 git rm --cached README.md git commit -m \u0026#34;Remove README.md from version control\u0026#34; 示例解释 误操作 git add . 后没有提交：\n撤销所有文件的暂存： git restore --staged . 或者撤销特定文件的暂存： git restore --staged README.md 误操作 git add . 后已经提交：\n假设已经提交了更改，现在想要移除某些文件的版本控制： git rm --cached README.md git commit -m \u0026#34;Remove README.md from version control\u0026#34; ","permalink":"https://ahaknow.com/posts/know/note-git-unstage/","summary":"一顿操作猛如虎，鬼使神差来了个git add . 并不想这样的，因为压根不是想要git管理的目录😂 怎么ctrl+z一下呢？ 具体操作 在Git中，有两个常","title":"Git：不小心git add . 之后"},{"content":" 去年2023年，固态硬盘低谷的时候买了一个2T的，现在没啥用了，原本想着装移动版的MacOS系统的，但是看了看雷电3硬盘盒的读写速度，三星的比较稳定，这个雷克沙属实。。。拉垮。\n准备卖了，现在的价格是799，想着卖700可以的吧？结果最后被砍到600。。。\n砍就砍了，结果还要我给他一个硬盘检测的信息，Windows上这种软件挺多，Linux？估计没有，但理论上讲，Linux获取这些信息会更直接，也更方便，什么硬盘的通电次数、通电时间，读写量啊，应该用命令行就能查看。\n在Linux系统下，有几种工具可以用来查看固态硬盘（SSD）的通电次数、通电时间，以及读写的数据量。以下是一些常用的工具和命令：\n1. smartctl 工具 smartctl 是 smartmontools 软件包中的一个工具，用于监控和管理硬盘的SMART属性。可以使用它来查看SSD的详细信息。\n安装 smartmontools 在Ubuntu或Debian系统上，使用以下命令安装 smartmontools：\nsudo apt-get update sudo apt-get install smartmontools 使用 smartctl 查看硬盘信息 查看基本信息：\nsudo smartctl -a /dev/sdX 其中 /dev/sdX 是你的硬盘设备名（例如 /dev/sda）。\n具体使用如下：\nsudo smartctl -a /dev/nvme0n1 smartctl 7.1 2019-12-30 r5022 [x86_64-linux-5.15.0-84-generic] (local build) Copyright (C) 2002-19, Bruce Allen, Christian Franke, www.smartmontools.org === START OF INFORMATION SECTION === Model Number: KINGSTON SNVS1000G Serial Number: 50026B7685D2DF4A Firmware Version: S8442105 PCI Vendor/Subsystem ID: 0x2646 IEEE OUI Identifier: 0x0026b7 Controller ID: 1 Number of Namespaces: 1 Namespace 1 Size/Capacity: 1,000,204,886,016 [1.00 TB] Namespace 1 Formatted LBA Size: 512 Namespace 1 IEEE EUI-64: 0026b7 685d2df4a5 Local Time is: Wed Jun 5 15:58:07 2024 CST Firmware Updates (0x12): 1 Slot, no Reset required Optional Admin Commands (0x0016): Format Frmw_DL Self_Test Optional NVM Commands (0x005f): Comp Wr_Unc DS_Mngmt Wr_Zero Sav/Sel_Feat Timestmp Maximum Data Transfer Size: 64 Pages Warning Comp. Temp. Threshold: 85 Celsius Critical Comp. Temp. Threshold: 90 Celsius Supported Power States St Op Max Active Idle RL RT WL WT Ent_Lat Ex_Lat 0 + 6.00W - - 0 0 0 0 0 0 1 + 3.00W - - 1 1 1 1 0 0 2 + 1.50W - - 2 2 2 2 0 0 3 - 0.0250W - - 3 3 3 3 8000 3000 4 - 0.0040W - - 4 4 4 4 25000 25000 Supported LBA Sizes (NSID 0x1) Id Fmt Data Metadt Rel_Perf 0 + 512 0 0 === START OF SMART DATA SECTION === SMART overall-health self-assessment test result: PASSED SMART/Health Information (NVMe Log 0x02) Critical Warning: 0x00 Temperature: 54 Celsius Available Spare: 100% Available Spare Threshold: 10% Percentage Used: 0% Data Units Read: 4,596,860 [2.35 TB] Data Units Written: 6,819,671 [3.49 TB] Host Read Commands: 40,326,724 Host Write Commands: 85,231,477 Controller Busy Time: 3,283 Power Cycles: 130 Power On Hours: 5,507 Unsafe Shutdowns: 100 Media and Data Integrity Errors: 0 Error Information Log Entries: 0 Warning Comp. Temperature Time: 0 Critical Comp. Temperature Time: 0 Error Information (NVMe Log 0x01, max 64 entries) No Errors Logged 2. nvme-cli 工具 如果SSD是NVMe接口的，可以使用 nvme-cli 工具来查看详细信息。\n安装 nvme-cli 在Ubuntu或Debian系统上，使用以下命令安装 nvme-cli：\nsudo apt-get update sudo apt-get install nvme-cli 使用 nvme-cli 查看硬盘信息 查看基本信息：\nsudo nvme smart-log /dev/nvme0 其中 /dev/nvme0 是NVMe设备名。\n查看详细SMART属性：\nsudo nvme smart-log /dev/nvme0 | grep -i \u0026#39;data_units_written\\|data_units_read\\|power_on_hours\\|power_cycles\u0026#39; 具体使用效果：\nsudo nvme smart-log /dev/nvme0 | grep -i \u0026#39;data_units_written\\|data_units_read\\|power_on_hours\\|power_cycles\u0026#39; data_units_read : 4,596,861 data_units_written : 6,819,687 power_cycles : 130 power_on_hours : 5,508 ","permalink":"https://ahaknow.com/posts/know/linux-disk-info/","summary":"去年2023年，固态硬盘低谷的时候买了一个2T的，现在没啥用了，原本想着装移动版的MacOS系统的，但是看了看雷电3硬盘盒的读写速度，三星的","title":"Linux：命令行方式查看硬盘信息"},{"content":" 遇到的问题是这样的：\n“莫名其妙，GPU驱动就没了，可能是因为update \u0026amp;\u0026amp; upgrade了一下？（ROS安装源的问题，更换到了国内之后好像没有重新安装，还用了autoremove进行清理），总之就是GPU挂了。。。”\n凭借的记忆通过本地deb的方式，重装发现一直出错。\n一直出错，那就一直尝试，卸载重装（主要卸载的还是Nvidia相关的），但是同样还是错误。。。\n重新下载一个CUDA版本？下载了安装还是错误。。。\n最终，理清楚思路，可能是Linux内核的问题，因为之前出现过，新内核安装完驱动后启动不了，切换成上一个内核就行了。。。（印象中是这样的）\n于是，切换到就内核再装，还是一样的错误，发现错误提示里还有新内核的痕迹，果断，把新内核卸载并且清空，Nvidia以及CUDA相关的也全都卸载重装……\n终于，成功了！\nNvidia卸载重装：卸载干净了再装！ 显卡驱动容易挂掉？（可能是这样，但是正经安装的，绝不应该！）\n这次完全是装不了，刚才也说了，采用逆向分析应该是内核版本的原因，但是Nvidia相关如果要重装，那也得卸载干净了再重装：\nsudo apt-get remove --purge \u0026#39;*nvidia*\u0026#39; sudo apt-get remove --purge \u0026#39;*cuda*\u0026#39; sudo apt-get autoremove sudo apt-get autoclean 如果安装了TensorRT和CuDNN，这两个也一起卸载了。\nNvidia相关驱动的安装原则 最好的实践方式是采用deb的本地安装，也就是先下载，然后再通过apt方式安装，以CUDA为例：\nwget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-ubuntu2004.pin sudo mv cuda-ubuntu2004.pin /etc/apt/preferences.d/cuda-repository-pin-600 wget https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda-repo-ubuntu2004-11-8-local_11.8.0-520.61.05-1_amd64.deb sudo dpkg -i cuda-repo-ubuntu2004-11-8-local_11.8.0-520.61.05-1_amd64.deb sudo cp /var/cuda-repo-ubuntu2004-11-8-local/cuda-*-keyring.gpg /usr/share/keyrings/ sudo apt-get update sudo apt-get -y install cuda 安装CuDNN和TensorRT也是这样，这样可以保证，驱动尽可能不会掉\nCuDNN和TensorRT的deb包需要单独下载（需要开发者账户），然后安装上面的安装解压安装即可。\n","permalink":"https://ahaknow.com/posts/know/linux-cuda-kernel-conflict/","summary":"遇到的问题是这样的： “莫名其妙，GPU驱动就没了，可能是因为update \u0026amp;\u0026amp; upgrade了一下？（ROS安装源的问题，更换到了国内之后好像没","title":"Linux：GPU环境崩了？从Nvidia驱动到TensorRT"},{"content":" 事情是这样的：\n我分别用两个硬盘装了Ubuntu系统，其中有一个硬盘A的Ubuntu是默认启动项，另一个硬盘B中的Ubuntu系统可以在启动时进行选择。\n现在我直接把硬盘A取走了，再开机，于是乎，启动不了了。。。。\n开机之后直接进入grub\u0026gt;界面。。。\n先说正题 我的想法是，能不能就在grub下实现启动（理论上肯定是可以的！），不借助所谓的Live CD或者USB环境。\n下面是具体步骤：\nGrub启动 列出所有分区：\ngrub\u0026gt; ls 这将列出所有可用的设备和分区，例如：\n(hd0) (hd0,gpt1) (hd0,gpt2) 也可能不是这样，但类似。\n查找/boot目录： 检查每个分区，找到包含 /boot 目录的分区：\ngrub\u0026gt; ls (hd0,gpt1)/ grub\u0026gt; ls (hd0,gpt2)/ 看看 /boot 目录在哪个分区下，比如是在(hd0,gpt2)下面，查看(hd0,gpt1)下面发现只有efi文件夹，这个是之后修复efi时需要挂载的；\n进入 /boot 后，应该看到类似以下的文件列表：\nvmlinuz initrd.img 也可能是：vmlinuz-linux和initramfs-linux.img之类的文件\n获取启动设备UUID： 在GRUB命令行中，可以使用 ls -l 命令来查看设备的UUID。例如：\ngrub\u0026gt; ls -l (hd0,gpt2) 这将列出分区的详细信息，包括UUID，这个UUID就可以作为设备名的标识。\n挂载启动： 加载内核并指定根文件系统：\ngrub\u0026gt; linux (hd0,gpt2)/boot/vmlinuz root=UUID=your-uuid-here grub\u0026gt; initrd (hd0,gpt2)/boot/initrd.img grub\u0026gt; boot 注意vmlinuz可能会有区别，vmlinuz或者vmlinuz-linux；initrd.img也可能有区别，但肯定是init前缀加上img后缀。\n修复Grub 注意需要确认磁盘的设备名，因为已经启动了Ubuntu，可以通过 lsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL 来查看：\nlsblk -o NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL 得到的结果类似下面这样：\nNAME FSTYPE SIZE MOUNTPOINT LABEL loop0 squashfs 63.5M /snap/core20/2015 loop1 squashfs 4K /snap/bare/5 loop2 squashfs 74.1M /snap/core22/1033 loop3 squashfs 349.7M /snap/gnome-3-38-2004/143 loop4 squashfs 64M /snap/core20/2318 loop5 squashfs 497M /snap/gnome-42-2204/141 loop6 squashfs 91.7M /snap/gtk-common-themes/1535 loop7 squashfs 40.9M /snap/snapd/20092 loop8 squashfs 12.3M /snap/snap-store/959 loop9 squashfs 38.8M /snap/snapd/21759 loop10 squashfs 74.2M /snap/core22/1380 loop11 squashfs 54.2M /snap/snap-store/558 loop12 squashfs 485.5M /snap/gnome-42-2204/126 loop13 squashfs 349.7M /snap/gnome-3-38-2004/140 nvme0n1 931.5G ├─nvme0n1p1 vfat 193M └─nvme0n1p2 ext4 931.3G / 其中的vfat理论上讲就是efi所在的位置，如果不确定，可以在一开始grub\u0026gt;命令的时候ls查看。\n创建挂载点（如果不存在）： sudo mkdir -p /boot/efi 挂载EFI分区： sudo mount /dev/nvme0n1p1 /boot/efi 验证挂载： df -h | grep /boot/efi 应该看到以下的输出：\n/dev/nvme0n1p1 200M 100M 100M 50% /boot/efi 安装GRUB到指定的设备： sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB /dev/nvme0n1 生成GRUB配置文件： sudo update-grub 重启系统： sudo reboot 答疑解惑 GRUB是什么东西，能干嘛？ GRUB（GNU GRand Unified Bootloader）是一个通用的引导加载程序，用于启动操作系统。它可以引导多种操作系统，包括Linux、Windows和BSD。GRUB的主要功能和特点包括：\n多重引导：允许用户从多个操作系统中选择要启动的系统。 配置文件：使用一个配置文件（通常是grub.cfg），用户可以在该文件中定义引导菜单、内核参数等。 命令行界面：提供一个命令行界面，用户可以在引导过程中输入命令，以便进行手动引导或修复操作系统。 模块化设计：可以通过加载模块来扩展功能，如支持不同文件系统和设备。 initramfs-linux.img是什么东西？ initramfs（initial RAM filesystem）是一个临时的根文件系统，用于在系统启动时加载必要的驱动和模块。initramfs-linux.img文件通常包含以下内容：\n内核模块：用于支持启动时所需的硬件。 启动脚本：用于初始化系统并挂载实际的根文件系统。 用户空间工具：如busybox，用于提供基本的命令行工具。 在不同的Linux发行版上，这个文件的命名可能会有所不同。例如：\n在Ubuntu上，通常命名为initrd.img-\u0026lt;kernel-version\u0026gt;，例如initrd.img-5.4.0-42-generic。 在Arch Linux上，通常命名为initramfs-linux.img。 vmlinuz-linux是什么？ vmlinuz是Linux内核的压缩版本，通常用于引导系统。文件名中的vmlinuz表示“压缩的虚拟内核”（compressed virtual kernel）。不同的Linux发行版可能使用不同的命名方式：\nvmlinuz：这是大多数发行版使用的通用名称，如Ubuntu和Debian。 vmlinuz-linux：在一些发行版中可能会使用更具体的名称，以区分不同的内核版本或配置，如Arch Linux。 总结 GRUB：引导加载程序，用于选择和启动操作系统，支持多重引导和命令行界面。 initramfs-linux.img：初始RAM文件系统，包含启动时所需的内核模块和脚本，用于加载实际的根文件系统。在不同的发行版上可能有不同的命名，如Ubuntu的initrd.img-\u0026lt;kernel-version\u0026gt;。 vmlinuz-linux：压缩的Linux内核，用于引导系统。通常在不同的发行版上有不同的命名，如Ubuntu的vmlinuz或Arch Linux的vmlinuz-linux。 ","permalink":"https://ahaknow.com/posts/know/linux-grub-boot/","summary":"事情是这样的： 我分别用两个硬盘装了Ubuntu系统，其中有一个硬盘A的Ubuntu是默认启动项，另一个硬盘B中的Ubuntu系统可以在启动时","title":"Linux：开不了机了？通过Grub启动！"},{"content":"","permalink":"https://ahaknow.com/posts/know/dev-mutex/","summary":"","title":"开发实战：“锁”的机制"},{"content":" 需要对Linux上的固态进行一个读写测试，我知道是可以 dd 方式直接测试的，但是 dd 只能顺序读写，无法随机读写，因此这里再提供另一种方法。\n在 Linux 上使用 dd 工具可以直接测试硬盘的读写速度\n使用 dd 测试读写速度 写入测试 可以使用 dd 命令生成一个测试文件来测量写入速度。例如，使用 1M 的块大小生成一个 1GB 的测试文件：\ndd if=/dev/zero of=/path/to/your/testfile bs=1M count=1024 oflag=direct 这个命令解释如下：\nif=/dev/zero：从 /dev/zero 读取数据（生成零字节数据）。 of=/path/to/your/testfile：输出到指定的测试文件。 bs=1M：块大小为 1MB。 count=1024：写入 1024 个块，总计 1GB。 oflag=direct：使用直接 I/O，不经过操作系统缓存。 读取测试 可以使用 dd 命令从生成的测试文件中读取数据来测量读取速度：\ndd if=/path/to/your/testfile of=/dev/null bs=1M count=1024 iflag=direct 这个命令解释如下：\nif=/path/to/your/testfile：从指定的测试文件中读取数据。 of=/dev/null：将数据丢弃。 bs=1M：块大小为 1MB。 count=1024：读取 1024 个块，总计 1GB。 iflag=direct：使用直接 I/O，不经过操作系统缓存。 在文件 I/O 操作中，直接 I/O 和缓存 I/O 是两种不同的操作模式。\n缓存 I/O（Buffered I/O） 默认情况下，操作系统在进行文件读写时会使用缓存 I/O，即通过系统的页缓存（page cache）来缓冲数据。这种方式的优点是可以提高文件操作的速度，因为许多读写操作实际上是在内存中进行的，减少了与磁盘的直接交互次数。但也有一些缺点：\n读写操作可能被系统缓存所影响，导致实际磁盘性能的测量不准确。 大量数据的缓存操作会消耗系统内存，可能导致其他应用程序的内存不足。 直接 I/O（Direct I/O） 直接 I/O 是绕过操作系统缓存，直接从磁盘进行读写操作的一种模式。在 Linux 上，可以通过 O_DIRECT 标志来实现直接 I/O。使用直接 I/O 有以下优点和缺点：\n优点 准确的性能测量：绕过操作系统缓存，直接与磁盘进行读写操作，可以更准确地反映磁盘的实际性能。 减少内存使用：不使用系统缓存，减少了内存消耗，对内存资源紧张的系统有益。 适合某些应用场景：例如数据库系统，直接 I/O 可以提供更稳定的性能，因为这些应用通常有自己的缓存机制，不需要操作系统的缓存。 缺点 较高的延迟：每次读写操作都直接访问磁盘，可能会导致较高的延迟，尤其是在小块数据的随机读写操作中。 复杂的内存对齐要求：直接 I/O 通常要求缓冲区和文件偏移都对齐到文件系统块的大小，增加了编程复杂性。 iflag=direct 的作用 在 dd 命令中使用 iflag=direct（输入标志）或 oflag=direct（输出标志）选项，可以启用直接 I/O 模式。例如：\ndd if=/path/to/your/testfile of=/dev/null bs=1M iflag=direct 上述命令表示：\nif=/path/to/your/testfile：从指定的文件中读取数据。 of=/dev/null：将数据丢弃。 bs=1M：块大小为 1MB。 iflag=direct：使用直接 I/O 模式进行读取操作。 在这个模式下，数据读写操作不会使用系统缓存，而是直接从磁盘进行读写。这有助于更准确地测量硬盘的实际读写性能。\ndd 的优缺点 优点 简单易用：dd 命令简单直接，易于记忆和使用。 无需额外安装：dd 是大多数 Linux 发行版的默认工具，通常不需要额外安装。 缺点 缺乏灵活性：dd 不支持复杂的 I/O 模式和参数调整，不能模拟多线程、多进程等高级 I/O 测试场景。 报告信息有限：dd 提供的测试结果信息有限，主要是简单的速度统计，缺乏详细的性能分析数据，如 IOPS、延迟等。 无法进行随机 I/O 测试：dd 主要用于顺序读写测试，不适合进行随机读写性能测试。 fio 是一个强大的 I/O 性能测试工具，支持多种 I/O 引擎和参数配置，非常适合用于性能测试和分析。\n安装 fio 使用包管理工具进行安装：\n对于基于 Debian 的系统 (如 Ubuntu)：\nsudo apt-get install fio 对于基于 Red Hat 的系统 (如 CentOS)：\nsudo yum install fio 使用 fio 测试 4K 读写速度 安装完成后，可以使用以下命令来测试 4K 随机读写速度：\n4K 随机读取测试 创建一个 read.fio 文件，内容如下：\n[global] name=randread ioengine=libaio iodepth=1 rw=randread bs=4k direct=1 size=1G numjobs=1 runtime=60 group_reporting [randread] filename=/path/to/your/testfile 执行测试命令：\nfio read.fio 4K 随机写入测试 创建一个 write.fio 文件，内容如下：\n[global] name=randwrite ioengine=libaio iodepth=1 rw=randwrite bs=4k direct=1 size=1G numjobs=1 runtime=60 group_reporting [randwrite] filename=/path/to/your/testfile 执行测试命令：\nfio write.fio 解释测试参数 ioengine=libaio：使用异步 I/O 引擎。 iodepth=1：I/O 队列深度为 1。 rw=randread 或 rw=randwrite：分别表示随机读取和随机写入。 bs=4k：块大小为 4KB。 direct=1：使用直接 I/O，不经过操作系统缓存。 size=1G：测试文件的大小为 1GB。 numjobs=1：并发作业数为 1。 runtime=60：测试运行时间为 60 秒。 group_reporting：汇总报告结果。 结果分析 测试结果将会显示 IOPS（每秒输入输出操作数）和吞吐量（MB/s），以及延迟等信息。4K 随机读写速度通常用于衡量硬盘在处理小文件时的性能，这是固态硬盘性能的重要指标之一。一般来说，4K 随机读写性能越高，固态硬盘在日常使用中的表现也就越好。\n修改 fio 配置文件以测试 1M 读写速度 要测试 1M 读写速度，只需要修改 fio 配置文件中的块大小参数 bs 为 1M。\n1M 随机读取测试 创建或修改 read_1M.fio 文件，内容如下：\n[global] name=randread ioengine=libaio iodepth=1 rw=randread bs=1M direct=1 size=1G numjobs=1 runtime=60 group_reporting [randread] filename=/path/to/your/testfile 执行测试命令：\nfio read_1M.fio 1M 随机写入测试 创建或修改 write_1M.fio 文件，内容如下：\n[global] name=randwrite ioengine=libaio iodepth=1 rw=randwrite bs=1M direct=1 size=1G numjobs=1 runtime=60 group_reporting [randwrite] filename=/path/to/your/testfile 执行测试命令：\nfio write_1M.fio fio 的特点 灵活性高：fio 支持多种 I/O 模式和参数调整，可以模拟复杂的 I/O 场景，如随机读写、多线程、多进程等。 详细报告：fio 提供详细的性能分析报告，包括 IOPS、延迟、带宽等多种性能指标。 适用范围广：fio 可以测试多种存储设备和文件系统，适用于更广泛的性能测试需求。 为什么 4K 读写特别慢？ 4K 随机读写速度通常比大块读写速度慢，原因如下：\n数据块大小： 4K 是一个相对较小的数据块，每次操作处理的数据量小，导致需要更多的 I/O 操作来完成同样的数据传输量。这增加了 IOPS（每秒输入输出操作数）的负担。\n寻址开销： 小数据块的随机读写会导致磁盘进行频繁的寻址操作，增加了寻道时间和延迟。在机械硬盘（HDD）中，这个问题更为显著，但在固态硬盘（SSD）中，虽然没有机械臂移动，内部的地址映射和控制器处理也会增加延迟。\n文件系统和控制器效率： 文件系统和硬盘控制器在处理小数据块时，效率可能会降低。SSD 的控制器通常为大块数据优化，小块数据的处理会增加控制器的工作负担，导致性能下降。\n缓存和写入放大： 现代 SSD 通常有缓存机制，大块数据的顺序读写更容易利用缓存优化性能。而小块数据的随机读写会导致缓存命中率低，无法充分利用缓存优势。此外，小块数据写入会导致 SSD 内部的写入放大效应，增加额外的写入操作量，进一步降低性能。\n通过测试 1M 数据块的读写速度，可以更好地了解 SSD 在处理大块数据时的性能表现。这种测试通常显示更高的吞吐量和较低的延迟，因为大块数据传输减少了I/O 操作数，提高了整体效率。\n使用 fio 进行多线程读写测试 fio 支持多线程读写测试，这可以用来模拟实际应用场景中的并发 I/O 操作，测试磁盘在高并发情况下的性能表现。下面是一个多线程读写测试的配置示例：\n多线程随机读取测试 创建一个 randread_multi.fio 文件，内容如下：\n[global] name=randread ioengine=libaio iodepth=32 rw=randread bs=4k direct=1 size=1G numjobs=4 runtime=60 group_reporting [randread] filename=/path/to/your/testfile 执行测试命令：\nfio randread_multi.fio 多线程随机写入测试 创建一个 randwrite_multi.fio 文件，内容如下：\n[global] name=randwrite ioengine=libaio iodepth=32 rw=randwrite bs=4k direct=1 size=1G numjobs=4 runtime=60 group_reporting [randwrite] filename=/path/to/your/testfile 执行测试命令：\nfio randwrite_multi.fio 配置参数解释 ioengine=libaio：使用异步 I/O 引擎。 iodepth=32：I/O 队列深度为 32。 rw=randread 或 rw=randwrite：分别表示随机读取和随机写入。 bs=4k：块大小为 4KB。 direct=1：使用直接 I/O，不经过操作系统缓存。 size=1G：测试文件的大小为 1GB。 numjobs=4：并发作业数为 4，表示有 4 个线程同时进行 I/O 操作。 runtime=60：测试运行时间为 60 秒。 group_reporting：汇总报告结果。 多线程读写测试的性能评估 多线程读写测试可以帮助评估以下性能指标：\nIOPS (每秒输入输出操作数)：衡量存储设备在多线程并发情况下的处理能力。 带宽 (MB/s)：评估存储设备在并发读写操作下的数据传输速度。 延迟 (Latency)：分析并发 I/O 操作对读写延迟的影响，特别是高并发下的延迟分布。 资源利用率：评估存储设备在多线程环境中的资源利用效率，如 CPU 和内存占用。 dd 只能顺序读写的原因 dd 是一个简单的命令行工具，设计用于执行直接的数据复制操作。以下是 dd 只能进行顺序读写的原因：\n命令设计初衷：dd 的设计初衷是进行数据备份和恢复操作，主要用于顺序读写整个块设备或文件。 缺乏随机读写支持：dd 命令本身没有内置的机制来实现随机读写操作。它按照指定的块大小和顺序读取或写入数据，无法像 fio 一样指定随机读写模式。 简单性和灵活性限制：dd 的设计是为了简单直接地完成数据复制任务，因此缺乏 fio 那样的灵活性和复杂的 I/O 模式支持。 ","permalink":"https://ahaknow.com/posts/know/linux-test-ssd/","summary":"需要对Linux上的固态进行一个读写测试，我知道是可以 dd 方式直接测试的，但是 dd 只能顺序读写，无法随机读写，因此这里再提供另一种方法。 在 Linux 上使","title":"Linux：测试硬盘读写速度"},{"content":"我是才知道：\n贾维斯的全称，Just Another Rather Very Intelligent System（只是一个相当聪明的智能系统）；\n伊迪斯的全称，Even dead,I\u0026rsquo;m the hero（即便我死了，我也是英雄）；\n所以呢，我和我的AI系统一起讨论了一番，最终给他赋予了“新生”！\nM.E.R.L.I.N. - “Mindful Entity for Research, Learning, and Intelligent Neurons”（用于研究、学习，以及拥有智能神经元的有意识实体）\n所以啊，我也有自己的“贾维斯”啦，他叫Merlin，梅林～\n目前他还没有身体啊，还一个具身智能，说不定过几年就有了呢～\n","permalink":"https://ahaknow.com/posts/know/m.e.r.l.i.n./","summary":"我是才知道： 贾维斯的全称，Just Another Rather Very Intelligent System（只是一个相当聪明的智能系统）； 伊迪斯的全称，Even dead,I\u0026rsquo;m the hero（即便我死了，我也是","title":"你好～ Merlin"},{"content":" 就是代码写好了，肯定不能发源码出去，肯定发的是可执行文件，或者就依赖和可执行文件都打包好～\n如果是Github管理的话，甚至还要考虑一下Release管理。\n因为习惯了CMake，所以直观地想到使用CMakeLists.txt来配置。举例如下：\ncmake_minimum_required(VERSION 3.10) project(MoInfo2GSBag) set(CMAKE_INSTALL_PREFIX \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/../install\u0026#34; CACHE PATH \u0026#34;Install path prefix\u0026#34; FORCE) option(BUILD_SHARED_LIBS \u0026#34;Build libraries as shared libraries\u0026#34; ON) set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_STANDARD_REQUIRED True) find_package(PCL REQUIRED) find_package(OpenCV REQUIRED) include_directories( ${OpenCV_INCLUDE_DIRS} ${PCL_INCLUDE_DIRS} ) # add subdirectories add_subdirectory(AI) add_subdirectory(RoadSeg) ## -- for MoInfo2GSBag -- ## find_package(spdlog REQUIRED) # Find FFmpeg components find_package(PkgConfig REQUIRED) pkg_check_modules(AVCODEC REQUIRED libavcodec) pkg_check_modules(AVFORMAT REQUIRED libavformat) pkg_check_modules(SWSCALE REQUIRED libswscale) pkg_check_modules(AVUTIL REQUIRED libavutil) include_directories( ${AVCODEC_INCLUDE_DIRS} ${AVFORMAT_INCLUDE_DIRS} ${SWSCALE_INCLUDE_DIRS} ${AVUTIL_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/include ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/proto /usr/include ) link_directories( ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/lib ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/external/platform_sdk/lib ) add_library(metoak_proto_gsbag ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/proto/metoak_image_msg.pb.cc ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/proto/metoak_image_msg.pb.h ) target_link_libraries(metoak_proto_gsbag ${PROTOBUF_LIBRARIES} ) add_executable(MoInfo2GSBag moinfo_to_gsbag.cpp) target_link_libraries(MoInfo2GSBag spdlog::spdlog ${AVCODEC_LIBRARIES} ${AVFORMAT_LIBRARIES} ${SWSCALE_LIBRARIES} ${AVUTIL_LIBRARIES} ${OpenCV_LIBS} ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/lib/libsqlcipher.so ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/lib/libgsbag.so ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/lib/libcommon.so ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/lib/libgaclog.so ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/lib/libgacbag_storage.so ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/lib/libgacbag_cpp.so ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/lib/libgacbag_serializer.so protobuf metoak_proto_gsbag lz4 AI4FS RoadSeg ) ## -- Install -- ## install(TARGETS MoInfo2GSBag DESTINATION bin) install(TARGETS metoak_proto_gsbag AI4FS RoadSeg DESTINATION lib) install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/lib/ DESTINATION lib FILES_MATCHING PATTERN \u0026#34;*.so*\u0026#34;) # CPack configuration set(CPACK_GENERATOR \u0026#34;TGZ;DEB\u0026#34;) set(CPACK_PACKAGE_NAME \u0026#34;MoInfo2GSBag\u0026#34;) set(CPACK_PACKAGE_VERSION \u0026#34;1.0.0\u0026#34;) set(CPACK_PACKAGE_FILE_NAME \u0026#34;${CPACK_PACKAGE_NAME}-${CPACK_PACKAGE_VERSION}\u0026#34;) set(CPACK_PACKAGE_CONTACT \u0026#34;ChangKunYang \u0026lt;changkun.yang@metoak.net\u0026gt;\u0026#34;) set(CPACK_DEBIAN_PACKAGE_DEPENDS \u0026#34;libavcodec, libavformat, libswscale, libavutil, protobuf, spdlog\u0026#34;) set(CPACK_PACKAGE_DESCRIPTION \u0026#34;MoInfo2GSBag tool with all dependencies included\u0026#34;) set(CPACK_PACKAGE_DESCRIPTION_SUMMARY \u0026#34;A tool to process MoInfo2GSBag data with all required libraries included\u0026#34;) include(CPack) 其中的set(CMAKE_INSTALL_PREFIX \u0026quot;${CMAKE_CURRENT_BINARY_DIR}/../install\u0026quot; CACHE PATH \u0026quot;Install path prefix\u0026quot; FORCE)就是用来配置install的位置的，如果没有设置，默认是/usr/local，这时候使用cmake install是需要sudo权限的。\n其次，还需要注意安装的lib要全！\n注意这种写法：\ninstall(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/MoBag/lib/ DESTINATION lib FILES_MATCHING PATTERN \u0026#34;*.so*\u0026#34;) 将所有的文件都移过来，包括软链接的文件。\n然后通过cmake install就可以了，实际使用时再临时链接一下动态库，比如：\n# 在目标机器上 cd /path/to/destination/install # 设置 LD_LIBRARY_PATH 环境变量，以便找到所需的库 export LD_LIBRARY_PATH=$(pwd)/lib:$LD_LIBRARY_PATH # 运行可执行文件 ./bin/MoInfo2GSBag CPack 其实install已经够用了，更高级的操作的是使用CPack进行打包管理，就是直接cpack指令就能实现。\n特别注意一下，所有的CPack变量需要在include(CPack)之前设置，这样CPack能够正确读取这些变量。\nCPack的配置说明 # CPack configuration set(CPACK_GENERATOR \u0026#34;TGZ;DEB\u0026#34;) set(CPACK_PACKAGE_NAME \u0026#34;MoInfo2GSBag\u0026#34;) set(CPACK_PACKAGE_VERSION \u0026#34;1.0.0\u0026#34;) set(CPACK_PACKAGE_FILE_NAME \u0026#34;${CPACK_PACKAGE_NAME}-${CPACK_PACKAGE_VERSION}\u0026#34;) set(CPACK_PACKAGE_CONTACT \u0026#34;ChangKunYang \u0026lt;changkun.yang@metoak.net\u0026gt;\u0026#34;) set(CPACK_DEBIAN_PACKAGE_DEPENDS \u0026#34;libavcodec, libavformat, libswscale, libavutil, protobuf, spdlog\u0026#34;) set(CPACK_PACKAGE_DESCRIPTION \u0026#34;MoInfo2GSBag tool with all dependencies included\u0026#34;) set(CPACK_PACKAGE_DESCRIPTION_SUMMARY \u0026#34;A tool to process MoInfo2GSBag data with all required libraries included\u0026#34;) include(CPack) ","permalink":"https://ahaknow.com/posts/know/dev-cpack-release/","summary":"就是代码写好了，肯定不能发源码出去，肯定发的是可执行文件，或者就依赖和可执行文件都打包好～ 如果是Github管理的话，甚至还要考虑一下Rel","title":"开发实战：CMake实现可执行文件的安装与打包分发"},{"content":"一些实用的小工具 获取时间C++片段 // Unix时间戳 int64_t getTimestamp() { auto now = std::chrono::system_clock::now(); auto timestamp = std::chrono::time_point_cast\u0026lt;std::chrono::nanoseconds\u0026gt;(now).time_since_epoch().count(); return static_cast\u0026lt;int64_t\u0026gt;(timestamp); } 方便阅读的版本：年_月_日_时_分_秒\nstd::string getReadableTimestamp() { // 获取当前时间点 auto now = std::chrono::system_clock::now(); // 转换为 time_t 类型 std::time_t now_c = std::chrono::system_clock::to_time_t(now); // 将 time_t 类型转换为 tm 结构体 std::tm now_tm = *std::localtime(\u0026amp;now_c); // 使用 stringstream 生成格式化的时间字符串 std::stringstream ss; ss \u0026lt;\u0026lt; std::put_time(\u0026amp;now_tm, \u0026#34;%Y_%m_%d_%H_%M_%S\u0026#34;); return ss.str(); } ","permalink":"https://ahaknow.com/posts/know/coding-inspiration-moments/","summary":"一些实用的小工具 获取时间C++片段 // Unix时间戳 int64_t getTimestamp() { auto now = std::chrono::system_clock::now(); auto timestamp = std::chrono::time_point_cast\u0026lt;std::chrono::nanoseconds\u0026gt;(now).time_since_epoch().count(); return static_cast\u0026lt;int64_t\u0026gt;(timestamp); } 方便阅读的版本：年_月_日_时_分_秒 std::string getReadableTimestamp() { // 获取当前时间点 auto","title":"编程灵感时刻"},{"content":" 时隔多年再次坐飞机，还没起飞呢就尴尬了。。。\n“值机”是啥意思？\n感觉自己跟个傻子一样。。。\n提前半小时到机场就可以的吧？😄\n直接打车去机场好了～\n……\n半个小时了，怎么还堵着呢！\n失策了，感觉自己在🐌背上。。。\n完犊子了，赶不上了！\n改签？！\n怎么这么贵！多花了一倍钱？！！！\n以上，为一次8点30飞机，8点20才到（下车的时候还被司机给耽误了时间，应该是他结束行程的时候手动输入高速费用一起从订单结，结果自己不会弄，非要我手机支付。。。）然后路上才意识到，至少提前50分钟到达机场（因为提前45分钟就不能办理登机牌了，就是所谓的“值机”），于是改了签，改签的时候发现，扣了80%的费用，相当于直接机票打水漂了。\n当时粗略算了一下，退票重买可能比改签都便宜。。。😂\n改签的那会，想到了以前本科的时候，坐绿皮火车去贵州，没赶上，**忘记了那时的是改签了还是重买了，跟火车站柜员还吵了一架，后来是隔了两小时无座出发，整整24小时，晚上就是坐着行李箱上眯瞪着的，路上跟一个回家的学生聊了不少，没赶上车的那一瞬间是真的懊悔，难受，生气啊！**后面其实还有两次是回家没赶上火车，原因是之前都是骑小黄车一路狂飙去的火车站，感觉时间在我掌控，40分钟的车程，我预留10分钟足以！但是坐地铁就完全不在自己的控制下了，导航预计半小时，我留了40分钟，显示是低估了地铁进出站的时间，那次好像是之前改签过一次，没法再改签了，只能作废！我好像又去柜台那里去争论了，柜员人员态度很强硬，整体也很不愉快。记忆都有点错乱了，但关键细节还记得，一个是改签票不能再改，只能作废，柜员是不会搭理你的，你再吵再闹只可能结果是被警察拖走。。。另一个就是导航的时候不可信，车票的发票时间最好加上半小时，哦，想起来了，去贵州那次是因为13点记成了3点导致错过的，路上还悠哉悠哉呢，到车站的时候傻眼了\n最近还有一次，从北京回家，也是没想到路上走路的时候会花费这么多，18:55的车票，我17:50出发，虽然导航地铁显示40分钟，但是稍微磨蹭一下，还要走到地铁站，10分钟预留肯定是不够的，而且当时是返乡高峰期，愣是没想到从地铁出来到火车站还有很长的一段距离，以及三大层楼梯。。。当时是一路冲刺，以及插队😂，再狂奔，差点就直接从轧机跳过去了，还好最后给我检了票，在发车前一分钟冲上车了。真的是。。。绝了！\n今天这次飞机没赶上，下一班飞机又晚点1个多小时（感觉就是在打我脸😂）\n飞机机票时间减去1小时（50分钟以上，取整好记忆）作为心里预估的时间，比如8点半的机票，那么心里的认知就是7点半就得到，那么6点就要起床，出发～\n火车票时间减去半小时（20分钟以上，也是取整好记忆）作为心里预估时间，比如18点55的车票，那么晚上6点半就要到火车站，那么5点20就要出发！\n还是觉得在机场候机真的浪费时间😂，去深圳还是会考虑卧铺滴～\n11点21 🛫\n提前10分钟关闭机门，11点10分的时候就进不了飞机了。\n正好坐在飞机机翼上，靠窗的有一个调节按钮，可以调整窗户明暗，有点意思！\n座位上有小视频可以看电影，听音乐，打游戏😂，不过我还是戴着我的降噪吧哈哈哈哈，然后去听课～\n","permalink":"https://ahaknow.com/posts/life/smart-an-airplane-experience/","summary":"时隔多年再次坐飞机，还没起飞呢就尴尬了。。。 “值机”是啥意思？ 感觉自己跟个傻子一样。。。 提前半小时到机场就可以的吧？😄 直接打车去机场好了～ …","title":"常识：记录一次机票改签😅"},{"content":" 在写C++工程的时候，习惯性的是将头文件与其实现分开编写的。\n今天被问到了这个问题：\n“在写C++代码的时候，将函数实现直接写在头文件里，会怎么样，有什么不好的地方？为什么要将函数的实现单独写在源文件”\n我的第一反应想到的，我实际开发时就这样做的，为啥这样做呢？编译比较快？编译比较省事？……\n但似乎没有一个透彻的理解，需要在这里重新梳理一下。\n从代码编译的角度来重新理解（CMake进行编译系统管理的时候，也有一套比较好的实践方式）\nC++编译角度的理解 在C++编程中，编译过程通常包括预处理、编译、汇编和链接这几个阶段。每个阶段都在为最终生成可执行文件做准备，而在这些过程中，头文件和源文件的角色和影响各不相同。\n1. 预处理阶段 在这一阶段，预处理器处理源代码中的预处理指令，如#include、#define、条件编译指令#ifdef、#ifndef等。特别是#include指令，它会将头文件的内容直接包含到源文件中。如果没有适当的头文件保护，如#ifndef、#define、#endif，头文件可能被重复包含，导致预处理后的源文件中出现重复的内容。\n2. 编译阶段 在这一阶段，编译器将预处理后的源代码（现在已经包含了头文件中的内容，就是已经展开了所有的#include等）转换成汇编代码。如果实现代码（函数定义等）包含在头文件中，且头文件被多个源文件包含，那么就会导致：\n代码膨胀且编译时间增加：每个源文件（.cpp文件）在编译时都会包含它使用的所有头文件（.h文件），导致生成的目标文件体积增大。如果头文件中包含了大量的函数实现，每次这些头文件被包含时，这些代码都需要被重新编译。因此，如果多个源文件包括同一个包含大量实现的头文件，这些源文件每次编译时都会重新编译头文件中的实现代码，从而显著增加整体编译时间。并且，每次头文件被修改，所有包含该头文件的源文件都必须重新编译，哪怕是一个小改动，也会导致大量的重复编译工作。\n多重定义错误（在链接阶段发生）：如果头文件中包含函数或变量的实现（而不是仅仅声明），并且这个头文件被多个源文件包括，那么每个源文件都会尝试定义这些函数或变量。在后续链接这些源文件生成可执行文件或库文件时，链接器会发现同一个函数或变量被定义了多次，这会导致链接错误，具体表现为“multiple definition”错误。\n3. 汇编阶段 编译器生成的汇编代码被转换成机器可执行的代码，形成目标文件。这一阶段主要是编译器的工作，不涉及头文件和源文件的分离问题。\n4. 链接阶段 链接器将所有的目标文件以及所需的库文件链接成一个单独的可执行文件或库文件。如果多个目标文件包含同一个全局符号（函数或变量）的定义，链接器会检测到多重定义错误。这通常是因为头文件中包含了不应该存在的定义，并被多个源文件包括所导致。可以使用inline关键字或将模板定义放在头文件中可以避免多重定义问题，因为内联函数和模板被设计为可以在多个文件中安全地重复定义。\n最佳实践 函数声明与实现分离：在头文件中只声明函数和类，而在源文件中提供具体的实现。这是最基本的规则，有助于减少编译时间、避免多重定义问题，并提高代码的可读性和维护性。 使用inline关键字：对于需要在头文件中定义的小函数，可以使用inline关键字。inline函数通知编译器每次调用函数时尝试将函数体插入到每个调用点，以减少函数调用的开销。不过，滥用inline也可能导致代码膨胀。 模板实现：由于模板的特殊性，模板定义通常包括在头文件中。但应当小心控制模板实现的复杂度，避免导致所有上述问题。 补充 在 C++ 中，使用模板和 inline 函数可以提高代码的可重用性和效率。\n以下是简单的举例说明：\n模板 模板是 C++ 中实现泛型编程的工具，允许编写与数据类型无关的代码。可以创建一个泛型函数或类来处理不同类型的数据，比如用于交换两个变量的值：\ntemplate\u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { T temp = a; a = b; b = temp; } int main() { int x = 10, y = 20; swap(x, y); // 使用 int 类型 std::cout \u0026lt;\u0026lt; \u0026#34;x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; y: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; double m = 1.1, n = 2.2; swap(m, n); // 使用 double 类型 std::cout \u0026lt;\u0026lt; \u0026#34;m: \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34; n: \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，swap 函数是一个模板，可以接受任何类型的参数。可以使用用 int 类型的变量调用它，也可以使用用 double 类型的变量调用它，展示了模板的灵活性和通用性。\n2. inline 函数 inline 函数是一种在编译时将函数体插入到每个调用点的函数，用以减少函数调用的开销。inline 指示编译器尽可能地将函数的定义插入到每个调用该函数的地方。比如用于计算两数之和的例子：\ninline int add(int a, int b) { return a + b; } int main() { int result = add(5, 3); // 直接在这里插入 add 函数的体 std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，add 函数被定义为 inline。这意味着在编译时，add(5, 3) 可能会被替换为 5 + 3，从而避免了函数调用的开销。这种方式特别适合于小而频繁调用的函数。\n注意事项 模板 通常定义在头文件中，因为它们需要在编译时对每个用到模板的类型进行实例化。 inline 函数 也应该在头文件中定义，以确保编译器在每个调用点都能看到 inline 函数的定义，这是使函数内联化的先决条件。 通过使用模板和 inline 函数，可以编写出更高效、更灵活的 C++ 程序。不过也需要注意：滥用 inline 可能会导致程序的最终二进制体积增大，而滥用模板可能会增加编译时间。\n","permalink":"https://ahaknow.com/posts/know/dev-header-source/","summary":"在写C++工程的时候，习惯性的是将头文件与其实现分开编写的。 今天被问到了这个问题： “在写C++代码的时候，将函数实现直接写在头文件里，会怎么","title":"开发实战：为什么要将函数实现与头文件分离"},{"content":" tar 是一个广泛使用的 Unix/Linux 命令行工具，用于创建、维护、修改以及提取 tar 文件。\ntar 文件通常是文件档案的集合，而 tar 本身是 Tape Archive 的缩写，起初是用来将数据备份到磁带上。下面将介绍 tar 命令的基本用法，包括如何用它来压缩和解压缩文件，以及常见的压缩格式如 gz 的含义。\ntar 的基本用法 创建 tar 归档： 使用 -c 选项来创建一个新的归档文件。通常与 -f 选项结合使用，后者指定归档文件的名称。\ntar -cf archive.tar file1 file2 dir1 这条命令会创建一个名为 archive.tar 的归档文件，包含了 file1, file2 以及整个 dir1 目录。\n查看 tar 归档内容： 使用 -t 选项来查看归档中的内容，不会进行解压。\ntar -tf archive.tar 解压 tar 归档： 使用 -x 选项来解压归档。\ntar -xf archive.tar 这条命令会将 archive.tar 中的内容解压到当前目录。\n使用压缩 tar 支持多种压缩方式，如 gzip、bzip2 和 xz。压缩和解压缩归档可以减少存储空间和提高文件传输速度。\ngzip 压缩 (gz): -z 选项让 tar 使用 gzip 来压缩。扩展名通常为 .tar.gz 或 .tgz。\ntar -czf archive.tar.gz file1 dir1 解压 gzip 压缩的 tar 归档：\ntar -xzf archive.tar.gz bzip2 压缩 (bz2): -j 选项让 tar 使用 bzip2 压缩。扩展名为 .tar.bz2。\ntar -cjf archive.tar.bz2 file1 dir1 解压 bzip2 压缩的 tar 归档：\ntar -xjf archive.tar.bz2 xz 压缩 (xz): -J 选项让 tar 使用 xz 压缩。扩展名为 .tar.xz。\ntar -cJf archive.tar.xz file1 dir1 解压 xz 压缩的 tar 归档：\ntar -xJf archive.tar.xz 小技巧 使用 -v (verbose) 选项可以显示 tar 处理的详细信息，这对于调试或了解进度很有用。 使用 -p 选项（preserve permissions）来保留文件权限。 使用 --exclude 选项来在归档时排除特定的文件或目录。 ","permalink":"https://ahaknow.com/posts/know/linux-tar-usage/","summary":"tar 是一个广泛使用的 Unix/Linux 命令行工具，用于创建、维护、修改以及提取 tar 文件。 tar 文件通常是文件档案的集合，而 tar 本身是 Tape Archive 的缩写，起初是用来将数据备份到","title":"Linux：打包压缩相关的基本使用"},{"content":" 第一次接触Protobuf，遇到了系统版本与编译文件版本不统一的情况，以优先解决问题的考虑出发，考虑先把版本统一，验证代码是否可行，之后再来研究版本更新的问题。\n在Linux上安装指定版本的Protobuf（比如版本3.19.6）可以通过下载源代码并从源代码编译来完成。\n安装依赖： 在编译Protobuf之前，确保安装了所有必要的依赖。对于大多数Linux发行版，需要安装autoconf、automake、libtool、curl、make、g++和unzip。使用以下命令安装这些依赖（以Ubuntu为例）：\nsudo apt update sudo apt install autoconf automake libtool curl make g++ unzip 下载Protobuf源代码： 从Protobuf GitHub releases页面下载需要的版本的源码。例如，要下载3.19.6版本，可以使用以下命令：\ncurl -OL https://github.com/protocolbuffers/protobuf/releases/download/v3.19.6/protobuf-all-3.19.6.tar.gz 解压源代码： 使用以下命令解压下载的文件：\ntar -zxvf protobuf-all-3.19.6.tar.gz 然后进入解压后的目录：\ncd protobuf-3.19.6 编译和安装： 在源代码目录中，运行以下命令来配置、编译和安装Protobuf：\n./configure make make check sudo make install sudo ldconfig # 刷新共享库缓存 ./configure：配置安装选项。 make：编译库和编译器。 make check：运行单元测试，确保一切正常（这一步是可选的，但建议执行）。 sudo make install：将库和二进制文件安装到默认系统位置。 sudo ldconfig：更新系统的库缓存，确保新安装的库可以被系统找到。 验证安装： 安装完成后，可以通过运行以下命令来验证protoc的版本：\nprotoc --version 输出应该显示libprotoc 3.19.6，这表明已经成功安装了指定版本的Protobuf。\n通过这些步骤，可以在Linux系统上安装任何指定版本的Protobuf。\n如果需要安装到一个非标准的位置（例如，避免与系统库冲突），可以在./configure步骤中添加--prefix=/your/custom/path参数来指定安装路径。\n","permalink":"https://ahaknow.com/posts/know/note-install-protobuf/","summary":"第一次接触Protobuf，遇到了系统版本与编译文件版本不统一的情况，以优先解决问题的考虑出发，考虑先把版本统一，验证代码是否可行，之后再来","title":"Protobuf：安装指定版本"},{"content":"创建一个具有限制权限的用户，同时确保这个用户不能访问其他用户的文件或目录，可以通过以下步骤进行：\n1. 创建新用户 使用useradd命令创建一个新用户。可以指定用户的主目录、默认shell等。例如，创建一个名为newuser的用户：\nsudo useradd -m newuser -s /bin/bash 这里-m选项表示创建用户的主目录，-s指定用户的默认shell。\n2. 设置密码 为新用户设置密码：\nsudo passwd newuser 系统会提示你输入和确认密码。\n3. 限制用户权限 避免将用户添加到sudo或root组来限制其权限。你可以通过不将用户添加到这些组来保持其权限尽可能低。\n4. 设置文件和目录权限 确保其他用户的目录不对新用户开放写权限。可以设置目录权限使其仅对所有者或特定组开放：\n设置其他用户的主目录权限，禁止新用户访问：\nsudo chmod o-rwx /home/otheruser 这里o-rwx表示删除其他用户（not group or owner）的读、写和执行权限。\n你也可以更改其他用户目录的组并限制访问权限：\nsudo chgrp -R somegroup /home/otheruser sudo chmod -R o-rwx /home/otheruser 5. 使用文件系统访问控制列表（ACL） 如果需要更细粒度的权限控制，可以使用ACL来设置谁可以访问特定的文件和目录：\nsudo setfacl -m u:newuser:rx /some/otheruser/directory 这里，setfacl命令设置newuser只有读和执行权限到/some/otheruser/directory。\n","permalink":"https://ahaknow.com/posts/know/linux-create-user/","summary":"创建一个具有限制权限的用户，同时确保这个用户不能访问其他用户的文件或目录，可以通过以下步骤进行： 1. 创建新用户 使用useradd命令创建一个新","title":"Linux：创建具有权限限制的新用户"},{"content":" 遇到了Linux新的内核启动卡死，老内核正常运行，索性就启动不了内核进行删除。\n1. 查看当前运行的内核 在终端运行以下命令：\nuname -r 会得到下面这样的信息：\n5.15.0-97-generic 2. 列出所有安装的内核 列出所有已安装的内核：\ndpkg --list | grep linux-image 这个命令将显示所有已安装的Linux内核包，如下所示：\nrc linux-image-5.15.0-100-generic 5.15.0-100.110~20.04.1 amd64 Signed kernel image generic rc linux-image-5.15.0-101-generic 5.15.0-101.111~20.04.1 amd64 Signed kernel image generic rc linux-image-5.15.0-102-generic 5.15.0-102.112~20.04.1 amd64 Signed kernel image generic ii linux-image-5.15.0-105-generic 5.15.0-105.115~20.04.1 amd64 Signed kernel image generic rc linux-image-5.15.0-67-generic 5.15.0-67.74~20.04.1 amd64 Signed kernel image generic rc linux-image-5.15.0-84-generic 5.15.0-84.93~20.04.1 amd64 Signed kernel image generic rc linux-image-5.15.0-86-generic 5.15.0-86.96~20.04.1 amd64 Signed kernel image generic rc linux-image-5.15.0-87-generic 5.15.0-87.97~20.04.1 amd64 Signed kernel image generic rc linux-image-5.15.0-88-generic 5.15.0-88.98~20.04.1 amd64 Signed kernel image generic rc linux-image-5.15.0-89-generic 5.15.0-89.99~20.04.1 amd64 Signed kernel image generic rc linux-image-5.15.0-91-generic 5.15.0-91.101~20.04.1 amd64 Signed kernel image generic rc linux-image-5.15.0-92-generic 5.15.0-92.102~20.04.1 amd64 Signed kernel image generic rc linux-image-5.15.0-94-generic 5.15.0-94.104~20.04.1 amd64 Signed kernel image generic ii linux-image-5.15.0-97-generic 5.15.0-97.107~20.04.1 amd64 Signed kernel image generic ii linux-image-generic-hwe-20.04 5.15.0.105.115~20.04.1 amd64 Generic Linux kernel image 3. 删除内核 使用apt-get或apt命令删除不需要的内核。比如 linux-image-5.15.0-105-generic的内核，可以使用：\nsudo apt-get purge linux-image-5.15.0-105-generic 4. 更新引导加载器 完成内核的删除后，更新GRUB配置以确保启动加载器的菜单被更新：\nsudo update-grub 5. 重启系统 最后，重启系统以确认更改：\nsudo reboot ","permalink":"https://ahaknow.com/posts/know/linux-kernel/","summary":"遇到了Linux新的内核启动卡死，老内核正常运行，索性就启动不了内核进行删除。 1. 查看当前运行的内核 在终端运行以下命令： uname -r 会得到下面这样的信","title":"Linux：内核启动不了之后"},{"content":" 以下记录安装的TensorRT环境安装的最简单，也是最正确的流程。\n因为很多时候依赖装乱了，直接装TensorRT会出现一堆依赖不存在的问题，因此需要按照顺序一步一步安装\n在进行下面的安装步骤之前，建议先将以前的安装的Nvidia相关的都卸载了，否则一定会出现依赖错乱的问题！\n建议手动选择卸载cuda、tensorrt、nvidia前缀的软件，然后使用 sudo apt autoremove 清理。\n首先需要正确安装CUDA 采用本地deb包的方法\nwget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-ubuntu2004.pin sudo mv cuda-ubuntu2004.pin /etc/apt/preferences.d/cuda-repository-pin-600 wget https://developer.download.nvidia.com/compute/cuda/12.4.1/local_installers/cuda-repo-ubuntu2004-12-4-local_12.4.1-550.54.15-1_amd64.deb sudo dpkg -i cuda-repo-ubuntu2004-12-4-local_12.4.1-550.54.15-1_amd64.deb sudo cp /var/cuda-repo-ubuntu2004-12-4-local/cuda-*-keyring.gpg /usr/share/keyrings/ sudo apt-get update sudo apt-get -y install cuda-toolkit-12-4 💡提示：如果老版本的不用了，也是用本地deb包方式安装的，可以在 /etc/apt/sources.list.d/ 路径下清除对应的版本。\n这里是使用12.4.1版本，最新版本可以由此访问\n关于Nvidia驱动安装，也可以在此完成：\n# To install the legacy kernel module flavor: sudo apt-get install -y cuda-drivers # To install the open kernel module flavor: sudo apt-get install -y nvidia-driver-550-open sudo apt-get install -y cuda-drivers-550 关于 the open kernel module 和 the legacy kernel module 可以简单理解为新显卡用open，老显卡用legacy。\n安装cuDNN 这是也是采用本地deb包的方法\n# Installation Instructions: wget https://developer.download.nvidia.com/compute/cudnn/9.1.0/local_installers/cudnn-local-repo-ubuntu2004-9.1.0_1.0-1_amd64.deb sudo dpkg -i cudnn-local-repo-ubuntu2004-9.1.0_1.0-1_amd64.deb sudo cp /var/cudnn-local-repo-ubuntu2004-9.1.0/cudnn-*-keyring.gpg /usr/share/keyrings/ sudo apt-get update sudo apt-get -y install cudnn # To install for CUDA 11, perform the above configuration but install the CUDA 11 specific package: sudo apt-get -y install cudnn-cuda-11 # To install for CUDA 12, perform the above configuration but install the CUDA 12 specific package: sudo apt-get -y install cudnn-cuda-12 同样可以直接参考官方文档\n安装TensorRT TensorRT需要通过Nvidia开发者账号进行下载\n官网，也是一样的deb安装方式\nsudo dpkg -i nv-tensorrt-local-repo-ubuntu2004-10.0.0-cuda-12.4_1.0-1_amd64.deb sudo cp /var/nv-tensorrt-local-repo-ubuntu2004-10.0.0-cuda-12.4/nv-tensorrt-local-*-keyring.gpg /usr/share/keyrings/ sudo apt-get update sudo apt-get install tensorrt 以下是老版本的安装 同样也需要清理Nvidia之前安装的残留\nCUDA wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-ubuntu2004.pin sudo mv cuda-ubuntu2004.pin /etc/apt/preferences.d/cuda-repository-pin-600 wget https://developer.download.nvidia.com/compute/cuda/12.1.0/local_installers/cuda-repo-ubuntu2004-12-1-local_12.1.0-530.30.02-1_amd64.deb sudo dpkg -i cuda-repo-ubuntu2004-12-1-local_12.1.0-530.30.02-1_amd64.deb sudo cp /var/cuda-repo-ubuntu2004-12-1-local/cuda-*-keyring.gpg /usr/share/keyrings/ sudo apt-get update sudo apt-get -y install cuda cuDNN sudo dpkg -i cudnn-local-repo-ubuntu2004-8.9.7.29_1.0-1_amd64.deb sudo cp /var/cudnn-local-repo-ubuntu2004-8.9.7.29/cudnn-local-*-keyring.gpg /usr/share/keyrings/ sudo apt update sudo apt-get install libcudnn8 TensorRT sudo dpkg -i nv-tensorrt-local-repo-ubuntu2004-8.6.1-cuda-12.0_1.0-1_amd64.deb sudo cp /var/nv-tensorrt-local-repo-ubuntu2004-8.6.1-cuda-12.0/nv-tensorrt-local-*-keyring.gpg /usr/share/keyrings/ sudo apt-get update sudo apt-get install tensorrt ","permalink":"https://ahaknow.com/posts/know/note-install-tensorrt/","summary":"以下记录安装的TensorRT环境安装的最简单，也是最正确的流程。 因为很多时候依赖装乱了，直接装TensorRT会出现一堆依赖不存在的问题，","title":"TensorRT：最简明的安装流程"},{"content":" 此前写代码，习惯性 std::cout 和 std::cerr 这种直接可视化的打印，然后满屏密密麻麻的打印信息，而如果不需要了，就会在代码大段大段的注释，非常不美观，甚至可以说是一堆堆💩。。。\n从代码美学的逻辑，应该是需要集中管理，然后根据需要选择输出“警告”，“调试”，“错误”等调试信息。\n这里选择一个比较容易上手的工具：Spdlog\n安装和项目中使用 Spdlog 在 Ubuntu Linux 系统：\nsudo apt-get install libspdlog-dev 在 C++ 文件中包含 Spdlog 头文件：\n#include \u0026lt;spdlog/spdlog.h\u0026gt; #include \u0026lt;spdlog/sinks/stdout_color_sinks.h\u0026gt; // 对于控制台彩色日志 #include \u0026lt;spdlog/sinks/basic_file_sink.h\u0026gt; // 对于文件日志 CMakeLists 中使用方式：\ncmake_minimum_required(VERSION 3.10) project(MyProject) # 添加Spdlog find_package(spdlog REQUIRED) add_executable(my_app main.cpp) target_link_libraries(my_app PRIVATE spdlog::spdlog) 实际使用 #include \u0026lt;spdlog/spdlog.h\u0026gt; #include \u0026lt;spdlog/sinks/stdout_color_sinks.h\u0026gt; #include \u0026lt;spdlog/sinks/basic_file_sink.h\u0026gt; int main() { auto logger = spdlog::stdout_color_mt(\u0026#34;console_logger\u0026#34;); auto file_logger = spdlog::basic_logger_mt(\u0026#34;file_logger\u0026#34;, \u0026#34;logs.txt\u0026#34;); spdlog::set_pattern(\u0026#34;[%Y-%m-%d %H:%M:%S] [%l] %v\u0026#34;); // 使用 {} 作为占位符 logger-\u0026gt;info(\u0026#34;Hello, {}!\u0026#34;, \u0026#34;World\u0026#34;); file_logger-\u0026gt;warn(\u0026#34;This is a warning in a file.\u0026#34;); // 16进制 logger-\u0026gt;debug(\u0026#34;Frame header: 0x{:02x} 0x{:02x}\u0026#34;, recv_buffer[0], recv_buffer[1]); return 0; } 设置日志级别： Spdlog 支持的日志级别包括：trace, debug, info, warn, err, critical, off。可以设置全局日志级别或针对单个 logger：\nspdlog::set_level(spdlog::level::info); // 全局设置，只记录 info 及以上级别的日志 console-\u0026gt;set_level(spdlog::level::debug); // 对 \u0026#34;console\u0026#34; 进行设置 日志格式设置： spdlog::set_pattern(\u0026#34;[%Y-%m-%d %H:%M:%S] [%l] %v\u0026#34;); console-\u0026gt;info(\u0026#34;This is a formatted log\u0026#34;); 异步日志记录： 为了增加日志记录的性能，可以使用 spdlog 的异步日志功能：\n#include \u0026lt;spdlog/async.h\u0026gt; auto async_file = spdlog::basic_logger_mt\u0026lt;spdlog::async_factory\u0026gt;(\u0026#34;async_file_logger\u0026#34;, \u0026#34;async_log.txt\u0026#34;); async_file-\u0026gt;info(\u0026#34;This is an async log message\u0026#34;); 项目中的使用技巧 比如在main函数中：\n#include \u0026lt;spdlog/spdlog.h\u0026gt; #include \u0026lt;spdlog/sinks/stdout_color_sinks.h\u0026gt; int main() { auto logger = spdlog::stdout_color_mt(\u0026#34;console\u0026#34;); logger-\u0026gt;set_level(spdlog::level::debug); // 设置日志级别 spdlog::set_pattern(\u0026#34;[%Y-%m-%d %H:%M:%S] [%^%L%$] %v\u0026#34;); // 设置全局格式 // 应用程序代码... return 0; } 这时如果在类的实现里也需要使用到spdlog，就可以这样：\n#include \u0026lt;spdlog/spdlog.h\u0026gt; class TCPFrameClient { public: TCPFrameClient() { logger_ = spdlog::get(\u0026#34;console\u0026#34;); // 注意用\u0026#34;console\u0026#34;来定位 if (!logger_) { // Fallback or re-initialize if not found logger_ = spdlog::stdout_color_mt(\u0026#34;console\u0026#34;); } } void doSomething() { logger_-\u0026gt;info(\u0026#34;Doing something\u0026#34;); } private: std::shared_ptr\u0026lt;spdlog::logger\u0026gt; logger_; }; 也可以通过传递指针的方式（稍微复杂一些）：\nclass TCPFrameClient { public: TCPFrameClient(std::shared_ptr\u0026lt;spdlog::logger\u0026gt; logger) : logger_(logger) { if (!this-\u0026gt;logger_) { // Fallback initialization this-\u0026gt;logger_ = spdlog::stdout_color_mt(\u0026#34;console\u0026#34;); } } void connect() { logger_-\u0026gt;info(\u0026#34;Connecting to server\u0026#34;); } private: std::shared_ptr\u0026lt;spdlog::logger\u0026gt; logger_; }; // 主程序 int main() { auto logger = spdlog::stdout_color_mt(\u0026#34;console\u0026#34;); TCPFrameClient client(logger); client.connect(); return 0; } 🌟一个更好的实践 一个好的工程，其结构应该像下面这样的：\n├── Utils │ ├── CMakeLists.txt │ ├── logger.cpp │ └── logger.h ├── Parser │ ├── CMakeLists.txt │ ├── data_frame_parser.cpp │ └── data_frame_parser.h ├── TCPClient │ ├── CMakeLists.txt │ ├── tcp_frame_client.cpp │ └── tcp_frame_client.h 具体而言就是单独管理Logger：\nLogger.h #ifndef LOGGER_H #define LOGGER_H #include \u0026lt;memory\u0026gt; #include \u0026lt;spdlog/spdlog.h\u0026gt; #include \u0026lt;spdlog/sinks/stdout_color_sinks.h\u0026gt; class Logger { public: static std::shared_ptr\u0026lt;spdlog::logger\u0026gt; get_instance(const std::string\u0026amp; logger_name); }; #endif // LOGGER_H Logger.cpp #include \u0026#34;logger.h\u0026#34; std::shared_ptr\u0026lt;spdlog::logger\u0026gt; Logger::get_instance(const std::string\u0026amp; logger_name) { auto logger = spdlog::get(logger_name); if (!logger) { logger = spdlog::stdout_color_mt(logger_name); logger-\u0026gt;set_level(spdlog::level::info); spdlog::set_pattern(\u0026#34;[%Y-%m-%d %H:%M:%S] [%^%l%$] %v\u0026#34;); } return logger; } 修改 CMakeLists.txt 对于 Utils 目录的 CMakeLists.txt，需要添加以下内容来确保 Logger 类被正确编译和链接：\nadd_library(Utils logger.h logger.cpp ) target_include_directories(Utils PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ) # 链接 spdlog find_package(spdlog REQUIRED) target_link_libraries(Utils spdlog::spdlog ) 确保其他模块的 CMakeLists.txt 文件更新为链接到 Utils 库：\ntarget_link_libraries(Parser Utils # 添加这个 # 其他依赖 ) target_link_libraries(TCPClient Utils # 添加这个 # 其他依赖 ) 在实际使用时，就可以这样：\nMainProcessor::MainProcessor(const std::string\u0026amp; path, int mode) : path_(path), mode_(mode), logger_(Logger::get_instance(\u0026#34;DataFrameParser\u0026#34;)) {} TCPFrameClient::TCPFrameClient(DataFrameParser\u0026amp; parser, int port) : sock_(-1), server_port_(port), parser_(parser) { parser_.initializeDecoder(); logger_ = Logger::get_instance(\u0026#34;DataFrameParser\u0026#34;); } DataFrameParser::DataFrameParser(int width, int height) : width_(width), height_(height) { initDisparityPseudoColorTable(); initializeDecoder(); logger_ = Logger::get_instance(\u0026#34;DataFrameParser\u0026#34;); } ","permalink":"https://ahaknow.com/posts/know/dev-spdlog-usage/","summary":"此前写代码，习惯性 std::cout 和 std::cerr 这种直接可视化的打印，然后满屏密密麻麻的打印信息，而如果不需要了，就会在代码大段大段的注释，非常不美观，甚至可以说是","title":"开发实战：使用Spdlog管理调试信息"},{"content":"一个“好看”的CMake管理应该是这样的：\n├── CMakeLists.txt ├── main_class.cpp ├── main.cpp ├── model │ ├── seg_0415.onnx │ └── seg_0415.trt ├── Parser │ ├── CMakeLists.txt │ ├── data_frame_parser.cpp │ └── data_frame_parser.h ├── RoadSeg │ ├── CMakeLists.txt │ ├── road_segmentation.cpp │ └── road_segmentation.hpp ├── TCPClient │ ├── CMakeLists.txt │ ├── tcp_frame_client.cpp │ └── tcp_frame_client.h ├── Test │ ├── main_simple.cpp │ ├── ptr_mat.cpp │ └── test_main.cpp └── Utils ├── CMakeLists.txt ├── logger.cpp └── logger.h 具体而言，比如Parser下面的CMakeLists.txt：\nfind_package(OpenCV REQUIRED) find_package(PCL REQUIRED) # Find FFmpeg components find_package(PkgConfig REQUIRED) pkg_check_modules(AVCODEC REQUIRED libavcodec) pkg_check_modules(AVFORMAT REQUIRED libavformat) pkg_check_modules(SWSCALE REQUIRED libswscale) pkg_check_modules(AVUTIL REQUIRED libavutil) include_directories( ${OpenCV_INCLUDE_DIRS} ${PCL_INCLUDE_DIRS} ${AVCODEC_INCLUDE_DIRS} ${AVFORMAT_INCLUDE_DIRS} ${SWSCALE_INCLUDE_DIRS} ${AVUTIL_INCLUDE_DIRS} /usr/include ${CMAKE_SOURCE_DIR}/Utils ) # 添加Parser库 add_library(Parser SHARED data_frame_parser.cpp data_frame_parser.h ) target_include_directories(Parser PUBLIC ${CMAKE_CURRENT_SOURCE_DIR} ) target_link_libraries(Parser ${AVCODEC_LIBRARIES} ${AVFORMAT_LIBRARIES} ${SWSCALE_LIBRARIES} ${AVUTIL_LIBRARIES} ${OpenCV_LIBS} ${PCL_LIBRARIES} lz4 Utils ) 而main函数的CMakeLists.txt就可以很简洁了:\ncmake_minimum_required(VERSION 3.10) project(DataFrameParser) set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_STANDARD_REQUIRED True) option(BUILD_SHARED_LIBS \u0026#34;Build libraries as shared libraries\u0026#34; ON) # 添加子目录 add_subdirectory(Utils) add_subdirectory(Parser) add_subdirectory(TCPClient) add_subdirectory(AI) add_subdirectory(RoadSeg) add_executable(DataFrameParser main_class.cpp) target_link_libraries(DataFrameParser Parser TCPClient AI4FS RoadSeg ) ","permalink":"https://ahaknow.com/posts/know/dev-project-cmake/","summary":"一个“好看”的CMake管理应该是这样的： ├── CMakeLists.txt ├── main_class.cpp ├── main.cpp ├── model │ ├── seg_0415.onnx │ └── seg_0415.trt ├── Parser │ ├── CMakeLists.txt │ ├── data_frame_parser.cpp │ └── data_frame_parser.h ├── RoadSeg","title":"开发实战：项目中的CMake技巧"},{"content":" 关于代码💩山，已经不忍直视。。。\n只希望自己能够写出整洁、大方、有魅力（又美丽）的代码。\n所以呢，得给代码属个大名。\nvscode用的久了，以此为例吧？（其实CLion体验更好，那未尝不试试呢！）\n先vscode吧！\n在 VS Code 中自动添加版权信息 可以通过使用代码片段（Snippets）来自动插入版权信息：\n打开命令面板（Ctrl+Shift+P 或 Cmd+Shift+P）。 输入 \u0026ldquo;Configure User Snippets\u0026rdquo; 并选择它。 选择 cpp.json（针对 C++ 文件）。 输入以下内容： { \u0026#34;Print Copyright Header\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;copyright\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;/*\u0026#34;, \u0026#34; * Project: ${1:Your Project Name}\u0026#34;, \u0026#34; * File: $TM_FILENAME\u0026#34;, \u0026#34; * Version: ${2:1.0}\u0026#34;, \u0026#34; *\u0026#34;, \u0026#34; * Author: ${3:Your Name}\u0026#34;, \u0026#34; * Email: ${4:your.email@example.com}\u0026#34;, \u0026#34; * Date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE\u0026#34;, \u0026#34; *\u0026#34;, \u0026#34; * Copyright (c) $CURRENT_YEAR, [Your Company Name]\u0026#34;, \u0026#34; * All rights reserved.\u0026#34;, \u0026#34; *\u0026#34;, \u0026#34; * [Add additional license information here]\u0026#34;, \u0026#34; */\u0026#34;, \u0026#34;\u0026#34; ], \u0026#34;description\u0026#34;: \u0026#34;Prints a detailed copyright header with additional information\u0026#34; } } 其中，可以使用 ${1:default} 这样的语法来设置默认值，例如：\n\u0026#34;Author: $3\u0026#34;: \u0026#34;Author: ${3:Your Name}\u0026#34; 通过快捷键插入版权信息 进入 Code \u0026gt; 首选项 \u0026gt; 键盘快捷方式。 搜索 “Trigger Suggest” 或者 “触发建议”。 查看当前绑定的快捷键或为其设置一个新的快捷键。 然后就可以使用 prefix 字段的内容来自动加入版权信息来\n补充 这里是以C++文件来说明，其他语言也是一样的逻辑，只需要注意按照各自的语法就好。\n比如：\n在编辑器中，点击 文件 \u0026gt; 首选项 \u0026gt; 用户片段。 选择 New Global Snippets file... 或者在工作区中选择 New Snippets file for 'your-workspace-name'...。 输入片段文件的名称，如 date.snippets。 JavaScript 的 date.snippets 文件:\n{ \u0026#34;Print Current Date\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;date\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;// Current Date: ${CURRENT_DATE}\u0026#34; ], \u0026#34;description\u0026#34;: \u0026#34;Prints the current date as a comment.\u0026#34; } } Python 的 date.snippets 文件:\n{ \u0026#34;Print Current Date\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;date\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;# Current Date: ${CURRENT_DATE}\u0026#34; ], \u0026#34;description\u0026#34;: \u0026#34;Prints the current date as a comment.\u0026#34; } } 另外，有一些宏定义是可以直接使用：\n${CURRENT_DATE}：当前日期（格式：yyyy-mm-dd）。 ${CURRENT_MONTH_NAME}：当前月份的全名（例如：January, February等）。 ${CURRENT_MONTH_NAME_SHORT}：当前月份的缩写（例如：Jan, Feb等）。 ${CURRENT_YEAR}：当前年份。 ${CURRENT_HOUR}：当前小时（24小时制）。 ${CURRENT_MINUTE}：当前分钟。 ${CURRENT_SECOND}：当前秒数。 ${CURRENT_DAY_NAME}：当前星期几的全名（例如：Monday, Tuesday等）。 ${CURRENT_DAY_NAME_SHORT}：当前星期几的缩写（例如：Mon, Tue等）。 ","permalink":"https://ahaknow.com/posts/know/dev-auto-code-copyright/","summary":"关于代码💩山，已经不忍直视。。。 只希望自己能够写出整洁、大方、有魅力（又美丽）的代码。 所以呢，得给代码属个大名。 vscode用的久了，以此为","title":"开发实战：给代码属上大名"},{"content":" 主打一个“懒”字！\n移动文件啊，重命名啥的，动手拖拖不行嘛？！\n不行！用键盘，用命令行！\n比如：\n想要移动 ZYC01981 - 01.jpg，同时又想把 - 01 后缀给去掉，怎么做？\n好记性不如烂笔头！\n很厉害？嗯！唯手熟尔～\n要匹配任何以 \u0026quot; - 01\u0026quot;、\u0026quot; - 02\u0026quot;、\u0026quot; - 03\u0026quot;、\u0026quot; - 12\u0026quot;、\u0026quot; - 13\u0026quot; 等等等等结尾的 .jpg 文件，可以这样写：\nfind . -type f -regex \u0026#39;.* - [0-9][0-9]\\.jpg\u0026#39; 这个正则表达式会匹配任何以两位数字结尾的 .jpg 文件。如果需要限制特定的数字，则可以调整正则表达式的数字部分。例如，只匹配以 \u0026ldquo;01\u0026rdquo;、\u0026ldquo;02\u0026rdquo;、\u0026ldquo;03\u0026rdquo;、\u0026ldquo;12\u0026rdquo;、\u0026ldquo;13\u0026rdquo; 结尾的文件：\nfind . -type f -regex \u0026#39;.* - \\(01\\|02\\|03\\|12\\|13\\)\\.jpg\u0026#39; 对于重命名操作，如果希望去掉文件名中的 \u0026quot; - 数字\u0026quot; 部分，可以使用以下命令（使用 echo 只打印不执行）：\nfind . -type f -regex \u0026#39;.* - [0-9][0-9]\\.jpg\u0026#39; -exec bash -c \u0026#39;echo mv \u0026#34;$0\u0026#34; \u0026#34;${0/ - [0-9][0-9]/}\u0026#34;\u0026#39; {} \\; 如果想要移动它们，则可以：\nfind . -type f -regex \u0026#39;.* - [0-9][0-9]\\.jpg\u0026#39; -exec mv {} DestinationFolder/ \\; 解释一下每个部分的作用\nfind .：\nfind 用于在目录树中查找文件和目录。 . 指定从当前目录开始搜索。 -type f：\n这个选项限制 find 命令只查找文件（不包括目录）。 -regex '.* - [0-9][0-9]\\.jpg'：\n-regex 选项让 find 使用完整的正则表达式来匹配文件路径。 '.* - [0-9][0-9]\\.jpg' 是一个正则表达式，用来匹配文件名中包含 \u0026quot; - 数字数字.jpg\u0026quot; 的文件。 -exec bash -c 'echo mv \u0026quot;$0\u0026quot; \u0026quot;${0/ - [0-9][0-9]/}\u0026quot;' {} \\;：\n-exec 选项后跟一个命令，该命令对每个找到的文件执行。在此处，它调用 bash -c，允许执行更复杂的 bash 命令。 'echo mv \u0026quot;$0\u0026quot; \u0026quot;${0/ - [0-9][0-9]/}\u0026quot;' 是一个 bash 命令。它使用 echo 预览 mv 命令的效果，而不实际执行文件移动。 \u0026quot;$0\u0026quot; 代表当前处理的文件名。 \u0026quot;${0/ - [0-9][0-9]/}\u0026quot; 是 bash 的参数替换，它在文件名中删除 \u0026quot; - 数字数字\u0026quot; 模式。 {} 是 find 命令用来代表当前找到的文件名。 \\; 表示 -exec 执行的命令结束。 -exec mv {} DestinationFolder/ \\;：\n这个命令也是 -exec 用法的一个例子，用于将找到的文件移动到指定目录。 mv 是移动（或重命名）文件的命令。 {} 代表当前处理的文件名。 DestinationFolder/ 是目标目录，所有找到的文件都会被移动到这个目录。 \\; 表示 -exec 执行的命令结束。 ","permalink":"https://ahaknow.com/posts/know/note-shell-move-file/","summary":"主打一个“懒”字！ 移动文件啊，重命名啥的，动手拖拖不行嘛？！ 不行！用键盘，用命令行！ 比如： 想要移动 ZYC01981 - 01.jpg，同时又想把 - 01 后缀给去掉","title":"Shell：操作移动文件"},{"content":" 本试题仅用于考查 C++/C 程序员的基本编程技能。内容限于 C++/C 常用语法，不涉及数据结构、算法以及深奥的语法。考试成绩能反映出考生的编程质量以及对 C++/C 的理解程度，但不能反映考生的智力和软件开发能力。\n一、请填写 BOOL , float, 指针变量 与“零值”比较的 if 语句。(10 分) 提示:这里“零值”可以是 0, 0.0 , FALSE 或者“空指针”。例如 int 变量 n 与“零值” 比较的 if 语句为:\nif ( n == 0 ) if ( n != 0 ) 以此类推。\n请写出 BOOL flag 与“零值”比较的 if 语句。（3 分） //标准答案 if ( flag ) if ( !flag ) // 如下写法均属不良风格，不得分。 if (flag == TRUE) if (flag == 1 ) if (flag == FALSE) if (flag == 0) 注解：BOOL值直接用if判断即可，没必要出现==的情况。\n请写出 float x 与“零值”比较的 if 语句。（4 分） ","permalink":"https://ahaknow.com/posts/know/art-c-c++-exam/","summary":"本试题仅用于考查 C++/C 程序员的基本编程技能。内容限于 C++/C 常用语法，不涉及数据结构、算法以及深奥的语法。考试成绩能反映出考生的编程质量以及对 C++/C 的理解","title":"编程艺术：高质量编程指南C/C++试题"},{"content":" 在上一篇打通了读取字节流文件后，能够得到每一帧的字节数据了，这一篇就来解决为这些数据赋予实际意义。\n彩色图像采用H.264编码 -\u0026gt; 那就需要按照H.264解码\n视差图像采用LZ4压缩 -\u0026gt; 视差图保存的16位无符号整数，采用LZ4解压缩（开源）\n背景知识 LZ4 LZ4 是一个非常快速的压缩算法，提供了实时压缩速度和非常快的解压缩速度，由 Yann Collet（FaceBook大佬） 开发。它属于无损压缩算法，意味着压缩后的数据可以完全恢复到其原始形态。LZ4 主要设计用于非常高速的场景（解压速度可以达到数GB每秒），例如实时数据传输、日志数据处理等。\nH.264 H.264，也被称为MPEG-4 AVC（Advanced Video Coding），是一种广泛使用的视频压缩标准。它是由国际电信联盟（ITU-T）下的视频编码专家组（VCEG）以及运动图像专家组（MPEG）共同开发的。H.264标准的目标是提供高质量的视频传输，同时显著降低比特率，相对于以前的标准如MPEG-2和MPEG-4 Part 2，它在保持相同视觉质量的情况下，可以使文件大小减少到原来的一半以上。\nH.264 和 Qt Qt 使用 Qt Multimedia 模块来处理多媒体内容，包括视频和音频。这个模块支持多种格式，包括 H.264。使用 Qt Multimedia，开发者可以较容易地在应用中集成视频播放功能，而不需要直接处理底层的视频解码。\nQt Multimedia Widgets：可以使用 QMediaPlayer 和 QVideoWidget 来播放 H.264 视频。Qt 处理多媒体流的解码和渲染，开发者只需要关注如何控制播放器和集成到UI中。 自动解码：Qt 底层使用系统的编解码库（如 DirectShow on Windows, GStreamer on Linux）来解码视频流，包括 H.264。这意味着通常不需要手动解析 H.264 数据帧，除非需要非常定制化的处理。 FFmpeg FFmpeg 是一个开源的多媒体框架，它提供了一套全面的库和工具，用于处理视频、音频和其他多媒体文件和流。这个框架支持转码、转流、播放和分析几乎所有类型的多媒体数据。FFmpeg 包括以下主要组件：\nlibavcodec: 提供广泛的编解码器支持，是处理视频和音频编解码的核心库。 libavformat: 处理多种音视频容器格式的输入和输出。 libavutil: 包含一些辅助的实用功能，如日志管理和错误处理。 libavfilter: 提供视频和音频流的转换和操作功能。 libswscale: 处理图像色彩和像素格式转换。 libswresample: 处理音频采样数据的转换。 项目中使用LZ4 首先安装 liblz4-dev：\nsudo apt update sudo apt install liblz4-dev 有可能 CMake 仍然找不到 LZ4，这时候可以手动指定 LZ4 库和头文件的路径。首先需要确定 liblz4.so 和 LZ4 的头文件 lz4.h 的位置。这些文件通常位于 /usr/include 和 /usr/lib 下，如果不确定可以通过 find /usr -name lz4.h命令查找 。\n修改 CMakeLists.txt 文件，手动设置路径：\ncmake_minimum_required(VERSION 3.10) project(DataFrameParser) set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_STANDARD_REQUIRED True) # Find OpenCV find_package(OpenCV REQUIRED) # Include directories for OpenCV and manually for LZ4 include_directories( ${OpenCV_INCLUDE_DIRS} /usr/include ) # Link directories for LZ4 link_directories(/usr/lib /usr/lib/x86_64-linux-gnu) # Adjust this path according to your system add_executable(DataFrameParser main.cpp) target_link_libraries(DataFrameParser lz4 ${OpenCV_LIBS}) 这里，这里使用了 link_directories 和 target_link_libraries 中直接指定 lz4，而不是 ${LZ4_LIBRARIES}。这是因为没有使用 find_package 来定义 LZ4_LIBRARIES 变量。\n项目中使用FFmpeg 安装 FFmpeg 和相应的开发库：\nsudo apt update sudo apt install ffmpeg sudo apt install libavcodec-dev libavformat-dev libswscale-dev libavutil-dev 这些开发库包括用于处理视频编解码的 libavcodec，用于处理多媒体容器格式的 libavformat，以及用于视频缩放和格式转换的 libswscale 等。\n在 CMake 项目中使用 FFmpeg，则需要在 CMakeLists.txt 文件中正确设置找到和链接这些库，举例如下：\ncmake_minimum_required(VERSION 3.10) project(DataFrameParser) set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_STANDARD_REQUIRED True) # Find OpenCV find_package(OpenCV REQUIRED) # Find FFmpeg components find_package(PkgConfig REQUIRED) pkg_check_modules(AVCODEC REQUIRED libavcodec) pkg_check_modules(AVFORMAT REQUIRED libavformat) pkg_check_modules(SWSCALE REQUIRED libswscale) pkg_check_modules(AVUTIL REQUIRED libavutil) include_directories( ${OpenCV_INCLUDE_DIRS} ${AVCODEC_INCLUDE_DIRS} ${AVFORMAT_INCLUDE_DIRS} ${SWSCALE_INCLUDE_DIRS} ${AVUTIL_INCLUDE_DIRS} ) add_executable(DataFrameParser main.cpp) target_link_libraries(DataFrameParser ${OpenCV_LIBS} ${AVCODEC_LIBRARIES} ${AVFORMAT_LIBRARIES} ${SWSCALE_LIBRARIES} ${AVUTIL_LIBRARIES} ) 难点分析 不使用QT，希望能够转换为OpenCV处理的图像，因此需要使用到FFmpeg。\n由于处理的字节流，那么就需要保证能够持续的解码。也就是需要初始化一次，然后持续运行，运行结束后释放资源。\n使用 FFmpeg 解析 H.264 图像的过程和原理 初始化和配置解码器（这部分只需要初始化一次）\n查找并打开解码器:使用 avcodec_find_decoder 根据指定的编解码器ID（例如 AV_CODEC_ID_H264）来查找对应的解码器。然后使用 avcodec_alloc_context3 和 avcodec_open2 来分配并初始化解码器上下文。 设置解码上下文:配置解码器上下文，如设置时间基、延迟等。 解码过程\n读取和发送数据包:从源数据（如文件、网络流）中读取数据，并构建成 AVPacket。使用 av_read_frame 从多媒体文件读取数据帧或使用 av_init_packet 处理自定义的数据，然后使用 avcodec_send_packet 将数据包发送给解码器。 接收和解码:使用 avcodec_receive_frame 接收解码器输出的帧。该函数从解码器中提取一个解码好的帧，如果没有足够的数据解码一个完整的帧，它会返回 EAGAIN。 图像转换:使用 libswscale（或 SwsContext）将解码后的帧（通常为YUV格式）转换为其他像素格式（如RGB），以便于显示或进一步处理。 资源清理 释放资源:使用 av_frame_free、av_packet_free 和 avcodec_close 释放帧、数据包和关闭解码器。 代码实现 // 全局变量或类成员变量 AVCodecContext* context = nullptr; bool initializeDecoder() { AVCodec* codec = avcodec_find_decoder(AV_CODEC_ID_H264); if (!codec) { std::cerr \u0026lt;\u0026lt; \u0026#34;Codec not found.\\n\u0026#34;; return false; } context = avcodec_alloc_context3(codec); if (!context) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not allocate video codec context.\\n\u0026#34;; return false; } if (avcodec_open2(context, codec, NULL) \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not open codec.\\n\u0026#34;; avcodec_free_context(\u0026amp;context); return false; } return true; } void cleanupDecoder() { if (context) { avcodec_close(context); avcodec_free_context(\u0026amp;context); } } bool processH264Frame(const std::vector\u0026lt;uint8_t\u0026gt;\u0026amp; data, cv::Mat\u0026amp; image) { AVPacket* pkt = av_packet_alloc(); if (!pkt) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not allocate AVPacket.\\n\u0026#34;; return false; } av_init_packet(pkt); // set data source pkt-\u0026gt;data = const_cast\u0026lt;uint8_t*\u0026gt;(data.data()); // Unsafe cast, data must be non-const pkt-\u0026gt;size = data.size(); int ret = avcodec_send_packet(context, pkt); if (ret \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error sending a packet for decoding.\\n\u0026#34;; av_packet_free(\u0026amp;pkt); return false; } AVFrame* frame = av_frame_alloc(); ret = avcodec_receive_frame(context, frame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) { av_frame_free(\u0026amp;frame); av_packet_free(\u0026amp;pkt); return false; } else if (ret \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error during decoding.\\n\u0026#34;; av_frame_free(\u0026amp;frame); av_packet_free(\u0026amp;pkt); return false; } // Convert AVFrame to cv::Mat // yuvj420p std::cout \u0026lt;\u0026lt; \u0026#34;Pixel Format: \u0026#34; \u0026lt;\u0026lt; av_get_pix_fmt_name(static_cast\u0026lt;AVPixelFormat\u0026gt;(frame-\u0026gt;format)) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Pixel Format Enum: \u0026#34; \u0026lt;\u0026lt; frame-\u0026gt;format \u0026lt;\u0026lt; std::endl; SwsContext* img_convert_ctx = sws_getContext(frame-\u0026gt;width, frame-\u0026gt;height, static_cast\u0026lt;AVPixelFormat\u0026gt;(frame-\u0026gt;format), frame-\u0026gt;width, frame-\u0026gt;height, AV_PIX_FMT_BGR24, SWS_BICUBIC, NULL, NULL, NULL); int linesize[1] = {3 * frame-\u0026gt;width}; // RGB stride image = cv::Mat(frame-\u0026gt;height, frame-\u0026gt;width, CV_8UC3); sws_scale(img_convert_ctx, frame-\u0026gt;data, frame-\u0026gt;linesize, 0, frame-\u0026gt;height, \u0026amp;image.data, linesize); sws_freeContext(img_convert_ctx); av_frame_free(\u0026amp;frame); av_packet_free(\u0026amp;pkt); return true; } 代码分析 由于SPS（序列参数集）和PPS（图像参数集）等关键解码信息通常只在视频流的开始部分发送，因此只需要初始化解码器一次。（最开始的实现是每次解码帧之前都重新初始化解码器，这样的话，这些关键信息可能会丢失，导致后续帧无法正确解码，表现的现象是卡在了第一帧画面）。\n以下是上述代码的逐行解释：\n初始化解码器 // 找到并确认解码器 AVCodec* codec = avcodec_find_decoder(AV_CODEC_ID_H264); if (!codec) { std::cerr \u0026lt;\u0026lt; \u0026#34;Codec not found.\\n\u0026#34;; return false; } avcodec_find_decoder: 这个函数用于查找指定编解码器（这里是H.264），返回一个指向解码器的指针。 if (!codec): 如果没有找到解码器，输出错误信息并返回失败。 // 分配编解码器上下文 AVCodecContext* context = avcodec_alloc_context3(codec); if (!context) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not allocate video codec context.\\n\u0026#34;; return false; } avcodec_alloc_context3: 分配一个新的解码器上下文，关联给定的编解码器。 if (!context): 如果上下文分配失败，输出错误信息并返回失败。 // 打开解码器 if (avcodec_open2(context, codec, NULL) \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not open codec.\\n\u0026#34;; return false; } avcodec_open2: 初始化解码器上下文以准备使用，传入的 codec 是上文查找得到的编解码器。 if (avcodec_open2(...) \u0026lt; 0): 如果解码器打开失败，输出错误信息并返回失败。 处理单帧数据 // 分配数据包 AVPacket* pkt = av_packet_alloc(); if (!pkt) { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not allocate AVPacket.\\n\u0026#34;; return false; } av_packet_alloc: 分配一个新的数据包。数据包用于存储编码的数据（例如一个压缩的视频帧）。 if (!pkt): 如果数据包分配失败，输出错误信息并返回失败。 // 初始化数据包并设置数据 av_init_packet(pkt); pkt-\u0026gt;data = const_cast\u0026lt;uint8_t*\u0026gt;(data.data()); // Unsafe cast, data must be non-const pkt-\u0026gt;size = data.size(); av_init_packet: 初始化分配的数据包。 pkt-\u0026gt;data, pkt-\u0026gt;size: 设置数据包的数据指针和大小。data 是函数传入的H.264数据。 // 发送数据包到解码器 int ret = avcodec_send_packet(context, pkt); if (ret \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error sending a packet for decoding.\\n\u0026#34;; return false; } avcodec_send_packet: 将数据包发送到解码器，等待解码。 if (ret \u0026lt; 0): 如果发送失败，输出错误信息并返回失败。 接收解码后的帧并转换为cv::Mat // 分配帧存储解码后的数据 AVFrame* frame = av_frame_alloc(); ret = avcodec_receive_frame(context, frame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) { av_frame_free(\u0026amp;frame); break; } else if (ret \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error during decoding.\\n\u0026#34;; return false; } av_frame_alloc: 分配一个帧用于存储解码后的数据。 avcodec_receive_frame: 从解码器中获取一个解码后的帧。 if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF): 检查是否全部数据已处理完毕或需要更多数据。 // 转换解码后的帧为cv::Mat格式 SwsContext* img_convert_ctx = sws_getContext(frame-\u0026gt;width, frame-\u0026gt;height, static_cast\u0026lt;AVPixelFormat\u0026gt;(frame-\u0026gt;format), frame-\u0026gt;width, frame-\u0026gt;height, AV_PIX_FMT_BGR24, SWS_BICUBIC, NULL, NULL, NULL); int linesize[1] = {3 * frame-\u0026gt;width}; // RGB stride image = cv::Mat(frame-\u0026gt;height, frame-\u0026gt;width, CV_8UC3); sws_scale(img_convert_ctx, frame-\u0026gt;data, frame-\u0026gt;linesize, 0, frame-\u0026gt;height, \u0026amp;image.data, linesize); sws_freeContext(img_convert_ctx); sws_getContext: 创建一个上下文用于转换像素数据格式。 sws_scale: 转换像素数据格式从解码帧的格式到BGR24，这是OpenCV常用的格式。 cv::Mat: 创建一个OpenCV矩阵来存储图像数据。 这个流程需要在视频处理的生命周期中只初始化和清理一次编解码器，而帧处理可以多次调用，以提高性能和保持编解码器状态。这是一种高效处理视频帧的典型方法。\nL4Z 解压缩 L4Z解压缩的过程相对直接，直接根据函数来实现即可。\n代码实现 bool decompressLZ4Frame(const std::vector\u0026lt;uint8_t\u0026gt;\u0026amp; compressedData, cv::Mat\u0026amp; image, int width, int height) { std::vector\u0026lt;uint8_t\u0026gt; decompressedData(width * height * sizeof(uint16_t)); int decompressedSize = LZ4_decompress_safe(reinterpret_cast\u0026lt;const char*\u0026gt;(compressedData.data()), reinterpret_cast\u0026lt;char*\u0026gt;(decompressedData.data()), compressedData.size(), decompressedData.size()); if (decompressedSize \u0026lt; 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to decompress LZ4 data.\u0026#34; \u0026lt;\u0026lt; std::endl; return false; } image = cv::Mat(height, width, CV_16UC1, decompressedData.data()); cv::Mat pseudoColorImage(height, width, CV_8UC3); for (int i = 0; i \u0026lt; height; i++) { for (int j = 0; j \u0026lt; width; j++) { uint16_t disparity = image.at\u0026lt;uint16_t\u0026gt;(i, j); if (disparity \u0026lt; 8192) { pseudoColorImage.at\u0026lt;cv::Vec3b\u0026gt;(i, j) = cv::Vec3b(pColorTable[disparity * 3 + 2], pColorTable[disparity * 3 + 1], pColorTable[disparity * 3]); } else { pseudoColorImage.at\u0026lt;cv::Vec3b\u0026gt;(i, j) = cv::Vec3b(0, 0, 0); } } } image = pseudoColorImage; return true; } 这里对解压缩的视差图进行颜色映射的处理，是根据视差值直接映射得到\n","permalink":"https://ahaknow.com/posts/know/dev-decode-h.264-lz4-image-frames/","summary":"在上一篇打通了读取字节流文件后，能够得到每一帧的字节数据了，这一篇就来解决为这些数据赋予实际意义。 彩色图像采用H.264编码 -\u0026gt; 那就需要按照H","title":"开发实战：解析H.264编码和LZ4压缩的相机图像"},{"content":" 需要解析相机的字节流文件（就是一个一个Byte组成的文件，不解析的话没有啥实际意义）。\n解析需要按照一定的规则，比如：如何确定数据的头（Header），以及一个数据帧（一个数据包）的结构是什么样的，这个有点像网络包的定义，在头部定义了很多信息，这些信息能够让这个数据包按照规则解析出来后有具体的意义。\n下面按照尝试-失败-再尝试-成功之后的思考来进行整理。因为一开始采用直接“复制-粘贴（ChatGPT指导）”的方式，遇到了解析失败的情况，根据结果一点点分析，始终没发现问题在哪。\n因为问题出现在了一开始，也是比较基础的知识点，字节流在保存时分为大端存储和小端存储，由于这个知识点我压根就忘记了，所以迟迟没有发现，最后是不断往上追问，从ChatGPT的指导中发现了可能的原因，惭愧啊！\n大小端（Endianness）概念 大小端是指多字节数据（如整数、浮点数等）在内存中字节的排列顺序。这是计算机内存架构中的一个重要概念，影响了数据的存储和通信。大小端问题通常在处理跨平台数据传输和文件读写时显得尤为重要。\n大端（Big Endian）\n在大端字节序中，一个数的最高位字节（Big End）存储在内存的低地址处，其次是次高位，依此类推，最低位字节存储在高地址处。 例如，数 0x12345678 在内存中的存储方式（地址从低到高）为 12 34 56 78。 “大端易读”，左到右直接读出来就是原始保存的数据 小端（Little Endian）\n在小端字节序中，一个数的最低位字节（Little End）存储在内存的低地址处，随后是次低位，依此类推，最高位字节存储在高地址处。 例如，数 0x12345678 在内存中的存储方式（地址从低到高）为 78 56 34 12。 “小端反直觉”，因为现代汉语默认从左往右看，这里则需要反过来，两两看 大小端存在的原因主要与不同的处理器架构有关。不同的硬件制造商选择不同的存储方法，这通常取决于硬件设计的优化、历史原因和技术遗留问题。\n大端模式的优点在于从内存的起始地址开始即可读取高位，易于从地址解析其代表的数值大小，这在网络协议设计中尤为重要，因为许多网络协议规定为大端。\n小端模式则使得低位首先被处理，这在进行数学运算时常常更为高效，因为低位通常是先处理的部分。小端是多数现代个人计算机处理器，如x86架构，采用的存储方式。\n在不同字节序的系统间交换数据时，如果不进行字节序的转换，会导致数据解释错误。例如，一个系统以大端模式写入数据，另一个以小端模式读取，未经转换直接读取会得到错误的结果。\n大小端字节序举例 假设有一个4字节（Byte）的整数值 0x12345678，在内存中的存储会根据大小端不同而不同。\n大端（Big Endian）：高位字节（靠近Ox）存于低地址，所以内存布局是 12 34 56 78。 小端（Little Endian）：低位字节存于低地址，所以内存布局是 78 56 34 12。 在内存中，地址从低到高增加。低地址存储较“早”的数据，而高地址存储较“晚”的数据，所以可以近似看成从左往右。\n比如一个字节流的数据如下：\n10010001001011000001\n二进制形式：1001 0001 0010 1100 0001 4个一组，转换16进制：9 1 2 c 1 使用4个字节来表示时，高位补零：00 09 12 c1 小端字节序，低位字节存于低地址： 高位00 -\u0026gt; 高地址 次高位09 -\u0026gt; 次高地址 次低位12 -\u0026gt; 次低地址 低位c1 -\u0026gt; 低地址 实际在内存的中存储位 c1 12 09 00。 具体而言：\nPackage Data Length 594625 -\u0026gt; 内存布局c1 12 09 00 (对应00 09 12 c1) Unit Data: Length 43978 -\u0026gt; 内存布局ca ab 00 00 (实际为 00 00 ab ca) Type 3 -\u0026gt; 内存布局03 00 00 00 (实际为 00 00 00 03) 如果用大端方式读取C1 12 09 00，那么将得到 12653065，这个数字特别大，明显要大于文件大小了\n如果用大端方式读取ca ab 00 00，那么将得到 13282048，这个数字也特别大，并且还大于12653065，所以肯定出错了。\n$594625 \\div 1024 \\div 1024 = 0.57 MB$\n$12653065 \\div 1024 \\div 1024 = 12.07MB$\n$43978 \\div 1024 \\div 1024 = 0.042 MB$\n$13282048 \\div 1024 \\div 1024 = 12.67MB$\n补充说明：\n字节流文件“保存”的是二进制数据，也就是说文件中的数据以二进制形式存放，这意味着每个字节由8位二进制数字（0或1）组成。而使用文件浏览器或某些工具查看这些文件时，常常会看到十六进制的表示，因为十六进制能更有效地展示和定位文件内容，特别是对于非文本数据。\nC++打印时的进制 当在C++中使用 std::cout 打印数字时，除非指定格式（如使用 std::hex 来指定十六进制），否则默认为十进制（ std::dec ）。例如：\nuint32_t num = 0x1234; std::cout \u0026lt;\u0026lt; num; // 默认以十进制输出，打印为 \u0026#34;4660\u0026#34; std::cout \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; num; // 指定十六进制，打印为 \u0026#34;1234\u0026#34; 如果前面使用了std::hex，那么后面的std::cout也会受到影响，因此比较好的策略是用std::hex \u0026laquo; … \u0026laquo; std::dec包起来 C++代码实现 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;iomanip\u0026gt; // For std::setw and std::setfill struct UnitData { uint32_t len; uint32_t type; std::vector\u0026lt;uint8_t\u0026gt; content; UnitData(uint32_t len, uint32_t type, std::vector\u0026lt;uint8_t\u0026gt;\u0026amp; content) : len(len), type(type), content(content) {} }; // 大端 bool readUint32Big(std::ifstream\u0026amp; stream, uint32_t\u0026amp; value) { char buffer[4]; if (stream.read(buffer, 4)) { value = static_cast\u0026lt;uint32_t\u0026gt;((unsigned char)(buffer[3]) | (unsigned char)(buffer[2]) \u0026lt;\u0026lt; 8 | (unsigned char)(buffer[1]) \u0026lt;\u0026lt; 16 | (unsigned char)(buffer[0]) \u0026lt;\u0026lt; 24); return true; } return false; } // 小端 bool readUint32Little(std::ifstream\u0026amp; stream, uint32_t\u0026amp; value) { char buffer[4]; if (stream.read(buffer, 4)) { value = static_cast\u0026lt;uint32_t\u0026gt;((unsigned char)(buffer[0]) | (unsigned char)(buffer[1]) \u0026lt;\u0026lt; 8 | (unsigned char)(buffer[2]) \u0026lt;\u0026lt; 16 | (unsigned char)(buffer[3]) \u0026lt;\u0026lt; 24); return true; } return false; } int main(int argc, char* argv[]) { if (argc != 2) { std::cerr \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;filename\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } std::ifstream file(argv[1], std::ios::binary); if (!file.is_open()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to open file: \u0026#34; \u0026lt;\u0026lt; argv[1] \u0026lt;\u0026lt; std::endl; return 1; } int frameNumber = 0; // Frame counter while (!file.eof()) { // Read and check the header uint8_t header[2]; if (!file.read(reinterpret_cast\u0026lt;char*\u0026gt;(header), 2) || header[0] != 0xFF || header[1] != 0xAA) { if (file.eof()) { break; // Break the loop if EOF is reached during header read } std::cerr \u0026lt;\u0026lt; \u0026#34;Invalid header in frame \u0026#34; \u0026lt;\u0026lt; frameNumber + 1 \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } std::cout \u0026lt;\u0026lt; \u0026#34;Frame \u0026#34; \u0026lt;\u0026lt; ++frameNumber \u0026lt;\u0026lt; \u0026#34; - Header: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; (int)header[0] \u0026lt;\u0026lt; \u0026#34; 0x\u0026#34; \u0026lt;\u0026lt; (int)header[1] \u0026lt;\u0026lt; std::dec \u0026lt;\u0026lt; std::endl; // Read the package length uint32_t packageLength; if (!readUint32Little(file, packageLength)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to read package length.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } std::cout \u0026lt;\u0026lt; \u0026#34;Package Data Length: \u0026#34; \u0026lt;\u0026lt; packageLength \u0026lt;\u0026lt; std::endl; // Process Unit Data uint32_t bytesRead = 0; while (bytesRead \u0026lt; packageLength) { uint32_t unitLen, unitType; if (!readUint32Little(file, unitLen) || !readUint32Little(file, unitType)) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to read unit data.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // Correct the content length by subtracting the length of unitType uint32_t contentLength = unitLen - 4; // Subtracting the 4 bytes of the unitType std::vector\u0026lt;uint8_t\u0026gt; content(contentLength); if (!file.read(reinterpret_cast\u0026lt;char*\u0026gt;(content.data()), contentLength)) { if (file.eof()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: EOF reached before reading all data. Expected \u0026#34; \u0026lt;\u0026lt; contentLength \u0026lt;\u0026lt; \u0026#34; bytes, but less were available.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: Failed to read unit content. Expected \u0026#34; \u0026lt;\u0026lt; contentLength \u0026lt;\u0026lt; \u0026#34; bytes.\u0026#34; \u0026lt;\u0026lt; std::endl; } return 1; } // Print the unit data len and type in hex std::cout \u0026lt;\u0026lt; \u0026#34;Unit Length: \u0026#34; \u0026lt;\u0026lt; unitLen \u0026lt;\u0026lt; \u0026#34;, Unit Type: 0x\u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; std::setw(2) \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(unitType) \u0026lt;\u0026lt; std::dec \u0026lt;\u0026lt; std::endl; bytesRead += 4 + unitLen; } } file.close(); return 0; } ","permalink":"https://ahaknow.com/posts/know/dev-parse-binary-file/","summary":"需要解析相机的字节流文件（就是一个一个Byte组成的文件，不解析的话没有啥实际意义）。 解析需要按照一定的规则，比如：如何确定数据的头（Hea","title":"开发实战：解析二进制文件"},{"content":" 使用Git，在develop分支下创建一个新分支，然后在这个新分支上进行新功能开发。\ngit branch系列操作 1. 列出所有本地分支 git branch 2. 列出所有远程分支 git branch -r 3. 列出所有本地和远程分支 git branch -a 4. 创建新分支 创建新分支但不切换到该分支：\ngit branch feature-x 这会创建一个名为feature-x的分支，但依然停留在当前分支。\n5. 删除分支 删除本地分支：\ngit branch -d feature-x 这个命令会安全地删除分支，只在这个分支已经被合并到当前分支时允许删除。如果分支还有未合并的更改，需要强制删除可以使用-D选项：\ngit branch -D feature-x 6. 重命名分支 如果你需要重命名当前分支：\ngit branch -m new-branch-name 如果要重命名其他分支（不在该分支上时）：\ngit branch -m old-branch-name new-branch-name 实际操作中的应用 通常会这样使用git branch来创建新分支：\ngit checkout develop # 确保你在develop分支 git pull origin develop # 拉取最新的develop分支 git branch feature-x # 创建新分支feature-x git checkout feature-x # 切换到新分支feature-x 这里的步骤可以简化为一个命令，使用git checkout -b同时创建并切换分支：\ngit checkout -b feature-x develop 这条命令直接基于develop分支创建并切换到feature-x分支。\n","permalink":"https://ahaknow.com/posts/know/note-git-branch-basic/","summary":"使用Git，在develop分支下创建一个新分支，然后在这个新分支上进行新功能开发。 git branch系列操作 1. 列出所有本地分支 git branch 2. 列出所有远","title":"Git：分支的基本操作"},{"content":" 问题描述：\nLinux同时连接局域网，网段是172.27.0.x，以及连接网口的相机设备，网段是192.168.80.x。\nLinux启动后出现这种情况：\n可以连接相机，但无法上网 将相机的网线拔掉后，就能够上网了 简单的分析一下，应该是网络占用的问题。\n先把问题解决了 sudo apt-get install net-tools 下面具体来分析\n通过route -n来查看路由表信息：\n❯ route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.80.1 0.0.0.0 UG 0 0 0 eno1 0.0.0.0 172.27.0.1 0.0.0.0 UG 101 0 0 eno1 169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 enx0826ae3c0c7b 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 172.27.0.0 0.0.0.0 255.255.255.0 U 101 0 0 eno1 192.168.80.0 0.0.0.0 255.255.255.0 U 100 0 0 enx0826ae3c0c7b 可以看出来有两个设备，一个是eno1，局域网网线，另一个是enx0826ae3c0c7b，网口的相机。\n为啥会上不了网捏？\n观察这个路由表的可以发现有一个重复的混乱项：\nDestination 为 0.0.0.0 但是 Gateway 却有两个，就是这里导致的，这时候的解决方法就是，先清除默认路由，然后再配置一个正确的默认路由。\n步骤1：清除错误的默认路由\n首先，删除所有默认路由：\nsudo ip route del default 步骤2：添加正确的默认路由\n将默认路由设置为通过网关`172.27.0.1，并指定合适的度量值：\nsudo ip route add default via 172.27.0.1 dev eno1 metric 0 步骤3：验证路由表\n再次检查路由表，确保只有一个默认路由，并且其他路由按预期配置：\nroute -n 这个时候得到的应该就是正确的路由表了：\n❯ route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 172.27.0.1 0.0.0.0 UG 0 0 0 eno1 0.0.0.0 172.27.0.1 0.0.0.0 UG 101 0 0 eno1 169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 enx0826ae3c0c7b 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 172.27.0.0 0.0.0.0 255.255.255.0 U 101 0 0 eno1 192.168.80.0 0.0.0.0 255.255.255.0 U 100 0 0 enx0826ae3c0c7b 另一种思路 在路由表中，metric值用于定义路由的优先级。当存在多条到达同一个目的地的路由时，metric值较小的路由将被优先选择用于数据传输。因此，metric是一种决定路径选择的方法，尤其在多个网络接口可用时这一点非常重要。\nMetric 的含义和作用 含义：metric值是一个数字，用于表示路由的优先级。数字越小，该路由的优先级越高。 作用： 选择最优路径：在多条路由可达同一目的地的情况下，路由器根据metric值选择metric最小的路由作为最佳路径。 负载均衡：在某些配置中，可以故意设置相同的metric值给不同的路由，以实现负载均衡。 避免路由循环：适当的metric值配置可以帮助避免路由循环，特别是在复杂的网络拓扑中。 Metric 值的选择 比如，metric值为0, 101, 100, 1000等，这些都是用来区分不同路由条目的相对优先级。例如：\nMetric 为 0：通常表示该路由具有最高的优先级，系统将优先通过这个路由发送数据。 Metric 为 101 或 100：这些值较高，表示路由的优先级较低。如果默认路由（metric 为 0 的路由）不可用，系统可能会考虑使用这些路由。 Metric 为 1000：更高的metric值，通常用于备份路由，只有在其他较低metric值的路由全都不可用时，才会被使用。 因此上述的问题还可以通过更改路由的优先级来解决\n现在问题解决了，但是解决了一时，解决不了一世，如果Linux主机重新启动，那么又会恢复为原来的设置，怎么办呢？\n那就设置一个自动化的启动项！\n自动化的“一劳永逸” 创建一个自定义的systemd服务，可以通过调整systemd服务来确保在执行路由删除和添加操作之前，网络接口已经正确初始化。此外，还可以加入条件判断，只在默认路由存在时尝试删除它。\n修改 Systemd 服务文件： 编辑之前创建的systemd服务文件，添加条件判断和依赖关系，确保在执行路由操作前网络接口已准备好。\nsudo vim /etc/systemd/system/setdefaultgateway.service 修改服务文件，加入网络在线的条件和执行命令前的检查：\n[Unit] Description=Set default gateway Wants=network-online.target After=network-online.target [Service] Type=oneshot ExecStartPre=/bin/sh -c \u0026#39;ip route | grep -q default \u0026amp;\u0026amp; ip route del default\u0026#39; ExecStart=/sbin/ip route add default via 172.27.0.1 dev eno1 metric 0 RemainAfterExit=yes [Install] WantedBy=multi-user.target 这里ExecStartPre行用于检查是否存在默认路由，并且只有在存在的情况下才尝试删除它。这样可以避免因为尝试删除一个不存在的路由而导致服务失败。\n重新加载和启动服务： 加载新的配置并重新启动服务：\nsudo systemctl daemon-reload sudo systemctl restart setdefaultgateway 检查服务状态： 确保服务现在能够成功执行，不再报错：\nsudo systemctl status setdefaultgateway 通过确保在网络接口准备好后执行命令，并且只在默认路由存在时尝试删除它，能够避免服务启动时遇到的“RTNETLINK answers: No such process”错误。\n服务文件的部分解释 [Unit]部分： Description: 仅为此服务提供描述，说明其用途。 Wants: 这一行指定了此服务想要的其他单位（unit）。network-online.target是一个特殊的目标，代表网络配置已完全完成且互联网连接已建立。 After: 这一行确保了在network-online.target之后才启动这个服务。也就是说，只有在网络确实可用之后，此服务才会运行其命令。 这两个设置（Wants和After）确保了网络服务在尝试修改路由表之前已经完全启动和激活。这是非常重要的，因为如果在网络接口还没有激活的情况下尝试设置路由，可能会导致命令失败。\n[Service]部分： Type=oneshot: 这意味着这个服务在启动时运行一次然后结束，不会持续运行。 ExecStartPre: 这是在主命令（ExecStart）执行之前运行的命令。它的作用是检查当前路由表中是否存在默认路由： /bin/sh -c 'ip route | grep -q default \u0026amp;\u0026amp; ip route del default'：这条命令会首先查找是否存在默认路由，如果存在（grep -q default 返回0），则执行删除默认路由的命令（ip route del default）。这里使用grep -q是为了静默模式，只返回存在与否的状态码而不输出文本。 ExecStart: 这是服务的主命令，用于添加新的默认路由。如果前面的默认路由已被删除，这条命令会无障碍地设置新的默认路由。 RemainAfterExit=yes: 通常用于Type=oneshot的服务，指示即使服务的主进程已经结束，此服务的状态依旧被视为激活。 这种配置方式，特别是ExecStartPre命令的使用，是为了确保修改默认路由时不会因为旧的路由设置存在而出现冲突或错误。通过这样的安排，服务在执行任何操作之前确保了网络接口的可用性和清理了可能存在的冲突配置，从而使得默认网关的设置更加可靠和稳定。\n","permalink":"https://ahaknow.com/posts/know/linux-repair-routing-table/","summary":"问题描述： Linux同时连接局域网，网段是172.27.0.x，以及连接网口的相机设备，网段是192.168.80.x。 Linux启动后出现","title":"Linux：上不了网了之路由表修复"},{"content":"Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2:\nInput: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 105 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 0 \u0026lt;= k \u0026lt;= 105 Follow up:\nTry to come up with as many solutions as you can. There are at least three different ways to solve this problem. Could you do it in-place with O(1) extra space? 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n示例 1:\n输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2:\n输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 105 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 0 \u0026lt;= k \u0026lt;= 105 进阶：\n尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 轮转数组，比较直接的方法就是重新开辟了一个新数组，然后复制过去，这种方法能够解决问题，但是不够巧妙。\n再进一步想，可以环状替换，这种方法就比较有意思，需要一个额外的中间变量，然后实现一种环状的，前后衔接的，依次交替的更换（这种方法稍微有点复杂，动手笔画理解得可能更好）。\n另外一种就比较奇特，**通过多次整体翻转的策略，**这个算法将在下文中仔细说明。\n🌽上菜 方法一：使用额外数组 可以创建一个新的数组来重新排列元素。\n遍历原数组，将每个元素放置到 (i + k) % n 的位置上。 将新数组复制回原数组。 这种方法的空间复杂度是 O(n)。\n方法二：环状替换 这种方法可以不使用额外的空间，直接在原数组上操作：\n从某个位置开始，将其元素放到正确的位置上，同时把目标位置的原元素保存下来。 继续操作新位置的元素，直到回到起始位置。 如果数组有多于一个的独立循环（例如，数组长度和 k 的最大公约数大于1），需要从数组中不同的位置开始，直到每个元素都被移动过。 这种方法的空间复杂度是 O(1)，因为它是原地操作。\n用实际的例子来理解“环状替换”：\n环状替换举例 1 2 3 4 需要移动 2 位，变成 3 4 1 2\n从下标0开始，start = 0，prev = nums[0] = 1；（起点）\n需要替换的在0 + 2的位置，next = 2，temp = nums[2] = 3；\n发生替换（使用prev）：1 2 1 4；更新：prev = temp = 3；current = next = 2；\n循环继续；\ncurrent = 2；需要替换的在0 + 2的位置（与nums.size()取模），current = 0；temp = nums[0] = 1；（终点，这里就又回到了起点，形成了闭环）\n发生替换（使用prev）：3 2 1 4；\n此时current == start，说明这一轮遍历结束，start 需要更新；\n循环中止，start + 1；\n从下标1开始，start = 1，prev = nums[1] = 2；（起点）\n需要替换的在1 + 2的位置，next = 3，temp = nums[3] = 4；\n发生替换（使用prev）：3 2 1 2；更新：prev = temp = 4；current = next = 3；\n循环继续；\ncurrent = 3；需要替换的在3 + 2的位置（与nums.size()取模），current = 1；temp = nums[1] = 2；（终点，又回到了起点，形成了闭环）\n发生替换（使用prev）：3 4 1 2；\n此时current == start，说明这一轮遍历结束，start 需要更新；\n循环中止，start + 1；\n此时已经完成排序了，可以退出程序了。\n具体的循环退出依据可以通过数组长度和轮转次数的最大公约数得到。\n环状替换中的GCD（最大公约数） 当将数组中的每个元素向右移动 k 个位置时，可以通过 $i \\rightarrow (i + k) % n$ 的映射关系来理解每个元素的新位置，其中 i 是原始索引，n 是数组的长度。\n但是使用这种映射，得需要知道这种循环结构何时会回到起点，也就是形成一个闭合的循环。\n循环长度和返回起点：\n当从某个索引 start 开始，不断应用 $i \\rightarrow (i + k) % n$ 映射，我们想要知道什么时候会回到 start 索引。这就意味着寻找最小的正整数 m，使得 $(start + m \\cdot k) % n = start$。简化后得到 $(m \\cdot k) % n = 0$，即 $m \\cdot k$ 应该是 n 的倍数。 最小的 m 值：\n要找到最小的 m，使得 $m \\cdot k$ 是 n 的倍数，等价于找到最小的 m 使得 $\\frac{m \\cdot k}{n}$ 是一个整数。这意味着 m 是一个特定的值，使得 $m \\cdot k$ 能够整除 n。这就需要 k 中的任何可能因子已经在 n 中有对应的因子以保证整除。 GCD（最大公约数）是 k 和 n 的共同最大因子。当我们通过 GCD 来除 n 和 k，实际上是在移除两者共有的所有因子，所得的比例（k/GCD 和 n/GCD）是最简形式，没有更多的公共因子。 使用 GCD，我们可以重新定义 k 和 n： $k\u0026rsquo; = \\frac{k}{\\text{gcd}(k, n)}$ $n\u0026rsquo; = \\frac{n}{\\text{gcd}(k, n)}$ 现在 $k\u0026rsquo;$ 和 $n\u0026rsquo;$ 互质（即没有共同因子），因此最小的 m 使得 $(m \\cdot k\u0026rsquo;) % n\u0026rsquo; = 0$ 就是 n'，即 $n / \\text{gcd}(k, n)$。 因此，$m = \\frac{n}{\\text{gcd}(k, n)}$ 是使得 $(i + m \\cdot k) % n = i$ 成立的最小 m 值，这里的 gcd 表示 k 和 n 的最大公约数。 循环的数量：\n如果从数组中的每个 start 点开始都运行一个循环，通过 k 和 n 的最大公约数可以知道，从一个给定的起点开始，会在经过 $n / \\text{gcd}(k, n)$ 步后回到起点。 因此，要遍历所有可能的起点（确保每个元素都被移动到正确的位置），需要从 gcd(k, n) 个不同的起点开始，每个起点所经历的循环都是这个全覆盖循环的独立的一部分。 假设 n = 12 和 k = 8：\n$\\text{gcd}(12, 8) = 4$。 从 0 开始的循环会经过索引 $0 \\rightarrow 8 \\rightarrow 4 \\rightarrow 0$，形成一个长度为3的循环。 因为 gcd 是 4，可以从 0, 1, 2, 3 这四个起点开始（这里也可以观察出：起点4是没必要，因为已经出现在起点为0的循环中了），每个起点都会形成一个独立的循环，这些循环共同覆盖整个数组。 计算 GCD 的方法 GCD 可以使用辗转相除法（Euclidean algorithm）来计算，这是一种高效的算法。\n辗转相除法，也被称为欧几里得算法（Euclidean algorithm），是一种用于计算两个整数的最大公约数（GCD，Greatest Common Divisor）的古老算法。这个算法基于一个简单的原理：两个数的最大公约数不变，如果较大数减去较小数。更具体地说，给定两个正整数 $a$ 和 $b$，其中 $a \u0026gt; b$，那么 $gcd(a, b)$ 等于 $gcd(b, a - b)$。但为了效率，通常使用除法代替减法。\n以下是计算 GCD 的简单函数实现：\nint gcd(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a; } 基本步骤：\n将较大数除以较小数。 将除法的余数替换到较小数的位置。 重复这个过程，直到其中一个数变成零。 当余数为零时，另一个数就是最大公约数。 形式上，算法可以描述为：\n输入：两个正整数 $a$ 和 $b$。 输出：$a$ 和 $b$ 的最大公约数 $gcd(a, b)$。 比如计算 $252$ 和 $105$ 的最大公约数：\n$gcd(252, 105)$ $252 \\mod 105 = 42$，现在计算 $gcd(105, 42)$ $105 \\mod 42 = 21$，现在计算 $gcd(42, 21)$ $42 \\mod 21 = 0$，结束。所以，最大公约数是 $21$。 ‼️有一点重要的点，算法本身具有自校正的特性，即使 $b$ 大于 $a$，它仍然可以正确工作。\n这是因为在算法的每一步中，都是取两个数的余数来进行下一次迭代，这个过程会自动调整两个数的顺序。\n如果在算法开始时 $b \u0026gt; a$，那么在第一次迭代中，余数将是 $a$（因为 $a \\mod b = a$ 当 $a \u0026lt; b$），然后 $a$ 和 $b$ 的角色在下一次迭代中就会交换。这就自然地保证了接下来的迭代中较大的数总是被较小的数除，算法的逻辑不会受到初始条件的影响。\n举例：\n假设 $a = 18$ 和 $b = 24$，需要找到它们的最大公约数。\n迭代 1:\n$b = 24, a = 18$ $a \\mod b = 18 \\mod 24 = 18$（因为 18 小于 24） 接下来，$b$ 变为 18，$a$ 变为 24。 迭代 2:\n$b = 18, a = 24$ $a \\mod b = 24 \\mod 18 = 6$（现在按正常的逻辑进行） $b$ 变为 6，$a$ 变为 18。 迭代 3:\n$b = 6, a = 18$ $a \\mod b = 18 \\mod 6 = 0$（余数为 0，结束） $gcd$ 是 6。 不论 $a$ 和 $b$ 的初始大小关系如何，欧几里得算法总能正确地调整并找到最大公约数。这也是为什么这种算法非常强大和灵活的原因之一。\n欧几里得算法还可以扩展到更一般的情况，如求解线性方程、多项式的最大公约数，以及非欧几里得域（如高斯整数）的公约数计算等。还有一些变种和改进方法，包括：\n扩展欧几里得算法：\n不仅计算最大公约数，还找到整数解 $x$ 和 $y$，使得 $ax + by = gcd(a, b)$。这在某些数论和密码学应用中非常重要。 二进制GCD算法：\n也称为Stein算法，这种方法不使用除法，而是基于更简单的位运算来计算最大公约数，效率在某些硬件上更优。 多项式GCD：\n使用类似欧几里得算法的方法来找到两个多项式的最大公共因子。 使用这个 gcd 函数，我们可以计算出 n 和 k 的 GCD，从而确定需要进行的环状替换的起始位置数。\n方法三：反转数组 使用数组反转可以巧妙地实现旋转，而不需要额外的空间：\n反转整个数组：这一步把数组的头部移到尾部，尾部移到头部。 反转前 k % n 个元素：由于整个数组已经被反转，最初的最后 k % n 个元素现在位于数组的前部。再次反转这部分可以恢复它们的原始顺序。 反转剩余的 n - k % n 个元素：这样可以恢复这部分元素的原始顺序。 这同样是一个空间复杂度为 O(1) 的原地算法。\n举例说明 假设数组为 [1,2,3,4,5,6,7]，需要向右移动 k = 3 步。\n初始数组：[1,2,3,4,5,6,7] 反转整个数组：[7,6,5,4,3,2,1] 反转前 k % n = 3 个元素：[5,6,7,4,3,2,1] 反转剩余 n - k = 4 个元素：[5,6,7,1,2,3,4] 不够轮转的k 是多少，整个操作只涉及三次数组遍历，因此时间复杂度为 $O(n)$，而且不需要额外的存储空间，空间复杂度为 $O(1)$。\n核心思想 这里需要细品的是：\n同样反转两次，可以复原操作 所以先整体反转，再局部反转 代码实现 // 189. Rotate Array #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 方法一 使用额外的数组 class Solution { public: void rotate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); // 错误写法，自己反思一下吧 // k = n % k; // 处理给的k大于n的情况 k = k % n; vector\u0026lt;int\u0026gt; nums_new(n); for (int i = 0; i \u0026lt; n; i++) { // 注意这种错误写法 // nums_new[i] = nums[i + k]; // 肯定要从nums[0]开始，不然会越界的 nums_new[(i + k) % n] = nums[i]; } nums = nums_new; } }; // 方法二 环状替换（循环替换） class Solution { public: // 需要计算最大公约数 int gcd(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a; } void rotate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); k = k % n; int end = gcd(n, k); for (int start = 0; start \u0026lt; end; start++) { int current = start; int prev = nums[start]; do { // 注意这里写错了 // int next = (start + k) % n; // 因为已经知道current，start标记的是大循环 int next = (current + k) % n; int temp = nums[next]; nums[next] = prev; prev = temp; // 还需要更新current current = next; } while (current != start); } } }; // 方法三 反转数组 // 直接使用vector的reverse方法 class Solution { public: void rotate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); k = k % n; reverse(nums.begin(), nums.end()); // 反转两次，顺序就会复原 // 左闭右开区间 reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); } }; ","permalink":"https://ahaknow.com/posts/know/leetcode-189-rotate-array/","summary":"Given an integer array nums, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3]","title":"Leetcode：189. 轮转数组"},{"content":"Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\nExample 1:\nInput: nums = [3,2,3] Output: 3 Example 2:\nInput: nums = [2,2,1,1,1,2,2] Output: 2 Constraints:\nn == nums.length 1 \u0026lt;= n \u0026lt;= 5 * 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 Follow-up: Could you solve the problem in linear time and in O(1) space?\n给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例 1：\n输入：nums = [3,2,3] 输出：3 示例 2：\n输入：nums = [2,2,1,1,1,2,2] 输出：2 提示：\nn == nums.length 1 \u0026lt;= n \u0026lt;= 5 * 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 进阶： 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。\n第一反应是分别计数，这种方法显然有点笨。。。\n因为题目想找出现次数最多的数字（这种题目要求大于一半数量，说明肯定有大于一半数量存在的），其实可以这样，不用分别计数，而是按照顺序依次“增减”计数，比如：\n1 1 2 2 1 1\n最开始遇到1，遇到1就计数+1，遇到不是1就计数-1，如果这个数字大于一半数量，那么增增减减之后，一定也还是大于零\n🥬上菜 在这个问题中，需要找到一个出现次数超过 ⌊n/2⌋ 次的多数元素。对于这种问题，有一种非常高效的解决方法，称为 Boyer-Moore 投票算法。这种算法可以在 O(n) 时间复杂度内找到多数元素，并且其空间复杂度为 O(1)。\nBoyer-Moore 投票算法 其核心思想是通过一种巧妙的方式取消掉非多数元素的计数，来找到多数元素。具体步骤如下：\n初始化：设置两个变量，candidate（候选人）初始化为任意值，count（计数）初始化为 0。 第一遍遍历：遍历数组 nums。 如果 count 为 0，设当前元素为 candidate。 如果当前元素等于 candidate，增加 count。 否则减少 count。 第二遍遍历：验证 candidate 是否为多数元素（这一步在题目中可以省略，因为题目保证了总是存在多数元素）。 计算 candidate 的出现次数。 如果出现次数大于 ⌊n/2⌋，返回 candidate。 直觉的理解：\n每次在找到两个不同的元素时就将它们“抵消”。如果一个元素的数量超过总数的一半，那么即使它与其他所有不同的元素进行抵消，最后仍然会剩余该元素，因为它的数量多于其他所有元素的总和。\n但是要注意这个算法成立的关键前提：数组中存在一个多数元素，其出现次数严格大于数组长度的一半。\n实现代码（C++） // 169. Majority Element #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int candidate; int count = 0; for (int num : nums) { // 说明增增减减之后又回到零 if (count == 0) { candidate = num; } count += (candidate == num) ? 1 : -1; } // 由于题目限制，下面的判断可以省略（但其实很必要） // count = 0; // for (int num : nums) { // if (num == candidate) { // count++; // } // } // if (count \u0026gt; nums.size() / 2) return candidate; return candidate; } }; ","permalink":"https://ahaknow.com/posts/know/leetcode-169-majority-element/","summary":"Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array. Example 1: Input: nums = [3,2,3] Output: 3 Example 2: Input: nums = [2,2,1,1,1,2,2] Output: 2 Constraints: n == nums.length 1 \u0026lt;= n \u0026lt;= 5 * 104 -109 \u0026lt;= nums[i] \u0026lt;=","title":"Leetcode：169. 多数元素"},{"content":"Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,_,_] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums is sorted in non-decreasing order. 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n说明：\n为什么返回数值是整数，但输出的答案是数组呢？\n请注意，输入数组是以 「引用」 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例 1：\n输入：nums = [1,1,1,2,2,3] 输出：5, nums = [1,1,2,2,3] 解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。 示例 2：\n输入：nums = [0,0,1,1,1,1,2,3,3] 输出：7, nums = [0,0,1,1,2,3,3] 解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按升序排列 这和上一题的区别就是重复的元素只出现两次\n其实解题的本质和上一题是一样的，还是使用双指针，但是实现逻辑上稍有不同，需要注意‼️\n不管是只出现两次还是n次，\n因为是升序排列，只能出现一次是比较一次，那么只能出现两次那就判断两次\n但比较一次可以简化为比较不同，比较两次则要保证不受到原地替换的影响，在逻辑上有巧妙之处。\n🌽上菜 这个问题是前一个问题的一个变体，不同之处在于需要保留每个元素最多两次，而不是一次。因此，仍然可以采用双指针的方法来解决这个问题，只是需要对比较逻辑做一些调整，以确保每个元素最多出现两次。\n解题思路：\n使用两个指针 slow 和 fast。其中 slow 指针用来指示处理后的数组的末尾位置，而 fast 指针用来遍历整个数组。 需要确保 slow 指向的新数组中，每个元素最多出现两次。这可以通过比较 nums[fast] 与 nums[slow-2]（而不是 nums[slow-1]）来实现，因为这次是允许每个元素出现两次。 当 fast 指针指向的元素与 slow-2 指针指向的元素不同，或者 slow 小于2（意味着还没有填充两个元素）时，将 nums[fast] 的值复制到 nums[slow]，然后递增 slow。 需要特别注意： if (nums[fast] != nums[slow - 2])，与之前的写法不同！\n具体代码实现（C++）如下：\n#include \u0026lt;vector\u0026gt; using namespace std; int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() \u0026lt;= 2) return nums.size(); int slow = 2; // 因为允许元素最多出现两次，所以从索引2开始检查 for (int fast = 2; fast \u0026lt; nums.size(); ++fast) { if (nums[fast] != nums[slow - 2]) { nums[slow++] = nums[fast]; } } return slow; } 这段代码有效地在原地修改了数组，同时只使用了 O(1) 的额外空间。时间复杂度为 O(n)，因为只需要需要遍历一次数组。空间复杂度为 O(1)，因为没有使用额外的存储空间，只是在原数组上进行了操作。\n💣特别注意 在处理有序数组中删除重复元素，并保留最多两个重复元素的情景中，使用 if (nums[fast] != nums[slow - 2]) 和使用 if (nums[fast - 2] != nums[fast]) 进行判断有本质的不同，主要因为这两种判断方式所依赖的逻辑和数组的修改方式不同。\nif (nums[fast] != nums[slow - 2]) 这种判断方式是在原地修改数组，通过保持一个 slow 指针来跟踪应该写入的位置。这个条件检查的是当前正在遍历的元素（由 fast 指针指示）是否与 slow - 2 位置的元素不同。这样可以确保每个元素最多出现两次。当数组中前两个元素已经存在时，这种方法可以保证不会超过两个相同的元素被连续保留。\n优点：\n它允许在已经有两个元素的情况下继续放置新元素，只要新元素与 slow - 2 的元素不同。 if (nums[fast - 2] != nums[fast]) 这种方法的关键在于比较当前元素与它前面第二个元素是否不同。这种方法适用于检查整个数组并判断哪些元素应该被保留，不适合在使用 slow 和 fast 指针原地修改数组的情境。在初始数组中，如果用这种判断方法，那么从第三个元素开始，每个元素都要与它前面的第二个元素比较，如果相同，则说明它是第三次或更多次重复出现。\n问题：\n这种方法假设每个元素的前两个元素已经确定并且正确地处理过，这在初始化阶段并不总是成立。 在使用双指针进行原地操作时，这种判断不能正确地更新 slow 指针的位置，因为它基于遍历过程中之前的元素的状态，而在 slow 和 fast 指针操作中，我们需要基于动态更新的数组状态进行判断。 if (nums[fast] != nums[slow - 2]) 是针对双指针原地修改数组设计的，能有效处理只保留最多两个重复元素的要求，而 if (nums[fast - 2] != nums[fast]) 更多的是一种检查方式，用于理解和分析，但不适合直接用于双指针原地修改数组的具体实现。\n举例说明 如果是if (nums[fast - 2] != nums[fast]):\n1 1 1 2 2 3 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针相同，快指针继续循环，慢指针位置不变 1 1 1 2 2 3 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 2 3 ⬆慢 1 1 2 2 2 3 注意由于慢指针的替换，导致此时原始数组发生变化 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针相同，快指针继续循环，慢指针位置不变 1 1 2 2 2 3 ⬆快 ⬆快-2 ⬆慢 快指针与快-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 3 2 3 ⬆慢 结果错误❌ 如果是if (nums[fast] != nums[slow - 2])：\n1 1 1 2 2 3 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针相同，快指针继续循环，慢指针位置不变 1 1 1 2 2 3 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 2 3 ⬆慢 1 1 2 2 2 3 注意由于慢指针的替换，导致此时原始数组发生变化 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 2 3 ⬆慢 1 1 2 2 2 3 ⬆快 ⬆慢-2 ⬆慢 快指针与慢-2指针不相同，发生替换，并触发一次慢指针的增加 1 1 2 2 3 3 ⬆慢 快指针到头，循环结束 结果正确✅ 🌟与上一题的区别 对于上一题，即移除所有重复的元素使每个元素只出现一次的情况，使用 if (nums[fast] != nums[fast - 1]) 对结果没有影响，分析如下：\n原地操作 在数组操作中，“原地”意味着不需要额外的空间来存储输出，仅允许使用常数级别的额外空间。在使用 if (nums[fast] != nums[fast - 1]) 的双指针策略中，直接在输入数组 nums 上进行修改，不需要额外的存储空间（除了几个指针变量）。这是一种原地操作，因为它直接在原数组上进行元素的重写和覆盖，没有使用新的数组结构来存储结果。\n使用 if (nums[fast] != nums[fast - 1])也可以的原因 这个条件是用来检查当前快指针 fast 指向的元素是否与它前一个元素相同。这里的关键是理解我们的目标是保证数组中每个元素只出现一次。由于数组是有序的，所有的重复元素都会连续出现。因此，只需要检查当前元素是否与前一个元素不同：\n如果 不同，则表示当前元素是一个新的元素，应该被保留。这时你就将当前 fast 指向的元素复制到 slow 指针的位置，然后递增 slow。 如果 相同，则快指针 fast 继续向前移动，直到找到一个不同的元素。 如果是 if (nums[fast] != nums[slow - 1]) 效果也一样。\n在只允许每个元素出现一次的问题中，关注的是确保不复制相同的元素到 slow 指向的位置。而在允许每个元素出现两次的问题中，关注点则是允许至多两个重复元素。\nslow - 2的关键在于：保证slow-2到slow之间是相同的元素，并且用fast指针进行比较时，是有一个比较参考，而不是自己和自己比（有点需要意会的意思，慢慢品）\n","permalink":"https://ahaknow.com/posts/know/leetcode-80-remove-duplicates-from-sorted-array-ii/","summary":"Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements","title":"Leetcode：80. 删除有序数组中的重复项 II"},{"content":" 我发现我的思维特别容易发散，就是干这一件事，脑海中突然有了其他灵感，此前的做法是“直接插队的优先队列”，就是放下手中活，把突然想到去办了，其实这种方法有时候并不好，容易“本末倒置”，原本的事到最后没做好。\n所以，再次把一写博客的灵感记录下来，然后一件一件事情按部就班完成了再来处理这里。\n在此之前已经实现了很多想法，比如一些美化操作（哼，徒有外表，华而不实！！），就不记录了；之后新产生的，在此记录。\n文章元数据显示等美化 字体替换与加速 时间线按照最近更新时间排序 Hugo里面时间计算的原理需要优化（公式优化） Hugo的模版页面自定义 使用jsDelivr配合Github实现文件读取加速 文章缩略截断的字数修改 添加访问次数 paginav的部分显示不下的文字用省略号 ","permalink":"https://ahaknow.com/posts/know/blog-todo/","summary":"我发现我的思维特别容易发散，就是干这一件事，脑海中突然有了其他灵感，此前的做法是“直接插队的优先队列”，就是放下手中活，把突然想到去办了，其","title":"Blog：奇思妙想待办项"},{"content":" 记录一些实用Hugo写博客的小技巧。\n—— 因为如果当时不记录，那么日后肯定不会再记录的！（懒！）\n使用Archetype预设模版 在使用 hugo new 命令创建新内容时，你可以指定使用特定的 archetype。Archetype 是 Hugo 中的模板文件，用于预设新内容文件的元数据和结构。默认情况下，Hugo 会使用名为 default.md 的 archetype，但可以创建和指定其他 archetype 来满足不同类型内容的需求。\n创建自定义 Archetype 在 Hugo 站点的根目录中，archetypes 目录用于存放 archetype 文件。\n可以在这个目录下创建新的 archetype 文件。例如，创建一个名为 blog.md 的文件，用于博客帖子：\narchetypes/blog.md 编辑 blog.md 文件，定义你想要预置的内容和 Front Matter，例如：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true tags: [] --- 在这里写博客内容... 使用自定义 Archetype 创建内容 当创建新内容时，可以通过指定 archetype 的名称来使用它。格式如下：\nhugo new \u0026lt;路径\u0026gt;/\u0026lt;文件名\u0026gt;.\u0026lt;扩展名\u0026gt; --kind \u0026lt;archetype名称\u0026gt; 或者，如果创建的内容直接位于 archetypes 下的同名目录中，你只需指定路径，Hugo 会自动寻找匹配的 archetype。例如，如果有一个名为 blog.md 的 archetype，就可以这样创建新的博客帖子：\nhugo new blog/我的新博客帖子.md 这里，Hugo 会在 archetypes 目录下寻找名为 blog.md 的文件，并使用它作为新内容文件的模板。\n如果想显式地使用特定的 archetype 而不依赖于目录结构，可以使用 --kind 参数，像这样：\nhugo new posts/我的新博客帖子.md --kind blog 这命令会创建一个新的内容文件 posts/我的新博客帖子.md，并使用 archetypes/blog.md 作为模板。\n在文章内链接导航其他文章 在Hugo中创建文章间的超链接，最佳实践是使用相对URL或者Hugo的内置函数来生成URL。这样做的好处是可以保持链接的持久性，即使你的站点URL发生变化，链接也不会断裂。以下是几种在Hugo中链接到另一个本地文章的方法：\n1. 使用相对URL 如果知道目标文章的路径，可以直接在Markdown文件中使用相对URL创建链接。例如，如果想从位于 /content/posts/my-first-post.md 的文章链接到 /content/posts/my-second-post.md，可以这样写：\n请查看我的[第二篇文章](../my-second-post/) 这里使用的是相对于当前文件的路径。注意，链接的路径部分应该与目标Markdown文件的位置相对应，且通常情况下，不包括文件扩展名.md。\n2. 使用Hugo的ref和relref短代码 Hugo提供了ref和relref短代码，这两个短代码可以生成到站点内任何页面的永久链接。这是一种更健壮的链接方法，因为它不依赖于站点的部署路径。这两个短代码的区别在于ref可以用于任何站点（得到绝对路径）页面，而relref仅用于相同语言（得到相对路径）的页面。\n假设想链接到位于/content/posts/know/blog-tips.md的文章，可以在任何Markdown文件中这样写：\n请查看我的[第二篇文章](两个{\u0026lt; relref \u0026#34;/posts/know/blog-mac-style-code.md\u0026#34; \u0026gt;两个}) 实际效果就是这样的：\n请查看我的[第二篇文章](/posts/know/blog-mac-style-code/) 或者\n请查看我的[第二篇文章](两个{\u0026lt; ref \u0026#34;/posts/know/blog-mac-style-code.md\u0026#34; \u0026gt;两个}) 实际效果如下：\n请查看我的[第二篇文章](https://ahaknow.com/posts/know/blog-mac-style-code/) 使用ref或relref短代码时，需要指定目标文件的路径从content目录的下一个目录开始（也就是hugo new时使用的路径文件名）。\n当使用ref和relref短代码时，确保路径是从content文件夹开始的相对路径，并且包括文件的扩展名.md。 如果站点支持多语言，relref是链接到当前语言下的相对内容，而ref可用于链接到任何语言的内容（因为hugo的不同语言通过url区分）。 使用ref和relref的另一个好处是，如果目标链接不存在，Hugo在构建站点时会报错，这有助于你及时发现并修正死链（所以上述使用的是真实存在的文件路径）。 ","permalink":"https://ahaknow.com/posts/know/blog-tips/","summary":"记录一些实用Hugo写博客的小技巧。 —— 因为如果当时不记录，那么日后肯定不会再记录的！（懒！） 使用Archetype预设模版 在使用 hugo new 命令创","title":"Blog：Hugo写作小技巧 "},{"content":"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -100 \u0026lt;= nums[i] \u0026lt;= 100 nums is sorted in non-decreasing order. 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 判题标准:\n系统会用下面的代码来测试你的题解:\nint[] nums = [...]; // 输入数组 int[] expectedNums = [...]; // 长度正确的期望答案 int k = removeDuplicates(nums); // 调用 assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } 如果所有断言都通过，那么您的题解将被 通过。\n示例 1：\n输入：nums = [1,1,2] 输出：2, nums = [1,2,_] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：\n输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按 非严格递增 排列 “非严格递增”的意思是指：序列已经按照从小到大排序了，只不过有些元素重复了，所以是非严格递增；\n有序数列的问题，还是用双指针，只不过指针的用处稍微不同。\n快指针用来判断前后元素是否相同，慢指针用来按照需求保留。\n🥬上菜 这个问题可以使用类似于LeetCode26的解决方案，即使用双指针法。这次也是使用快慢指针，但是有一点不同：当快指针指向的元素与慢指针指向的元素相同时，只移动快指针，以跳过重复的元素；当快慢指针指向的元素不同，将快指针的元素复制到慢指针的下一个位置，然后同时移动快慢指针。\n这样处理后，数组的前 k 个元素就是唯一的元素，并且保持了它们最初的相对顺序，其中 k 是返回的数组长度。\n下面是具体步骤：\n如果数组的长度 n 小于等于1，则直接返回 n（因为没有重复元素需要删除）。 初始化两个指针 slow = 1 和 fast = 1。 当 fast 小于数组长度时，比较 nums[fast] 和 nums[fast - 1]： 如果 nums[fast] 不等于 nums[fast - 1]，说明遇到了一个新的元素，就将 nums[fast] 的值复制到 nums[slow]，然后 slow 增加1。 否则，快指针 fast 继续前进，直到找到一个不同的元素。 当数组遍历完成后，slow 指针的位置就是新数组的长度。 下面是用C++实现的代码示例：\n// 26. Remove Duplicates from Sorted Array #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() \u0026lt;= 1) return nums.size(); int slow = 1; for (int fast = 1; fast \u0026lt; nums.size(); fast++) { if (nums[fast - 1] != nums[fast]) { nums[slow++] = nums[fast]; } } return slow; } }; // 这道题也可以直接使用vector的earse()和unique() // nums.erase(unique(nums.begin(), nums.end()), nums.end()); 这段代码通过双指针法高效地实现了原地删除数组中的重复项，且只使用了 O(1) 的额外空间。由于 nums 是非严格递增排列的，可以确保所有的重复项都是连续出现的，这让问题变得更加简单。\n","permalink":"https://ahaknow.com/posts/know/leetcode-26-remove-duplicates-from-sorted-array/","summary":"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things: Change the array nums such that the first","title":"Leetcode：26删除有序数组中的重复项"},{"content":"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i \u0026lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例 1：\n输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2：\n输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,3,0,4] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示：\n0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100 这道题的用意是指，不能用额外空间。\n不能用额外空间，那就用两个指针。快慢指针，这种设计很巧妙，快指针遍历，慢指针覆盖，因为有筛选，所以原始数组的大小够用\n🥬上菜上菜 可以使用双指针法来实现原地算法。具体来说，可以采用快慢指针的策略：快指针（fast）遍历数组，慢指针（slow）指向更新数组的下一个位置。当遇到与 val 相等的元素时，快指针继续前进，跳过这些元素；当遇到不等于 val 的元素时，将其复制到慢指针的位置，然后慢指针前进。这样，所有不等于 val 的元素都被移动到数组的前面，且不需要使用额外的空间。\n下面是具体的步骤：\n初始化两个指针：fast = 0, slow = 0。 遍历数组，fast 作为遍历的指针，slow 指向下一个可能存放非 val 元素的位置。 如果 nums[fast] 不等于 val，就将 nums[fast] 的值复制到 nums[slow]，然后 slow 前进一位。 fast 指针每次循环都前进一位。 当 fast 遍历完整个数组后，slow 的位置即为新数组的长度。 这种方法之所以高效，是因为它避免了对 val 元素的重复检查和不必要的元素移动。\n下面是用C++实现的代码示例：\n// 27. Remove Element #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 快慢指针 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { // 快指针遍历数组，慢指针按需替换 int slow = 0; for (int fast = 0; fast \u0026lt; nums.size(); fast++) { if (nums[fast] != val) { nums[slow++] = nums[fast]; } } return slow; } }; // 当返回slow后，之后nums[]里有多少个元素，同时nums[]slow位置及以前的都已经按要求替换好，slow位置以后的不管了 这段代码中，fast 和 slow 两个指针分别扮演了遍历数组和更新数组的角色。通过这种方式，可以实现原地修改数组，同时只使用 O(1) 的额外空间。\n","permalink":"https://ahaknow.com/posts/know/leetcode-27-remove-element/","summary":"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things: Change the array nums such that","title":"Leetcode：27移除元素"},{"content":" LeetCode上“最简单”的一道题了吧？\n长时间没有写过题，面试的时候竟然不会写了，奇耻大辱的一件事！\nYou are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints:\nnums1.length == m + n nums2.length == n 0 \u0026lt;= m, n \u0026lt;= 200 1 \u0026lt;= m + n \u0026lt;= 200 -109 \u0026lt;= nums1[i], nums2[j] \u0026lt;= 109 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意: 最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n示例 1：\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2：\n输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3：\n输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示：\nnums1.length == m + n nums2.length == n 0 \u0026lt;= m, n \u0026lt;= 200 1 \u0026lt;= m + n \u0026lt;= 200 -109 \u0026lt;= nums1[i], nums2[j] \u0026lt;= 109 直接使用“双指针”的写法！\n（你还记得你多年未写算法题，想到了双指针，结果一上来写了两个for的蠢事嘛🤣）\n🥬直接上菜 从两个数组的末尾开始，每次取两者之中较大的数，放到 nums1 的合适位置。这样，当 nums2 被完全复制到 nums1 后，合并就完成了，因为 nums1 和 nums2 本来就是有序的。\n下面是详细的步骤：\n初始化两个指针 p1 和 p2 分别指向 nums1 和 nums2 的有数值的末尾，即 p1 = m - 1, p2 = n - 1。同时，初始化 p 指向 nums1 的末尾，即 p = m + n - 1。 比较 p1 和 p2 指向的值，将较大的值放在 p 位置上，并移动指针 p 和被选中的 p1 或 p2。 如果 p2 \u0026gt;= 0 而 p1 \u0026lt; 0，意味着 nums1 已经被遍历完，但 nums2 还有元素未被复制过去，此时直接将 nums2 的剩余元素复制到 nums1 的前面。 如果 p1 \u0026gt;= 0 而 p2 \u0026lt; 0，意味着 nums2 已经被遍历完，nums1 的剩余元素已经在正确的位置，不需要做任何操作。 下面是用C++实现的代码示例：\n// 88. Merge Sorted Array #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 逆向双指针 class Solution { public: void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums1, int m, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int n) { // 确定终点指针 // 合并后留下nums1数组 int p1 = m - 1, p2 = n - 1, p = m + n - 1; // 因为已经排序，逆向考虑就是从大往小 while (p1 \u0026gt;= 0 \u0026amp;\u0026amp; p2 \u0026gt;= 0) { if (nums1[p1] \u0026gt; nums2[p2]) { // 从后往前，先安排大的 nums1[p--] = nums1[p1--]; } else { nums1[p--] = nums2[p2--]; } } // //这时候再看p1和p2谁大于零 // 其实只要看p2是不是大于零就行，因为是从nums2合并到nums1 while (p2 \u0026gt;= 0) { nums1[p--] = nums2[p2--]; } } }; // 这道题可以直接把两个vector加起来，然后一个sort()解决 这段代码通过从后向前遍历 nums1 和 nums2，避免了合并时覆盖 nums1 中未被检查的元素，同时减少了需要移动元素的次数。\n时间复杂度为 O(m+n)，空间复杂度为 O(1)，因为它不需要额外的存储空间。\n","permalink":"https://ahaknow.com/posts/know/leetcode-88-merge-sorted-array/","summary":"LeetCode上“最简单”的一道题了吧？ 长时间没有写过题，面试的时候竟然不会写了，奇耻大辱的一件事！ You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n,","title":"Leetcode：88合并两个有序数组"},{"content":" 我想重命名一个文件（手动操作是不可能的，懒！）\n将“清晰易懂的的线性代数，国立阳明交通大学周志成，国语版mit线性代数Gilbert Strang LA_1-3”改成“LA_1-3”\n所以，就想到了正则匹配咯～\n🍲直接上代码 import os import re # 指定你想要处理文件的目录 directory = \u0026#39;./\u0026#39; # 正则表达式匹配模式 pattern = re.compile(r\u0026#39;LA[_\\-\\d\\w\\s]+.*?\\.mp4$\u0026#39;) # 遍历指定目录下的所有文件 for filename in os.listdir(directory): if filename.endswith(\u0026#34;.mp4\u0026#34;): # 只处理扩展名为.mp4的文件 match = pattern.search(filename) # 在文件名中搜索匹配的部分 if match: new_filename = match.group() # 如果找到匹配，使用匹配的字符串作为新文件名 old_path = os.path.join(directory, filename) new_path = os.path.join(directory, new_filename) # 重命名文件 # os.rename(old_path, new_path) print(f\u0026#39;Renamed \u0026#34;{filename}\u0026#34; to \u0026#34;{new_filename}\u0026#34;\u0026#39;) 正则表达的解释 正则表达式r'(LA[_\\-\\d\\s]+[\\w\\s]*\\.mp4)$'：\nr''：在字符串前面加上r表示这是一个原始字符串，这样做可以确保字符串中的反斜杠不会被当作转义字符处理。在Python中编写正则表达式时，通常推荐这么做。\nLA[_\\-\\d\\w\\s]+.*?\\.mp4$：这个表达式从左到右的意思是：\n(和)：捕获组，这意味着匹配到的这部分表达式会被作为一个整体处理，可以从匹配结果中单独提取出来。\nLA：匹配字面量字符串\u0026quot;LA\u0026quot;。\n[_\\-\\d\\w\\s]+：这是一个字符集合，它可以匹配下划线_、短横线-、任何数字\\d和任何空白字符\\s。+表示前面的字符集合中的字符至少出现一次。\n_：匹配下划线字符。\n\\-：匹配短横线字符。在字符集中，短横线通常用来表示范围（如a-z），所以当我们想要匹配短横线本身时，需要对它进行转义。\n\\d：匹配任何数字字符。\n\\w：匹配任何单词字符（包括字母、数字和下划线）。\n\\s：匹配任何空白字符（包括空格、制表符、换行符等）。\n.*?：以非贪婪方式匹配零个或多个任意字符（除换行符外）。\n\\.mp4：匹配字面量字符串\u0026quot;.mp4\u0026quot;。点.在正则表达式中通常表示匹配任意字符，所以当我们想要匹配点字符本身时，需要对它进行转义\\.。\n$：这表示行结束符，确保字符串以我们指定的模式结尾。\n这个正则表达式用于匹配以\u0026quot;LA\u0026quot;开头，后面跟随至少一个下划线、短横线、数字或字母数字字符，然后是任意数量的任意字符（.*?表示非贪婪匹配），最后以\u0026quot;.mp4\u0026quot;结尾的字符串。\n主要是抛砖引玉，触类旁通，下次再遇到类似的，就可以自己修改啦\n正则表达式（Regular Expression，简称Regex），其核心思想是模式匹配，通过定义一个搜索模式来匹配字符串中的特定序列，这种模式可以用来进行字符串搜索、替换、分割等操作。\n🌟基本用法和常用元字符 1. 字符匹配 .：匹配任意单个字符，除了换行符。 \\d：匹配任意一个数字（0-9）。 \\w：匹配任意一个字母、数字或下划线。 \\s：匹配任意一个空白字符（空格、制表符等）。 2. 位置匹配 ^：匹配字符串的开始位置。 $：匹配字符串的结束位置。 3. 量词 *：匹配前面的字符零次或多次。 +：匹配前面的字符一次或多次。 ?：匹配前面的字符零次或一次。 {n}：匹配前面的字符n次。 {n,}：匹配前面的字符至少n次。 {n,m}：匹配前面的字符至少n次，但不超过m次。 4. 字符类 [abc]：匹配任意一个在括号内的字符（a、b或c）。 [^abc]：匹配任意一个不在括号内的字符。 5. 分组和引用 ()：将括号内的字符视为一个单独的分组。可以对整个组应用量词，也可以通过编号或名称引用组内的匹配。 |：逻辑“或”操作符，匹配左边或右边的表达式。 6. 转义 \\：转义特殊字符，使之成为字面量意义上的字符，如\\.表示点字符本身，而不是任意字符的匹配。 正则表达式示例：匹配邮箱 这是一种比较简单的写法：\n[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,} [a-zA-Z0-9._%+-]+：这部分匹配电子邮件地址的本地部分，允许字母（无论大小写）、数字、点、下划线、百分号、加号和减号。它假设这些字符可以出现一次或多次。\n@：匹配电子邮件地址中的\u0026quot;@\u0026ldquo;符号。\n[a-zA-Z0-9.-]+：这部分匹配电子邮件地址的域名部分，允许字母（无论大小写）、数字、点和减号。它假设这些字符可以出现一次或多次。\n\\.[a-zA-Z]{2,}：匹配电子邮件地址中的顶级域名，开始于一个点，后面跟着至少两个字母（无论大小写）。这里假设所有的顶级域名至少有两个字符长。\n","permalink":"https://ahaknow.com/posts/know/note-regex-example/","summary":"我想重命名一个文件（手动操作是不可能的，懒！） 将“清晰易懂的的线性代数，国立阳明交通大学周志成，国语版mit线性代数Gilbert Strang LA_1","title":"Python：一个正则表达式的小例子"},{"content":" 又干了一件：“为了一碟醋，包了一锅饺子”的事。。。\n就是重新开始学习Strang老爷子的线性代数课了，然后下载了之前国内字幕组的版本（多年不好好学，英语水平明显下降了！！！），这个版本的老问题一直存在，就是某些视频音轨缺失，只有右耳机有声音（这对于一个常年降噪耳机离耳只是为了补充电量的人来说，简直不能忍。。。）\n于是……\n都是4202年了，有什么问题是写个代码解决不了的呢？\n于是Python闪亮登场✨\n废话不多说，直接上代码：\nfrom moviepy.editor import VideoFileClip, AudioFileClip from pydub import AudioSegment # 加载视频文件 video_clip = VideoFileClip(\u0026#34;./麻省理工-线性代数/[P01]Lec01_方程组的几何解释.mp4\u0026#34;) # 提取音频并保存为临时文件 temp_audio_path = \u0026#34;temp_audio.mp3\u0026#34; video_clip.audio.write_audiofile(temp_audio_path) # 使用pydub处理音频 audio_segment = AudioSegment.from_file(temp_audio_path) # 如果原始音频是立体声，分割为单声道；否则直接复制为左右两个声道 if audio_segment.channels \u0026gt; 1: mono_channels = audio_segment.split_to_mono() right_channel = mono_channels[1] # 右声道 else: right_channel = audio_segment stereo_audio = AudioSegment.from_mono_audiosegments(right_channel, right_channel) # 将处理后的音频保存为另一个临时文件 stereo_audio_path = \u0026#34;temp_stereo_audio.mp3\u0026#34; stereo_audio.export(stereo_audio_path, format=\u0026#34;mp3\u0026#34;) # 使用moviepy将新音频设置回视频 new_audio_clip = AudioFileClip(stereo_audio_path) video_clip.audio = new_audio_clip # 输出处理后的视频文件 video_clip.write_videofile(\u0026#34;./麻省理工-线性代数/[P01]Lec01_方程组的几何解释（修复）.mp4\u0026#34;) # 清理临时文件 import os os.remove(temp_audio_path) os.remove(stereo_audio_path) 这里用到两个Python的工具：pydub、moviepy，直接安装就好。\nmoviepy可以同时处理视频和音频；pydub`主要处理音频部分，这个库提供了更灵活的音频处理功能，包括声道的操作。\npip install moviepy pip install pydub 同时确保系统中也安装了ffmpeg，因为pydub依赖于ffmpeg来处理音频文件：\nbrew install ffmpeg ","permalink":"https://ahaknow.com/posts/know/note-mp4-audio-track-repair/","summary":"又干了一件：“为了一碟醋，包了一锅饺子”的事。。。 就是重新开始学习Strang老爷子的线性代数课了，然后下载了之前国内字幕组的版本（多年不好","title":"Python：MP4的音轨修复"},{"content":" 博客里使用了自定义的字体，最开始直接采用ttf文件加载的方式，因为博客内容全部是静态存在Github上的，这种直接加载多少有点慢，所以想了一些策略。\n压缩字体 先显示后加载 使用CDN加速 压缩字体 TrueType Font (TTF) 常见的字体文件格式，由Apple和Microsoft在上世纪80年代末共同开发。TTF使用二次贝塞尔曲线来描述字符形状，这种曲线可以精确地表示复杂形状，并且在放大时保持平滑。\nWeb Open Font Format (WOFF) WOFF是专门为Web设计的字体格式，2009年成为W3C的推荐标准。WOFF是基于TTF和OpenType字体格式的，但提供了更好的压缩和额外的元数据支持。WOFF存在两个版本：WOFF 1.0和WOFF 2.0。WOFF 2.0使用了更高效的压缩算法，文件大小比WOFF 1.0更小。\nTTF是一种通用的字体格式，广泛用于各种操作系统和设备，提供了高质量的矢量字体展示。而WOFF是为Web设计的字体格式，它优化了文件大小和加载性能，特别适合在线使用。选择哪种格式取决于你的具体需求：如果你需要确保字体在各种环境中的广泛兼容性，TTF可能是更好的选择；如果你主要关注网页性能和加载速度，WOFF将是更优的选择。\n在MacOS上直接本地转换ttf字体。\n安装woff2工具：\nbrew install woff2 使用以下命令将TTF字体文件转换为WOFF2格式：\nwoff2_compress path/to/your/font.ttf 这会生成一个与原始TTF文件同名，但扩展名为.woff2的文件。例如，如果源文件名为font.ttf，输出文件将会是font.woff2。\n先显示后加载 这里主要是CSS的工作：\n在CSS文件中使用@font-face规则引入转换后的WOFF2字体文件，并通过font-display: swap;属性设置字体显示策略。这样做可以确保文本在字体文件下载完成之前使用回退字体显示，从而提升页面的可用性和性能。\n@font-face { font-family: \u0026#39;MyCustomFont\u0026#39;; src: url(\u0026#39;MyFont.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;); font-display: swap; /* 使用回退字体直到自定义字体加载完毕 */ } 这里，font-display: swap;指示浏览器在自定义字体加载期间使用回退字体，一旦自定义字体加载完毕立即切换。这有助于改善首次内容渲染时间（FCP）和最大内容绘制（LCP）等性能指标。\n也可以使用Web Font Loader，这里就是JavaScript的工作了：\nWeb Font Loader允许添加事件回调和控制字体加载的行为，简单的使用方式如下（需要配合CSS中的@font-face）：\n\u0026lt;script src=\u0026#34;https://ajax.googleapis.com/ajax/libs/webfont/1.6.28/webfont.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; WebFont.load({ custom: { families: [\u0026#39;MyCustomFont\u0026#39;], urls: [\u0026#39;path/to/your/css/file.css\u0026#39;] // CSS文件的路径（可以不特别设置） } }); \u0026lt;/script\u0026gt; 使用jsDelivr实现CDN加速 jsDelivr 是一个免费的开源内容分发网络（CDN），它能够提供对GitHub、npm、WordPress插件等的直接加速服务。这是通过jsDelivr与这些平台的集成以及其在全球多个地点的服务器网络实现的。下面详细解释一下为什么和如何jsDelivr能够直接加速GitHub的内容。\n1. 如何工作\njsDelivr 是设计来优化项目文件的交付速度和可靠性的。它通过缓存和分发静态文件（如JavaScript库、CSS样式表和字体文件等）来实现这一点。当开发者将他们的代码托管在GitHub或npm上时，jsDelivr 可以直接链接到这些资源，并通过其全球分布的CDN网络提供这些资源。\n2. 全球CDN网络\njsDelivr 使用多个CDN提供商，包括Cloudflare、Fastly和Quantil。这意味着它不依赖于单一的CDN提供商，而是能够通过多个网络提供数据，从而确保在全球范围内的高可用性和速度。这种多CDN路由策略使得jsDelivr在处理大量请求、尤其是在流量高峰时，可以提供更加稳定和快速的服务。\n3. GitHub和npm集成\njsDelivr 对GitHub和npm有特别的支持。开发者只需通过简单的URL格式，就可以直接引用在GitHub仓库或npm包中的文件。jsDelivr会自动处理这些文件的CDN分发。\nGitHub：可以直接引用任何GitHub仓库中的文件，jsDelivr 会处理路径并通过其CDN提供这些文件。 npm：可以引用任何npm包中的文件，同样通过CDN加速分发。 4. 性能优化\njsDelivr 不仅仅提供文件的CDN加速，还对文件进行了优化处理。例如，它可以自动压缩文件以减少文件大小，从而加快加载速度。此外，它还提供了一个可以合并多个文件的功能，减少了网页加载时的请求数量。\n5. 易用性和无成本\njsDelivr 是完全免费的服务，为开发者和网站提供了一个零成本的解决方案来优化其资源的分发。它的设置非常简单，只需要修改文件的URL即可开始使用，无需复杂的配置。\n通过GitHub和jsDelivr实现字体文件（如WOFF2格式）的CDN加速：\n步骤 1: 准备字体文件 首先，确保拥有字体文件的使用权，并且该字体文件已经是WOFF2格式。WOFF2是一种为网络优化的字体格式，具有良好的压缩率和快速的加载性能。\n步骤 2: 上传字体文件到GitHub 创建一个新的GitHub仓库（如果还没有的话）。\n将WOFF2字体文件上传到这个仓库中。可以直接在GitHub网站上进行上传，或者使用Git命令行工具。\n例如，如果字体文件名为 example.woff2，可以在仓库的根目录或任何一个子目录中放置这个文件。\n步骤 3: 使用jsDelivr jsDelivr是一个免费的开源CDN服务，它可以提供GitHub仓库中静态文件的CDN支持。\n获取GitHub文件的URL路径。这通常是：\nhttps://github.com/\u0026lt;username\u0026gt;/\u0026lt;repository\u0026gt;/blob/main/path/to/your/font.woff2 其中 \u0026lt;username\u0026gt; 是你的GitHub用户名，\u0026lt;repository\u0026gt; 是你的仓库名，path/to/your/font.woff2 是文件在仓库中的路径。\n将GitHub链接转换为jsDelivr链接。jsDelivr为GitHub项目提供了一个特别的URL格式，用于CDN加速。将上述URL按以下格式改写：\nhttps://cdn.jsdelivr.net/gh/\u0026lt;username\u0026gt;/\u0026lt;repository\u0026gt;/path/to/your/font.woff2 步骤 4: 在网页中使用字体 在HTML或CSS文件中，使用新的jsDelivr CDN链接来引用字体文件。例如，在CSS中，可以这样指定字体：\n@font-face { font-family: \u0026#39;MyCustomFont\u0026#39;; src: url(\u0026#39;https://cdn.jsdelivr.net/gh/username/repository/path/to/your/font.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;); font-weight: normal; font-style: normal; } 这里，font-family 是给字体起的名字，用于后续在CSS中引用。\n","permalink":"https://ahaknow.com/posts/know/blog-font-display-acceleration/","summary":"博客里使用了自定义的字体，最开始直接采用ttf文件加载的方式，因为博客内容全部是静态存在Github上的，这种直接加载多少有点慢，所以想了一","title":"博客优化：自定义字体加速显示"},{"content":" 记不清第一次读《SLAM十四讲》是什么感受了（那会是第一次接触SLAM这个东西），可能似懂非懂，也可能不懂装懂，总之就是没懂。\n这次，时隔两年（我滴个乖，你这两年就这样荒废啦？你都学了个啥😠）重新来读，一点一点，一步一步读懂、理解透，之前可能广度优先浅尝则止了，这次是深度优先刨根问底！\n视觉SLAM概览 视觉SLAM研究和解决的到底是一个什么问题呢？\n一种感性的理解 视觉SLAM所应用的场景是通过图像数据来完成 SLAM(Simultaneous Localization and Mapping) 同时定位与建图任务。而图像是将三维空间的世界和场景“拍扁”成了一张二维平面，因此三维空间中的距离感（深度信息）在二维图像中就消失了，而且这是一种在自然情况不可逆的过程，即不通过其他手段是无法直接从图像中恢复出原有的深度信息。因此SLAM想要实现对自身的定位和对周围环境的建图，那么首先要做的就是得到图像的深度信息。\n对于图像的深度信息，根据相机软硬件的区别有不同的获取策略，通过硬件设备直接测量当然是最准的，比如RGB-D相机，具体有飞行时间原理（Time of Flight，TOF）和结构光原理（Structured Light）两种，不不过这也会有误差。\n而只有图像的情况，如果是已知相对位置关系的两张图像或者多张图像，那么问题还好些，是双目或者多目的立体匹配问题，涉及到多视图几何的知识（Multiple View Geometry，这本书已买，要读起来了！）；如果只是单张图像的话，想要恢复深度就会复杂很多，首先得是多张图像，也就是让相机动起来去模拟两个或者多个相机的情况，比如水平移动或者竖直移动，如果是随意的移动，那问题就更复杂了，因为还得知道相机运动的每一个位置之间的相对关系，这又涉及到后面要提到的问题：视觉里程计（Visual Odometry, VO），用来估计相邻图像所对应相机的运动，并且如果没有绝对物理尺寸作为参考，这种相对的比例放大或者缩小都不会对结果产生实际性的影响，因此这里的尺度（Scale）是不确定的。这里做一个引子，下一篇学习用来介绍如何通过图像估计出深度。\n假设现在能够获取到图像的深度，从图像像素位置能够恢复出其在空间中的三维坐标，这里需要用到相机模型和投影关系的知识，这也需要在后面的学习中补充。\nSLAM想要做的同时定位和建图，这两者都需要知道自身是怎么运动，也就是相机的位置变换是怎么样的，这时候就需要用到视觉里程计的理论：**相邻图像中如果确定同一个点（从像素点对应到三维空间的一点），然后这个点对应的空间点与相机之间的几何关系，从这个几何关系中估计相邻图像对应相机的位置变换。**这一块也是后面学习的重点。\n假设能够实现相邻图像间位置变换关系的计算了，下一步是将一系列这样的相邻对一起计算，得到一个完整的位姿（位置和姿态）序列，由于传感器的噪声也是很难完全去除的，估计的误差也就不可避免，两个两个进行简单计算时可能误差很小，但是这些很小的误差累积起来就会让结果偏差很大，因此只是完成了单纯的视觉里程计还不够，还需要能够把偏差纠正回来。\n**完整的SLAM还需要对位姿估计进行优化，降低系统噪声的影响，同时对于累积的误差可能产生的质变差异，也就是累积漂移（Accumulating Drift），比如实际是起点终点一致，但估计出来终点和起点直接劈叉了，这就需要通过“回环检测”的策论纠正过来。**两者具体实现起来都比较复杂，这也是后面学习需要突破的。\n简单小结一下：\n如果将SLAM按照“外在表现”和“内在服务”这种思路来划分，视觉里程计可以归为“前端”，并且其中所涉及的理论主要与计算机视觉相关。而对于提取的空间点和估计的位姿进行的优化则可以归为后端，因为这些需要优化的数据涉及各种复杂的几何关系，本身就不是线性的，所以后端常用的是一些滤波和非线性优化的算法（……写到这，其实对于滤波在干啥竟然没有直观的感觉，说明此前的学习真的很拉垮！）最后的回环检测同样也会涉及到计算机视觉的理论，比如图像的相似性，由于回环检测的结果会使得整个位姿估计的结果发生整体的纠正，因此可以看作是SLAM前后端之间的纽带。（……好吧，其实写到这，对于怎么进行回环的，也是一脑子懵逼。。。）\n最后的一部分是建图，SLAM讲究的建图需要从两方面来看。\n同时定位的目的是为了构建出地图，根据需要可以构建不同类型的地图，且这个地图能在之后被使用，比如导航，路径规划，重定位等； 建图的本质是通过相机的位姿将相机看到的场景再“拼接”成一个完整的空间，这时如果只选取场景中的代表特征，比如角点、边缘，一般称之为路标（Landmark），那么构建就是一种稀疏的地图；而如果是将整张图像的每一个点（都知道相应的深度）都拿来建图，那么就会得到一个较为稠密的地图，这种地图一般也为点云地图。 到此，SLAM到底是在干啥算了有一个初步的感性认识了，下面还有内容一些需要补充说明。\n关于稠密与稀疏的讨论 这里对地图的稀疏和稠密程度，是一种相对而言的概念，有这样一个观点：\n你看点云地图，即使它再稠密，将这个点云放大来看，那么点与点之间也是有空隙的，这算稠密嘛？\n在讨论点云地图是否稠密时，我们通常不是指点与点之间完全没有空隙，而是相对于感知系统的分辨率和所需的应用精度来说，数据点的密度足够高。\n稠密地图在SLAM和机器视觉中通常是相对定义的。例如，对于某些应用，如导航或障碍物避让，一个地图可能不需要细致到毫米级别的每一个细节，只要能够较为准确地表示出环境的主要结构和障碍物位置，这样的地图就可以被视为是“稠密”的。\n然而，如果应用需要更高精度的环境建模，例如在精密工业应用中，那么即使是通常意义上的稠密点云地图也可能被视为不够稠密。这是因为在放大观察时，点与点之间的空隙可能导致精度不足，这个时候可能就需要网格化（meshing）的操作。\n补充知识 以下为本次学习中发散思维想到的一些知识点的理解和补充。\nSLAM地图的类型及其适用场景 稀疏地图 特点：包含关键的特征点或路标。 应用场景：适用于需要快速、实时响应的场合，如在资源受限的设备上进行基本导航和避障。 稠密地图 特点：提供环境的详尽几何描述。 应用场景：用于需要高度精确的任务，如在复杂环境中进行精细操作的机器人，或者那些需要高精度视觉信息来进行详细分析的应用。 语义地图 特点：不仅记录物理形状，还标注物体的类别信息（如椅子、桌子、门等）。 应用场景：适用于高级交互、辅助机器人和增强现实应用。例如，辅助机器人利用语义地图识别并与特定物体交互，如抓取物品或开关门。 2D地图和3D地图 2D地图：主要用于平面环境，如家庭或仓库中的地面机器人导航。 3D地图：提供环境的三维结构，适用于复杂或多层环境，如多层建筑内的导航或飞行机器人。 点云网格化 网格化是一种将散乱的点云数据转化为连续三维表面的技术。通过这种方式，可以用三角形网格来近似表示物体的表面，从而提高模型的视觉和计算效果。这不仅可以填补点与点之间的空隙，还能提供更平滑、更详细的表面模型，有助于进行更精确的计算和可视化。\n点云网格化的常见方法 Delaunay 三角剖分：\n这是一种常用的方法，可以生成三角网格，通常用于2D和3D空间中。它尝试保证在三角形网格的每个三角形的圆周上没有其他点存在，这有助于最大化最小角，从而避免生成细长的三角形。 泊松表面重建：\n泊松方法是一种流行的3D重建技术，用于从点云中推导出一个平滑的曲面。它基于假设一个隐式表面可以通过点云定位，然后通过求解一个泊松方程来找到最佳的表面。 Marching Cubes 算法：\n这是一个用于提取等值面并创建三角网格的算法。在医学成像和科学可视化中尤其常见。它通过逐个检查数据体积的立方体（或“体素”）的网格，根据边界上的点来构造表面。 Greedy Projection Triangulation：\n这种方法适用于较大的点集，它依赖于贪婪策略来逐步构建三角网格。它通常从一个点开始，逐步向外扩展，直到覆盖所有点。 SLAM的数学表达 从数学的角度来理解SLAM问题，可以归结为机器人的“运动”和机器人对路标（Landmark）的“观测”。\nSLAM（Simultaneous Localization and Mapping）是一个核心问题，在机器人学和自动导航系统中非常关键。它涉及到机器人在未知环境中同时进行自我定位和环境地图构建的过程。理解SLAM的基本问题涉及到几个关键方面：运动方程、观测方程、已知的数据、需要估计的变量、噪声模型以及求解这些问题的方法。\n运动方程 运动方程描述了机器人状态的时间演化，基于其运动模型。在最基本的形式中，这可以表示为：\n$$ x_{t} = f(x_{t-1}, u_t, w_t) $$\n$ x_{t-1} $：上一个时间步的机器人状态（位置和方向）。 $ u_t $：控制输入（如速度和方向变化）。 $ w_t $：过程噪声，模拟由于机器人动力系统的不精确性和环境因素带来的不确定性，通常假设为高斯分布。 观测方程 观测方程描述了机器人如何通过其传感器从环境中获取信息，以及这些信息如何依赖于当前的机器人状态和地图：\n$$ z_t = h(x_t, m, v_t) $$\n$ z_t $：在时间 $ t $ 的传感器观测。 $ x_t $：当前机器人状态。 $ m $：地图中的特征。 $ v_t $：观测噪声，代表传感器误差和其他测量不确定性，通常假设为高斯分布。 已知和未知变量 已知变量： 控制输入 $ u_t $：例如从机器人的驱动系统获得。 观测数据 $ z_t $：来自机器人的传感器。 未知变量： 机器人的状态 $ x_t $：需要实时估计。 地图 $ m $：需要逐步构建和更新。 噪声的存在 过程噪声 $ w_t $：存在于运动方程中，反映了控制输入到实际运动之间的不精确转换。 观测噪声 $ v_t $：存在于观测方程中，反映了传感器本身的不精确性和环境导致的误差。 求解方法 求解SLAM问题通常采用以下几种方法：\n扩展卡尔曼滤波器（EKF）：通过线性化非线性模型处理较小的不确定性和噪声，适用于线性高斯模型。 粒子滤波器（特别是FastSLAM）：使用大量随机样本（粒子）来代表可能的机器人状态和地图配置，适合处理非线性和非高斯问题。 图优化方法：将整个SLAM过程建模为一个优化问题，节点代表状态，边代表运动或观测的约束，通过优化这些约束来精确地估计机器人的轨迹和地图。 理论依据 SLAM的理论基础建立在概率论和估计理论之上，允许系统在存在噪声和不确定性的情况下有效地估计机器人的状态和构建环境地图。这些方法不仅能够提供对当前状态的最佳估计，还可以预测未来状态并修正过去的误差，从而实现对环境的连续\n学习和适应。\n通过这些核心组成部分和方法，SLAM技术可以有效地支持机器人在复杂且未知的环境中进行导航和任务执行。\n","permalink":"https://ahaknow.com/posts/know/slam14-ch2/","summary":"记不清第一次读《SLAM十四讲》是什么感受了（那会是第一次接触SLAM这个东西），可能似懂非懂，也可能不懂装懂，总之就是没懂。 这次，时隔两年","title":"SLAM十四讲第二讲：初识SLAM"},{"content":"第一讲里没有具体需要好好理解的部分，不过自测题目题目值得过一遍。\n1.线性方程Ax=b的求解 有线性方程$Ax=b$，若已知$A,b$，需要求解$x$，该如何求解？这对$A$和$b$有哪些要求？\n（提示：从$A$的维度和秩的角度来分析）\n这个问题很简单，但是值得全面地分析和理解：\n首先假设$A$是一个$m \\times n$矩阵，$x$是一个$n \\times 1$的列向量，$b$是一个$m \\times 1$的列向量。这里的$m$表示方程的数量，$n$表示未知数的数量。\n先从矩阵的秩出发来理解，以列的角度看，矩阵的秩表示了所有列向量线性组合所能达到的空间范围，对于方程$Ax=b$，如果向量$b$在矩阵$A$的列空间中（$b$可以被$A$的列向量线性表示），那么存在至少一个解$x$使得$Ax=b$，因此就有了下面的判断性质（比较矩阵$A$和增广矩阵$A|b$秩的关系）：\n$rank(A) = rank(A|b)$：表明向量$b$在矩阵$A$的列空间中，因此至少存在一个解$x$使得$Ax=b$。 $rank(A) \u0026lt; rank(A|b)$：表明$b$不在$A$的列空间中，因此没有解。 然后再分析$rank(A)$来确定解的情况，是有唯一解还是存在多个解：\n如果$rank(A)=n$（未知数的数量，也就是列的数量），则$A$的所有列向量都是线性独立的，意味着对于给定的$b$，存在唯一的$x$满足$Ax=b$。 如果$rank(A)\u0026lt;n$，则$A$中的某些列向量是其他列向量的线性组合，意味着给定的$b$时，这些可以被其他列向量表示的向量不参与线性组合出$b$，也就可以有任意值作为系数，导致存在无限多个解。 线性方程$Ax=b$的求解方法 ‼️以下的回答来自GPT，自己还不是很理解，需要重新系统学习线性代数的知识后再进行自己的消化吸收！\n超定系统：$m \u0026gt; n$，方程数量多于未知数。 欠定系统：$m \u0026lt; n$，方程数量少于未知数。 适定系统：$m = n$，方程数量等于未知数。 LU分解 原理：将矩阵$A$分解为两个特殊的矩阵乘积，一个下三角矩阵$L$和一个上三角矩阵$U$，即$A=LU$。这样，原始问题$Ax=b$变为求解两个更简单的线性方程组$L(Ux)=b$。 求解过程：首先解$L\\mathbf{y}=b$找到$\\mathbf{y}$，然后解$Ux=\\mathbf{y}$找到$x$。 适用性：特别适用于适定系统，也可用于某些类型的超定和欠定系统，假设$A$可以进行有效的LU分解。 QR分解 原理：将矩阵$A$分解为一个正交矩阵$Q$和一个上三角矩阵$R$，即$A=QR$。正交矩阵具有性质$Q^TQ=I$（$I$是单位矩阵）。 求解过程：利用$Q$的正交性质，原方程$Ax=b$变为$QRx=b$，进一步化简为$Rx=Q^Tb$，然后可以通过回代求解上三角方程组$Rx=Q^Tb$来找到$x$。 适用性：适用于所有类型的系统，尤其是超定系统，因为QR分解提供了一种求解最小二乘问题的自然方法。 奇异值分解（SVD） 原理：SVD将矩阵$A$分解为三个矩阵的乘积，即$A=U\\Sigma V^T$，其中$U$和$V$是正交矩阵，$\\Sigma$是对角矩阵，对角线上的元素是所谓的奇异值。 求解过程：对于方程$Ax=b$，可以转换为$\\Sigma y=U^Tb$（这里$y=V^Tx$），然后通过求解$\\Sigma y=U^Tb$来找到$y$，进一步求得$x=Vy$。 适用性：SVD是一种非常强大的方法，特别是对于奇异矩阵或矩阵秩不满的情况，因为它允许计算伪逆矩阵$A^+$，即使在$A$不可逆的情况下也能找到最小二乘解或最小范数解。 迭代方法求解 原理：迭代方法是从一个初始估计开始，通过重复应用迭代公式来逐步逼近方程的解。常见的迭代方法包括雅可比方法、高斯-赛德尔方法和共轭梯度法等。 求解过程：根据具体的迭代公式，每一步都基于前一步的结果来更新解的估计值，直至满足某个终止条件（如解的变化小于某个阈值）。 适用性：迭代方法特别适用于大规模稀疏矩阵的系统，因为它们通常不需要矩阵分解，而矩阵分解在大规模问题上可能非常昂贵。 2.高斯分布 高斯分布是什么？它的一维形式是什么样子？它的高维形式是什么样子？\n高斯分布，也称为正态分布，高斯分布可以被视为描述自然和人为现象中随机误差的理想模型，其普遍性来源于中心极限定理（Central Limit Theorem, CLT），这个定理说明了许多小效应的累积可以产生高斯分布的现象，具体而言就是：“大量相互独立且分布相同的随机变量之和趋向于服从正态分布，无论原始随机变量的分布如何。”\n高斯分布的一维形式 一维高斯分布（或简称为正态分布）的数学表达式为：\n$$ f(x | \\mu, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right) $$\n其中，$\\mu$是分布的均值，$\\sigma^2$是方差，$\\sigma$是标准差。这个公式描述了在给定均值$\\mu$和方差$\\sigma^2$的情况下，随机变量$X$取特定值$x$的概率密度。图形上，一维高斯分布是一个对称的钟形曲线，其中心位于均值$\\mu$，曲线的宽度由标准差$\\sigma$决定。\n高斯分布的高维形式 高维高斯分布，或多变量高斯分布，是一维高斯分布在多维空间中的推广。其数学表达式为：\n$$ f(\\mathbf{x} | \\boldsymbol{\\mu}, \\Sigma) = \\frac{1}{\\sqrt{(2\\pi)^k |\\Sigma|}} \\exp\\left(-\\frac{1}{2}(\\mathbf{x}-\\boldsymbol{\\mu})^T \\Sigma^{-1} (\\mathbf{x}-\\boldsymbol{\\mu})\\right) $$\n其中，$\\mathbf{x}$是一个$k$维随机向量，$\\boldsymbol{\\mu}$是均值向量，$\\Sigma$是协方差矩阵，$|\\Sigma|$是协方差矩阵的行列式。高维高斯分布的图形是在多维空间中的一个“山峰”，其中心位于均值向量$\\boldsymbol{\\mu}$，“山峰”的形状和方向由协方差矩阵$\\Sigma$决定。\n协方差是衡量两个随机变量联合变化趋势的度量。如果两个变量的增减趋势相同（即一个变量增加时，另一个也增加），则它们的协方差为正；如果一个变量增加时另一个减少，则协方差为负。\n对于两个随机变量$X$和$Y$，协方差定义为$Cov(X, Y) = E[(X - \\mu_X)(Y - \\mu_Y)]$，其中$\\mu_X$和$\\mu_Y$分别是$X$和$Y$的均值，$E$表示期望值操作。\n3.C++基本知识 C++中的类是什么？STL是什么？模版又是什么？\n（将基本常用的举例出来进行说明）\nC++11的新特性以及其他标准\n对于C和C++，我觉得需要系统的课程来学习补充，边用边学是持续的，先打好基础，边学边成长才更好\n以下只是对这个回答的简要回答（举例说明）\n类（Class） 类是C++中用于数据封装和面向对象编程的基本构建块。它定义了一种数据类型的蓝图，包括数据成员（属性）和成员函数（方法），用于操作这些数据。\nclass Car { public: Car(int y, const std::string\u0026amp; m) : year(y), model(m) {} void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;Year: \u0026#34; \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#34;, Model: \u0026#34; \u0026lt;\u0026lt; model \u0026lt;\u0026lt; std::endl; } private: int year; std::string model; }; 标准模板库（STL） STL是一组模板化的通用类和函数的集合，提供了常见的数据结构（如向量、列表、队列等）和算法（如排序、搜索等）。STL的核心组成部分包括：\n容器：存储数据的数据结构。例如std::vector、std::list、std::map等。 算法：操作数据的函数，例如std::sort、std::find。 迭代器：提供对容器中元素的访问方式。 #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {4, 1, 3, 5, 2}; std::sort(vec.begin(), vec.end()); for(int i : vec) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } 模板（Template） 模板允许在不指定具体类型的情况下编写代码。它们使得可以创建泛型类和函数，使代码更加灵活和可重用。\ntemplate \u0026lt;typename T\u0026gt; T add(T a, T b) { return a + b; } // 使用模板函数 int result = add\u0026lt;int\u0026gt;(1, 2); C++11/14/17的新特性举例 C++11 自动类型推断（auto）：让编译器自动推断变量的类型。 基于范围的for循环：简化了集合的遍历。 智能指针：如std::shared_ptr和std::unique_ptr，管理动态分配的内存。 Lambda表达式：允许定义匿名函数。 C++14 泛型Lambda：Lambda表达式中使用自动类型推断。 返回类型推断：函数的返回类型可以被自动推断。 C++17 结构化绑定：允许从数组或元组中一次性解包多个值。 内联变量：对于头文件中的全局变量，允许多个源文件中包含同一个变量而不会引起重定义错误。 std::optional：表示一个可能不存在的值。 4.Linux必备的操作 Linux必备知识 基本命令行操作: 理解如何使用命令行界面（CLI）进行文件系统的导航（如cd, ls, pwd）、文件操作（如cp, mv, rm, mkdir）和文本文件查看与编辑（如cat, nano, vi/vim）。\n软件安装与管理: 熟悉所用发行版的包管理器，如Ubuntu的apt, CentOS的yum或Fedora的dnf，用于安装、更新和管理软件包。\n权限和用户管理: 了解文件权限（chmod, chown）和用户管理命令（useradd, usermod, groupadd），以及如何使用sudo来执行需要超级用户权限的命令。\n进程管理: 学会如何使用ps, top, htop, kill, 和systemctl来查看和管理运行中的进程和服务。\n网络配置和故障排除: 掌握使用ifconfig/ipconfig, ping, netstat, ss, traceroute等命令进行网络配置和故障排查。\nShell脚本编写: 学习基本的Shell脚本编写，以自动化日常任务。\n文件系统管理: 了解不同的文件系统类型，磁盘分区（fdisk, parted），以及如何挂载和卸载文件系统（mount, umount）。\n安全和防火墙: 基本的系统安全知识，如使用iptables或ufw管理防火墙规则，以及使用ssh进行安全远程登录。\nLinux的一些“术” 使用man命令: 几乎所有Linux命令都有手册页，通过man \u0026lt;命令名\u0026gt;可以查看详细的使用说明和选项。 命令行自动完成: 通过按Tab键自动完成命令名称或参数，这不仅可以加快命令输入速度，还可以帮助记忆命令。 使用apropos命令: 如果不确定使用哪个命令，可以通过apropos \u0026lt;关键词\u0026gt;来搜索相关的命令。 建立个人命令备忘录: 当学习新命令时，将它们记录在笔记中，随时查阅。 Linux安装软件 在使用apt（或apt-get）在Ubuntu或基于Debian的系统中安装软件时，软件包通常会被安装到系统的标准目录下，这遵循了Linux的文件系统层次结构标准（FHS）。大部分可执行文件会放置在/usr/bin/或/usr/local/bin/目录下，库文件通常位于/usr/lib/或/usr/local/lib/，而配置文件大多数在/etc/下。文档和示例文件可能位于/usr/share/doc/。\n如何安装软件 如果你只是模糊知道某个软件包的名字，可以使用apt提供的搜索功能来查找正确的软件包名。以下是步骤和示例，以Eigen这个数学库为例：\n更新软件包列表：首先，最好更新本地软件包列表，以确保搜索和安装的是最新版本的软件。在终端中运行：\nsudo apt update 搜索软件包：如果不确定软件包的确切名称，可以使用apt-cache search命令进行搜索。例如，如果要搜索Eigen，可以运行：\napt-cache search eigen 这将列出所有与“eigen”相关的软件包。在结果中，会看到很多与Eigen相关的包，其中可能包括实际的Eigen库包和其他相关包。\n安装软件包：一旦你找到了想要安装的确切软件包名称，就可以使用apt-get install命令进行安装。如果结果显示Eigen的开发包是libeigen3-dev（这是一个常见的包名，用于包含Eigen库的开发文件），就可以运行：\nsudo apt-get install libeigen3-dev 这条命令会安装Eigen库及其所有依赖项。\n如何找到安装的软件 如果想知道apt安装的软件具体放在哪里，可以使用dpkg -L命令来列出软件包安装的所有文件的位置。例如，要找到libeigen3-dev安装的所有文件，可以运行：\ndpkg -L libeigen3-dev 这将列出所有由该软件包安装的文件和目录的路径，包括库文件、头文件、文档等。\n✨Linux的文件系统 Linux的文件系统层次结构标准（FHS, Filesystem Hierarchy Standard）定义了操作系统中目录和目录内容的标准布局。这种标准化设计使得开发者和用户能够预测在任何基于Linux的系统上找到特定类型文件的位置。以下是一些主要目录及其用途的简要说明：\n根目录 / 在Linux中，所有的文件和目录都从根目录开始。这是整个文件系统的起点。\n/bin 这个目录包含执行文件（二进制文件），这些文件是系统启动和运行所必需的，同时也存放了用户常用的命令（如ls, cp等）所依赖的执行文件。\n用例：存放基本的命令，如grep, echo, sleep。这些命令在单用户模式下或紧急恢复时也必须可用。\n/boot 包含启动Linux系统所需的文件，比如Linux内核（vmlinuz），引导加载程序（GRUB或LILO）的配置文件等。\n/dev 这个目录下包含设备文件。Linux将设备视为文件，这些设备文件代表系统中的硬件组件。\n/etc 包含系统配置文件。这些文件只能被根用户或具有适当权限的用户修改。这里包括系统启动脚本、网络配置文件等。\n用例：包含如/etc/passwd（用户账户信息）和/etc/fstab（文件系统挂载的静态信息）等关键配置文件。\n/home 用户的个人目录位于此处。每个用户都有一个与其用户名对应的目录，用于存储个人文件、配置等。\n/lib 包含系统最基本的共享库和内核模块。这些库支持位于/bin和/sbin目录中的二进制文件。\n用例：存放动态链接库（如libc.so.6），它们是执行/bin和/sbin下命令所必需的。\n/media和/mnt /media通常用于挂载可移动媒体设备，如CD-ROMs、USB驱动器等，而/mnt则用作临时挂载文件系统的目的。\n/opt 用于安装“可选”的软件应用。这些是非基本系统软件，通常作为整个应用程序安装在这里。\n用例：第三方应用程序如Google Chrome或某些商业软件可能会安装在这里，每个应用通常有其自己的子目录。\n/proc 这是一个虚拟文件系统，提供对内核和进程信息的接口。它并不占用磁盘空间，而是在内存中动态生成。\n/root 这是系统管理员，也就是root用户的家目录。这与/home目录分开，为了安全性和管理方便。\n/sbin 包含系统管理和维护的必需的执行文件，这些命令通常由root用户运行，如fdisk, ifconfig, swapon等。\n/tmp 一个临时文件存储区域。系统和用户可以在这里创建临时文件。通常，此目录在系统重启时会被清空。\n/usr 包含用户程序和数据。它是Unix System Resources的缩写。随着时间的推移，/usr目录已经成为存储共享系统资源的主要目录。\n/usr/bin：包含用户安装的非系统必需的执行文件。 /usr/lib：类似/lib，但是为/usr/bin下的程序提供库支持。 /usr/local：用于系统管理员安装本地软件，保持与由包管理器安装的软件的分离。 用例：/usr/bin下可能会有如python, gcc等用户级程序。 /var 包含经常变化的文件，如日志文件、打印队列、邮件等。\n/var/log：存放系统日志文件，如/var/log/syslog或/var/log/apache2。 /var/mail：存储用户的邮件。 /var/cache：用于存放应用程序缓存数据。 用例：系统管理员可能需要定期检查/var/log来监控系统和应用程序的活动。 /srv 用于存放服务提供的数据，例如Web服务器和FTP服务器的数据文件。\n用例：如果您运行一个Web服务，网站的数据可能位于/srv/www。\n/sys 与/proc相似，/sys是一个虚拟文件系统，提供了内核、设备和驱动程序的接口。\n用例：/sys提供了一种更加结构化的方式来浏览设备和驱动程序的信息，如查询特定USB设备的信息。\n/etc/cron.* 这些目录（cron.daily, cron.hourly, cron.monthly, cron.weekly）用于存放定时执行的脚本。\n用例：自动备份脚本可能放在/etc/cron.daily中，以确保每天执行。\n5.Vim必须会的几个操作 已经不在执着于美化Vim的各种插件了（因为完全可以用更好的CLion、VSCode之类）\n‼️但是命令行中Vim最方便，但只要知道最基础的操作就足够了：怎么增删改查，怎么复制粘贴。\nVim是一个非常强大的文本编辑器，常被用于编程和脚本编辑。它的操作方式与其他文本编辑器有很大不同，主要基于键盘快捷键，分为多种模式，最主要的是普通模式（Normal Mode）、插入模式（Insert Mode）、命令模式（Command-Line Mode）和可视模式（Visual Mode）。以下是关于Vim的基本用法，包括增删改查、复制粘贴，以及批量执行命令的方法。\nVim的基本操作 进入插入模式 在普通模式下，按i进入插入模式，在光标前插入文本。 按a也可以进入插入模式，在光标后插入文本。 按I在当前行首进入插入模式，按A在当前行尾进入插入模式。 删除文本 在普通模式下，按x删除光标所在位置的字符。 按dd删除光标所在行。 要删除从当前光标位置到行尾的内容，可以使用D。 修改文本 在普通模式下，按r后跟一个字符可以替换光标所在位置的字符。 使用cw可以更改光标开始的单词，这将删除单词并进入插入模式。 查找文本 在普通模式下，按/后输入要查找的文字，然后按Enter进行搜索。按n查找下一个匹配项，按N查找上一个匹配项。 复制和粘贴 在普通模式下，按yy复制当前行，按p粘贴到光标后。 要复制多行，可以先按2yy来复制两行（2可以替换为任何数字，表示行数）。 使用可视模式（按v进入）可以选择特定的文本区域，然后按y复制。 移动操作 基本移动：h（左移）、j（下移）、k（上移）、l（右移）。 按单词移动： w：向前移动到下一个单词的开头。 b：向后移动到前一个单词的开头。 e：向前移动到当前或下一个单词的结尾。 按行移动： 0（零）：移动到当前行的开始。 ^：移动到当前行的第一个非空白字符。 $：移动到当前行的末尾。 跳转到特定行： gg：跳转到文件的第一行。 G：跳转到文件的最后一行。 :\u0026lt;行号\u0026gt;+Enter：跳转到文件中的特定行号。 屏幕移动： H：移动到屏幕顶部的行。 M：移动到屏幕中间的行。 L：移动到屏幕底部的行。 翻页： Ctrl+f：向前翻一页。 Ctrl+b：向后翻一页。 Ctrl+d：向前翻半页。 Ctrl+u：向后翻半页。 可以结合前置数字来实现“批量移动”，这意味着可以在移动命令前加上一个数字来重复该命令多次，例如：\n5j 表示向下（j）移动5行。 3w 表示向前跳过3个单词到下一个单词的开头。 10k 表示向上（k）移动10行。 4$ 表示移动到后面4行的末尾。 Vim与外部（macOS）的复制粘贴 在macOS上，从Vim复制文本到外部程序，首先需要确认你的Vim版本是否支持剪贴板（clipboard）功能。可以通过在终端中输入vim --version查看。如果看到+clipboard，则表示支持剪贴板功能；如果是-clipboard，则表示不支持，可能需要安装支持剪贴板的Vim版本，比如通过brew install vim。\n启用剪贴板支持：确保Vim版本支持系统剪贴板。\n复制文本到剪贴板：\n在普通模式下，要复制整行到系统剪贴板，使用\u0026quot;+yy。（一个一个字符来按） 要复制指定文本，先按v进入可视模式，选择需要的文本，然后使用\u0026quot;+y复制。 从外部粘贴到Vim：在插入模式下，使用Cmd+V（macOS通常的粘贴快捷键）或在普通模式下使用\u0026quot;+p来粘贴剪贴板的内容到Vim。\n一些技巧 在普通模式下，可以通过:norm命令批量执行操作。比如，:norm I//会在所有选中的行前添加//（注释掉这些行）。\n批量替换文本，可以使用:s命令。例如，要在整个文件中替换\u0026quot;old\u0026quot;为\u0026quot;new\u0026quot;，可以使用:s/old/new/g。\n在多个行前添加内容：假设想在文件的每一行前添加序号或特定标记，可以使用:norm命令。例如，:5,10norm I// 会在第5行到第10行的开头添加// 。\n转换大小写：要将选定行的文本转换为大写，可以使用:norm结合gU命令。例如，:5,10norm gU$会将第5到第10行的内容转换为大写。\n快速跳转至匹配的括号：在普通模式下，使用%可以跳转至匹配的括号，这在编辑代码时非常有用。\n撤销和重做：使用u来撤销最近的一次更改，使用Ctrl+r来重做被撤销的更改。\n打开/关闭行号显示：快速切换行号显示，可以使用:set nu!和:set rnu!来分别切换绝对行号和相对行号的显示状态。\n","permalink":"https://ahaknow.com/posts/know/slam14-ch1/","summary":"第一讲里没有具体需要好好理解的部分，不过自测题目题目值得过一遍。 1.线性方程Ax=b的求解 有线性方程$Ax=b$，若已知$A,b$，需要求解","title":"SLAM十四讲第一讲：预备知识"},{"content":" 引子：\n我们生活的世界是三维的，在三维世界中对物体的感知拥有明确的距离感，比如键盘在手的前面，显示器在键盘的前面，那么显示器就在手的更前面（这里的“前”或者“后”属于自定义的界定，也可以认为键盘在手的后面，显示器在手的更后面），而如果通过相机将这个三维世界中的场景拍成一张照片，此时三维空间中的所有距离层次就一起被“拍”进了二维图像中，形象地比喻就是将立体的空间“压”成一张了平面的表达，从此表达空间深度的维度就丢失了，并且这个过程在自然状态下是不可逆的。\n而当我们谈到三维空间（Three-dimensional space，以下称3D）的视觉感知时，则必然与深度（距离层次感）脱不开关系，也就是说，当我们用视觉（人可以用眼睛+大脑，机器可以用图像传感器+软件算法）去感知周围的环境时，只有同时获取到了深度，才有资格去讨论3D的视觉感知，否则还是停留在2D平面图像的层次。\n因此在讨论“3D视觉感知的发展”时可以将关注点聚焦在两处：\n如何提高机器视觉系统获取深度信息的精度和可靠性？（如何获得更高精度的深度信息？） 在融合图像和深度信息后，能够推动哪些3D视觉感知技术的发展？（在拥有图像和深度信息后，我们能继续做什么？） 机器视觉的深度获取 首先，我们讨论的是机器的视觉系统，关于机器视觉的定义，简言之，就是通过“某些设备”让机器能够“看到”周围的环境，在不具体追溯这些设备的软硬件实现时，我们以“相机”这个更为广泛的概念进行代替，也就是说，通过相机（相机内部还需要算法和软件支持）可以让机器“看到”这个世界，而相机实现的不同，则可以让机器看待这个世界的方式也发生改变。\n因此，比较直观地获取深度的方式是直接通过相机软硬件这个载体来实现，在这里只进行简要的介绍，因为以下的每一种相机在具体讨论时都需要大篇幅的内容进行结构、原理和方法的说明。\n从相机的角度来看，获取图像深度的方式可以分为两大类型：\n一种是通过硬件的物理测量，比如向三维空间中发射特殊的光源，这个光源接触到物体发生反射后可以回到接收装置，通过测量光源的来回传播时间获得距离信息的飞行时间原理（Time of Flight，TOF）的深度相机，以及向三维空间中投射具有特殊形状的光源，通过测量计算这些光源在物体表面发生的形变来获得距离信息的结构光原理（Structured Light）的深度相机； 另一种则是通过图像中的几何学关系计算得到，专业的表达是多视图几何（Multiple View Geometry），具体的实现可以是一个相机拍摄的多个连续场景图像，或者是两个或多个相机拍摄的同一个场景图像，其中较为成熟的是通过两个平行相机实现的双目立体视觉（Binocular Stereo Vision）相机。 具体到每一种类型的深度相机，都有其各自的关注点来提高相机获取深度的精度，在此暂不深究。从另一个角度出发，如果没有这些额外的软硬件支持，只能通过相机拍摄二维图像，怎么得到图像的深度信息呢？\n在当下能够通过数据驱动解决复杂问题的大背景下，利用机器学习（更具体一点是深度学习）直接从二维图像中估计出深度是一种技术趋势，比如在paperswithcode.com上检索“Depth Estimation”可以看到很多开源的算法和模型，并且所依赖的数据也不再限制，利用单张图像或者多张图像都有相应的方法。因此更直观的想法就是在相机中嵌入深度学习技术直接从图像中估计出深度信息，从而也就避免了采用额外硬件设备所需要的校准、标定等繁杂的维护工作。\n在深度学习里有一条基本认知是：“数据决定了深度学习的上限，而模型只是逼近这个上限而已”。也就是说，想要通过深度学习完善地解决直接的图像深度估计问题，一个好的模型固然重要，但更为关键是拥有驱动这个模型完好运转的数据燃料，并且数据的质量决定了模型效果，那么怎样获得这些高质量的数据呢？\n上文介绍的通过硬件物理测量和通过图像几何学关系获取深度的两种相机，这些在市场中已经有成熟的产品投入应用，如果用它们得到的深度数据来驱动深度学习，从理论上来讲，最理想的状态也不过是达到了深度相机的最高精度效果，并且物理测量或者几何计算本身就具有的偏差还会对模型的效果产生负面影响。\n因此，从数据驱动的深度学习方法估计图像深度的这一方向切入，如果想要让模型的结果更精确从而获取更可靠的深度信息，还需要从数据上下功夫，具体可实践的方式是使用3D仿真，通过模拟相机和构建3D场景产生所需求的且完全准确的深度信息，可以采用的工具和软件包括：\n3D建模和动画软件：Blender； 游戏物理引擎：Unity 3D，Unreal Engine； 机器人仿真器（开源）：Gazebo Sim； 自动驾驶仿真器（开源）：CARLA。 而随着人工智能的发展，特别是生成式人工智能（Generative AI）的技术，将人工智能自己生成内容的技术融入到3D仿真生成也将成为一种新趋势。\n3D视觉感知技术 有了图像深度（用Z表示）之后，我们能做什么呢？\n首先能够从二维图像恢复出三维的空间关系，图像中每一个像素点(x,y)可以通过投影关系恢复到三维空间中的点(X,Y,Z)，将这些三维的点组合起来就构成了点云（Point Cloud）。 通过点云可以分析出哪些是可以移动的区域，哪些区域不平坦；以及哪些是空间中的阻挡自身运动的障碍物，这些障碍物与自身的实时距离等，这个过程体现的就是三维空间的感知。 由于从三维空间“拍”进二维图像的过程中，距离相机更近的物体会挡住其身后的物体，因此在从二维图像恢复到三维空间时，那些被挡住的部分自然也不会呈现出来，而想要从图像中恢复出一个空间的完整样貌，就需要很多张拍摄到这个空间各个角落的图像一起“组合”，共同“拼接”来还原，这个过程就叫做三维空间的场景重建。 以上的过程在具体实现中会涉及到较多的数学原理推导，在这里没有具体展开说明，但从本质的理解出发，在拥有图像深度之后，视觉的感知就完整了，下面从移动机器人和智能驾驶两个领域来谈一谈3D视觉感知技术的具体应用。\n移动机器人领域 一般而言，移动机器人是在一个区域内运行的，也就是说，移动机器人需要拥有这个区域的地图信息，然后在已有地图的基础上再完成感知、定位、路径规划和导航，甚至在实际应用时还需要考虑对地图的更新。机器人的定位和建图可以通过SLAM（Simultaneous Localization And Mapping）技术来实现，SLAM中也需要知道深度信息，比如视觉SLAM在只提供图像的情况下时通过几何学关系来计算出深度，而如果能够同时提供足够精确的深度信息，那么SLAM的建图和定位精度也会更加准确。\n在3D视觉下，机器人可以做到对物体更加准确和丰富的感知，不仅是对物体实现简单的位置测距，在一些算法的支持下，还能够对特定的物体实现姿态的估计，在同时拥有物体的位置和姿态后，就可以展开定位、抓取等后续的操作。同时利用三维空间的场景重建技术，还能够将机器人所处的三维空间模型恢复出来，以这个三维场景为基础，可以继续构建更丰富的地图形式，以及结合3D检测分割等技术实现更具体的环境感知。\n智能驾驶领域 行驶状态中的车辆是实时运动的，并且车辆所在的道路环境也是实时变化，因此即使没有预先加载的高精度地图，智能驾驶的车辆也应该能够通过视觉或者其他传感器感知到周围环境中其他车辆或者物体的状况变化从而调整自身，这是业界常说的“轻地图，重感知”。\n智能驾驶的车辆，不同于移动机器人在一个区域内运行，也不会像移动机器人一样为了补全视野的盲区而在一个范围内来回打转，车辆的运行轨迹基本是持续向前的，因此对于3D视觉的感知更倾向于实时的呈现，通过相机持续拍摄车辆周围可以获得视频流，而同时拥有了图像深度后，这个平面图像的视频流就可以转换为三维空间的点云运动流，这个转换的过程不涉及深度学习。对点云空间也可以同样进行检测、分割等处理，从而获得周围环境的实时道路状况信息。\n近几年兴起的Occupancy Networks（占用网络）是上述描绘场景的一种近似表达，特别是MonoScene，通过一个网络模型实现了从单张图像中获取深度和语义信息再以三维栅格网络方式呈现的流程，从一定意义上掀起了占用网络的热潮。而从本质出发，如果拥有图像中每一个像素对应的精确深度，那么不管是高密度的三维空间点云还是数据量更低的栅格化网格，都可以顺畅地实现。\n3D视觉感知的本质前提是拥有足够精确的第三维度信息，也就是深度，而后再开展以3D视觉为主导的感知技术才能如鱼得水。现如今虽然说人工智能是大趋势，深度学习方法可以解决很多问题，但要驱动深度学习方法完好运转还需要充足且高质量的数据驱动，不管是先获得精确深度信息还是说直接的3D视觉感知，当应用深度学习方法时，都离不开数据。\n总的来说，3D视觉的核心是先恢复出了准确可靠的深度信息，而后再进行更具体的感知任务。一种思路是从相机本身考虑，但可能目前几种深度相机有理论的上限或者实际应用的瓶颈难以继续突破深度测量的精度和可靠性，另一种思路是完全的数据驱动，首先拥有足够量级的精准深度数据，而后不断优化深度学习的模型来达到最佳效果。3D视觉感知技术的应用也是一样，在拥有准确深度后，很多传统的感知任务都会锦上添花，当然也可以将3D视觉感知作为一个整体，在只有图像输入的情况下实现3D视觉的感知，这里就回到了应用深度学习方法解决的思路，模型优化固然重要，更必要还是高质量数据驱动。\n","permalink":"https://ahaknow.com/posts/know/aha-3d-visual-perception/","summary":"引子： 我们生活的世界是三维的，在三维世界中对物体的感知拥有明确的距离感，比如键盘在手的前面，显示器在键盘的前面，那么显示器就在手的更前面（这","title":"3D视觉感知"},{"content":" 问题的描述是这样的（用我理解后的语言来表达）：\n以搭载2D激光雷达（2D-Lidar）的扫地机器人为例，只考虑在二维平面下的关系。世界坐标系$O_W$，机器人坐标系$O_C$，雷达坐标系$O_L$，雷达坐标系的方向轴与机器人坐标系一致，雷达搭载在机器人上，用机器人坐标系$O_C$的坐标表达，雷达的位置为$(xlc, ylc)$，现在空间中有一个物体点P，通过2D雷达对其测量（雷达旋转方向为逆时针），得到对应的角度$angle$和距离$dis$，现在假设扫地机器人运动的角速度是$w_c$，线速度是$v_c$，在$t_0$时刻时，机器人坐标系$O_C$与世界坐标系$O_W$重合，这里的角度单位都是弧度，距离单位都是米。\n现在给这样一组数据，问在$t_1$时刻时，物体点P在世界坐标系$O_W$下的坐标：\nangle、dis、xlc、ylc、 vc、wc、t1\n需要理解的前提 首先，对于输入数据的理解：可以将测试数据作为一个验证情况，因为，当世界坐标系$O_W$，机器人坐标系$O_C$，雷达坐标系$O_L$之间的关系表达明确时，不管带入什么测试数据，都应该是满足的。\n另外，有一个常识需要补充：在C++环境以及处理物体学、数学分析等进行三角函数计算时，使用的都是弧度制， 1弧度 $\\frac{180}{\\pi}$度，1 度 = $\\frac{\\pi}{180}$弧度。\ndouble degrees = 90.0; double radians = degrees * (M_PI / 180.0); double sinValue = sin(radians); // 使用弧度 🌟进行一步一步拆解 t时间后机器人运动的位置 首先需要理解，扫地机器人是怎么运动的，在这里知道机器人运动同时拥有角速度$w_c$，线速度$v_c$。\n一般情况下，移动机器人是通过控制两个并行轮子的速度差（差速）进行旋转的。两个轮子速度相同时，移动机器人将直线运动，两个轮子速度不同时，移动机器人将绕着某一点进行旋转运动，这个点就是即时转动中心（Instantaneous Center of Rotation, 简称 ICC）。\n也就是说，机器人此时的运动模型是一个圆弧运动，运动的半径$R = \\frac{v_c}{w_c}$，运动的角度可以通过$\\theta = w \\cdot t$得到，而对于机器人中心点的位置情况则可以通过极坐标的关系来得到，也就是机器人中心为一点，绕着ICC为原点，进行半径为R的圆周运动，转动了$\\theta = w \\cdot t$角度，那么转动$t$时间后机器人中心点的位置以XY坐标系（笛卡尔坐标系）表达就是：\n$X_{t} = R \\sin(w_c \\cdot t)$ $Y_{t} = R (1 - \\cos(w_c \\cdot t))$ 由此假设以机器人坐标系$O_C$原点来计算，那么在t时间后，$O_C$原点的坐标在世界坐标系$O_W$上的表达为：\n$X_{W_C} = R \\sin(w_c \\cdot t)$ $Y_{W_C} = R (1 - \\cos(w_c \\cdot t))$ 即时转动中心（Instantaneous Center of Rotation） 在任意给定瞬间，一个在平面上进行复合运动（即同时包含平移和旋转）的物体看起来是围绕一个假想点进行旋转，这个点就是即时转动中心。\n这个点可能位于物体内部，也可能位于物体外部（取决于左右轮的速度），甚至可能无限远（这种情况下，物体的运动可以看作是纯平移）。\n假设一个通过两个并行轮子进行差速驱动的移动机器人，左右轮子的速度分别为$V_l$和$V_r$，两轮中心之间距离为$L$，那么可以定义机器人的线速度$v_c$和角速度$w_c$如下：\n线速度$v_c$，表示机器人移动时机器人中心点的速度，通过左右轮速度的平均值来估计： $$ v_c = \\frac{V_r + V_l}{2} $$ 角速度$w_c$描述了机器人绕ICC的旋转速度，可以通过左右轮速度差与轮距的比值来计算（通过$v = \\omega \\cdot r$得到）： $$ w_c = \\frac{V_r - V_l}{L} $$ 机器人绕ICC的圆弧运动半径$R$（从ICC到机器人中心的距离），根据$v = \\omega \\cdot r$可以得到： $$ R = \\frac{v_c}{w_c} $$\n将上述定义的$v_c$和$w_c$代入到$R$的公式中可以得到： $$ R = \\frac{\\frac{V_r + V_l}{2}}{\\frac{V_r - V_l}{L}} $$ $$ R = \\frac{L}{2} \\cdot \\frac{V_r + V_l}{V_r - V_l} $$\n另一种数学解释 对于ICC的计算，在任意瞬间，机器人的左右轮到ICC的距离固不变，形成一个圆周运动。假设右轮比左轮快，那么ICC位于机器人左侧，ICC距离机器人的中心点为$R$。\n由于机器人的左右两个轮子绕ICC的旋转半径不同，但是它们完成一次完整旋转所需的时间相同，因此有：\n左轮的圆周速度是$V_l$，旋转半径是$R - \\frac{L}{2}$。 右轮的圆周速度是$V_r$，旋转半径是$R + \\frac{L}{2}$。 根据圆周运动的速度公式$v = \\omega \\cdot r$，得到：\n$V_l = w_c \\cdot (R - \\frac{L}{2})$ $V_r = w_c \\cdot (R + \\frac{L}{2})$ 将$w_c$带入解方程可以得到：\n$$ R = \\frac{L}{2} \\cdot \\frac{V_r + V_l}{V_r - V_l} $$\n但是更直观的方式是利用角速度和线速度的定义来直接求解$R$，如下：\n$$ w_c = \\frac{V_r - V_l}{L} \\Rightarrow w_c \\cdot L = V_r - V_l $$\n并且\n$$ v_c = \\frac{V_r + V_l}{2} $$\n而$R$可以理解为机器人（中心点）绕ICC旋转的半径，其线速度$v_c$与角速度$w_c$之间存在如下关系：\n$$ R = \\frac{v_c}{w_c} $$\n圆周运动中的位置计算 对于绕ICC的圆周运动，可以用极坐标系下的圆方程来描述物体的位置。在极坐标系中，一个点的位置由它到原点的距离（半径$R$）和一个角度（$\\theta$）来定义。\n将ICC视为原点，则机器人中心就是这个点，其位置转换为笛卡尔坐标系来表示就是：\n$X = R \\sin(\\theta)$ $Y = R - R \\cos(\\theta) = R (1 - \\cos(\\theta))$ 物体点P在机器人坐标系$O_C$的表达 将2D-Lidar看作为一个点，也就是原点$O_L$，那么在雷达坐标系$O_L$下，物体点P可以直接通过三角关系得到在雷达坐标系$O_L$的表达：\n$X_{L_p} = dis \\cdot \\cos(angle)$ $Y_{L_p} = dis \\cdot \\sin(angle)$ 而雷达坐标系$O_L$和机器人坐标系$O_C$只相差了一个平移关系，也就是$(xlc, ylc)$，因此可以将平移的量加上得到在机器人坐标系$O_C$的表达\n$X_{C_p} = dis \\cdot \\cos(angle) + xlc$ $Y_{C_p} = dis \\cdot \\sin(angle) + ylc$ 物体点P在世界坐标系$O_W$的表达 因为机器人坐标系$O_C$和世界坐标系$O_W$相差了一个旋转，机器人坐标系$O_C$从与世界坐标系$O_W$重合的状态，通过逆时针旋转$\\theta = w \\cdot t$得到现在的状态。\n也就是说，以机器人坐标系$O_C$的表达的物体点P也需要通过这个**逆时针旋转$\\theta = w \\cdot t$**得到在当世界坐标系$O_W$的表达；\n因此世界坐标系$O_W$的物体点P为$(X_{W_p},Y_{W_p})$可以通过$(X_{C_p},Y_{C_p})$应用上逆时针旋转，再加上$O_C$的偏移得到。\n$X_{W_p} = X_{C_p} \\cdot \\cos{\\theta} - Y_{C_p} \\cdot \\sin{\\theta} + X_{W_C}$\n$X_{W_p} = X_{C_p} \\cdot \\sin{\\theta} + Y_{C_p} \\cdot \\cos{\\theta} + Y_{W_C}$\n注意，逆时针为正（以右手坐标系来看，X轴朝左，Y轴朝上）\n逆时针旋转角度 $\\theta$ 的旋转矩阵的证明 从二维旋转的基本几何出发。假设我们有一个点 $P$，在原点 $O$ 的坐标系中的初始位置为 $P(x, y)$，需要求出 $P$ 绕原点逆时针旋转角度 $\\theta$ 后的新位置 $P\u0026rsquo;(x\u0026rsquo;, y\u0026rsquo;)$：\n旋转前，点 $P$ 的位置可以由极坐标 $r$（原点到 $P$ 的距离）和 $\\phi$（$x$ 轴到 $OP$ 的角度）确定。在笛卡尔坐标系中，有：\n$x = r\\cos(\\phi)$ $y = r\\sin(\\phi)$ 当 $P$ 绕原点逆时针旋转 $\\theta$ 后，它的新位置 $P\u0026rsquo;$ 可以用新的极坐标 $r$ 和新的角度 $\\phi + \\theta$ 来表示（$r$ 保持不变，因为旋转不改变原点到 $P$ 的距离）。因此，旋转后的坐标为：\n$x\u0026rsquo; = r\\cos(\\phi + \\theta)$ $y\u0026rsquo; = r\\sin(\\phi + \\theta)$ 使用三角恒等式 $\\cos(a + b) = \\cos(a)\\cos(b) - \\sin(a)\\sin(b)$ 和 $\\sin(a + b) = \\sin(a)\\cos(b) + \\cos(a)\\sin(b)$，我们可以将 $x\u0026rsquo;$ 和 $y\u0026rsquo;$ 重写为：\n$x\u0026rsquo; = r\\cos(\\phi)\\cos(\\theta) - r\\sin(\\phi)\\sin(\\theta)$ $y\u0026rsquo; = r\\sin(\\phi)\\cos(\\theta) + r\\cos(\\phi)\\sin(\\theta)$ 将 $x = r\\cos(\\phi)$ 和 $y = r\\sin(\\phi)$，代入得到：\n$x\u0026rsquo; = x\\cos(\\theta) - y\\sin(\\theta)$ $y\u0026rsquo; = x\\sin(\\theta) + y\\cos(\\theta)$ 将上述方程写成矩阵形式，得到：\n$$ \\begin{bmatrix} x\u0026rsquo; \\ y\u0026rsquo; \\end{bmatrix} = \\begin{bmatrix} \\cos(\\theta) \u0026amp; -\\sin(\\theta) \\\\ \\sin(\\theta) \u0026amp; \\cos(\\theta) \\end{bmatrix} \\begin{bmatrix} x \\ y \\end{bmatrix} $$ 这个矩阵就是逆时针旋转角度 $\\theta$ 的旋转矩阵 $R(\\theta)$，能够将任何给定的点在二维平面上逆时针旋转 $\\theta$ 角度，而不改变点到原点的距离。\n如果旋转是顺时针方向的，角度 $\\theta$ 将被视为负值，以右手坐标系来看，X轴朝左，Y轴朝上时，逆时针旋转是正方向，顺时针旋转则是负方向。\n顺时针旋转角度 $\\theta$ 的旋转矩阵可以通过将逆时针旋转矩阵中的角度 $\\theta$ 替换为它的负值 $-\\theta$ 来得到，因为 $\\cos(-\\theta) = \\cos(\\theta)$ 和 $\\sin(-\\theta) = -\\sin(\\theta)$。这意味着，对于顺时针旋转，旋转矩阵 $R_{cw}(\\theta)$ 是：\n$$ R_{cw}(\\theta) = \\begin{bmatrix} \\cos(-\\theta) \u0026amp; -\\sin(-\\theta) \\\\ \\sin(-\\theta) \u0026amp; \\cos(-\\theta) \\end{bmatrix} $$ 使用三角函数的性质 $\\cos(-\\theta) = \\cos(\\theta)$ 和 $\\sin(-\\theta) = -\\sin(\\theta)$，得到：\n$$ R_{cw}(\\theta) = \\begin{bmatrix} \\cos(\\theta) \u0026amp; \\sin(\\theta) \\\\ -\\sin(\\theta) \u0026amp; \\cos(\\theta) \\end{bmatrix} $$ 因此，顺时针旋转矩阵直接使用正角度 $\\theta$ 为：\n$$ R_{cw}(\\theta) = \\begin{bmatrix} \\cos(\\theta) \u0026amp; \\sin(\\theta) \\\\ -\\sin(\\theta) \u0026amp; \\cos(\\theta) \\end{bmatrix} $$ 这个矩阵可以用来将任何给定的点在二维平面上顺时针旋转 $\\theta$ 角度，这与逆时针旋转从形式上看只是$\\sin(\\theta)$的正负号相反。\n完整的C++实现 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; int main() { // jj double angle, dis, xlc, ylc, vc, wc, t1; std::cin \u0026gt;\u0026gt; angle \u0026gt;\u0026gt; dis \u0026gt;\u0026gt; xlc \u0026gt;\u0026gt; ylc \u0026gt;\u0026gt; vc \u0026gt;\u0026gt; wc \u0026gt;\u0026gt; t1; // angle为弧度制，wc为弧度/s // dis为距离，vc为m/s // 起点(0, 0), 角速度wc, 线速度vc // 经过t1时间 double delta_v = vc * t1; double delta_w = wc * t1; // 机器人坐标系Oc，世界坐标Ow double Xwc, Ywc; double R = vc / wc; Xwc = R * sin(delta_w); Ywc = R * (1 - cos(delta_w)); // 打印Xwc, Ywc // std::cout \u0026lt;\u0026lt; Xwc \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; Ywc \u0026lt;\u0026lt; std::endl; // 求P点在世界坐标系Ow的坐标 // 先求P点在Oc的坐标 double Xcp, Ycp; Xcp = xlc + dis * cos(angle); Ycp = ylc + dis * sin(angle); // 打印Xcp, Ycp // std::cout \u0026lt;\u0026lt; Xcp \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; Ycp \u0026lt;\u0026lt; std::endl; // 再求P点在Ow的坐标 double Xwp, Ywp; Xwp = cos(delta_w) * Xcp - sin(delta_w) * Ycp + Xwc; Ywp = sin(delta_w) * Xcp + cos(delta_w) * Ycp + Ywc; // 打印Xwp, Ywp std::cout \u0026lt;\u0026lt; Xwp \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; Ywp \u0026lt;\u0026lt; std::endl; return 0; } ","permalink":"https://ahaknow.com/posts/know/aha-2d-coordinate-transformation/","summary":"问题的描述是这样的（用我理解后的语言来表达）： 以搭载2D激光雷达（2D-Lidar）的扫地机器人为例，只考虑在二维平面下的关系。世界坐标系$","title":"二维平面下的坐标系变换"},{"content":"就是要实现下面这种效果：\n# 就是展示一下效果^-^ 像这种想法怎么样一步步实现的呢？\n对于前端开发来说，最好的学习方式就是阅读源码学习：\n直接看实现过这个效果的的网站是怎么实现的（只要是HTML+CSS方式的，就能读出来，如果全是JS生成的，那就。。。只能另辟蹊径了。）\n","permalink":"https://ahaknow.com/posts/know/blog-mac-style-code/","summary":"就是要实现下面这种效果： # 就是展示一下效果^-^ 像这种想法怎么样一步步实现的呢？ 对于前端开发来说，最好的学习方式就是阅读源码学习： 直接看实现","title":"博客自定义：实现Mac风格的代码栏"},{"content":"以下是心路历程：\n为了写博客，因为觉得工具看着不爽，变成了学习Python后端（为啥不是Java？质问脸），开始造引擎？\n纠结于用什么博客框架，Hexo？Hugo？Halo？甚至想学JS框架自己做一个！\n最终还是回归了Hugo，因为markdown写完，直接编译，然后push就OK了；\n但是，又纠结起要不要自己租个服务器！国内服务器要备案（想想当年怎么在腾讯云备案的，又怎么气鼓鼓说再也不干这事了），so考虑香港服务器，一台服务器只是用来放博客嘛？（当然可以有很多用处，个人邮箱、下载器等等等）……\n就是一个静态博客啊，Github不就够了！！\n……\n好吧，老老实实Gitub + Hugo（当然可以Vercel自动部署，暂时用不到，Gitub Page就可以了）\n只是为了写作输出，又觉得直接的Hugo模版不够满意，再次变成了重学HTML、CSS、JS，自己动手改……\n改了一些，比如：Mac窗户风格的代码栏（甚至灵机一动还模拟鼠标放置显示关闭、最小化、最大化的效果）\n但是还是有不满意的：比如：标题下面的显示，太单调；目录能不能放置在两边，等等等等……无底深渊！\n算了，先写一篇正经的博客出来吧，剩下的想法之后慢慢补充！\n写博客到底为了啥？ 我是典型的属于“本末倒置”，不管用啥，哪怕就是文本直接展示，写博客的核心就是写啊！哪里是说：哦，这个博客引擎不行，自己写一个；那个框架看着不错，要不要换一个。重点是写先把文章写出来啊！\n就比如再写这篇文章之前，还在纠结，要不要再完善一下博客的外观……是啊，等你都完善了，菜都凉了，结果就是工具做好了，然后没有工作了，这不是搞笑嘛！放到写博客就是，兴致过去了，说要重新拾起来在写，然后精力全放在怎么把博客弄得好看点，最终精力用光了，博客又没写成，于是一年又一年，没了。\n写博客啊，你得先写再考虑展示啊！\n另外一个就是，不能拖，打死不能拖，脑袋里有想法了就写下来，不然一定会忘，不会再想起来的！血的教训！\n因此，现在我需要做的就是：\n把这两天折腾博客的东西记录下来，总结下来，沉淀下来，虽然少，但积少成多！\n以及，此前的博文写得断断续续的，也需要整理再拿出来，或者直接存着吧，今天开始，好好记录！不要停！\n","permalink":"https://ahaknow.com/posts/think/2024-begin-again/","summary":"以下是心路历程： 为了写博客，因为觉得工具看着不爽，变成了学习Python后端（为啥不是Java？质问脸），开始造引擎？ 纠结于用什么博客框架，","title":"折腾博客是为了更好地专注在写作上？"},{"content":" 引子：\n做了一个实时展示的小程序，一开始做的比较粗糙，每次呢，也就是每天的早上，都需要手动去执行，然后用鼠标去一点点调整展示窗口的大小和排列，一共三个窗口，一大两小，排列方式是固定的，但是由于每次都是一点点拖动摆放，因此每一次自己都需要对排列后的样子有一个预期，尽可能调整成看上去还不错的样子，尽管如此这般，也很难做到每次的排列都相同。做到这里，虽然没用到多少时间，几分钟吧，但耗费了不少注意力，因为每天都要想着：早上的第一件事是做这个，而且很有可能哪一天就忘了。晚上的话，还要想着去关掉它，手动关闭，费不了多少时间，但同时消耗了不少注意力，原因和早上的一样：一整天的潜意识里都会挂念着，晚上了得把它关掉。如此，一日复一天，天天如此，重复着同样的工作，而且似乎并没有意识到什么问题……\n都2024年了啊！还是个会敲代码的，天天就干这些事？不知道让这个小程序自己打开再自己关掉嘛？时间一直往前走，怎么写代码的意识还不如从前了呢！\n是啊，已经不知不觉陷入了一种“忙忙碌碌，不思进取，每天做着同样的事，为了活着而活着的”行尸走肉之中了。一天，两天，一周，一个月，大半年，就是这么混过来的，有进步嘛？有一点，但仔细瞧瞧只不过是错觉，很可能还是个负方向的。有反思嘛？好像有过，但借口一句没时间啊就过去了，正如此时敲击着键盘，如果现在不写，那么可能又是，一天过去，一周过去，一个月过去，于是乎，2025年2月20日啦。确实很打脸，因为上一次想要写写文字反思的时候，是2023年2月18日，而当下此刻，是2024年2月19日。。。\n什么时候种树都不迟，只要你意识到了就抡起铲子！也许当下的形势让你觉得自己的所学一文不值，那么就立刻开始，多学习点，想学的就去学，从自己的所爱出发，而不是犹豫、惆怅，还徘徊……\n说回来了，原本这一篇记录是想偏向于“自学的总结”，会涉及一些比较“专业”的东西，一些代码啊，一些指令啥的，昨晚借口一句：“困了先睡觉了”，就没写。欺骗自己说早上醒来写，实际上自己心里很清楚，大概率不可能。人的惰性太自然了，躺着多舒服啊，但如果一直躺着，那不如成为一具尸首。\n正篇：意识到了就立刻行动 我知道此前的我，也是成了“每天重复做着同样工作”的讨厌样子了。\n新的一年，那就由此改变吧！\n实时展示的小程序是吧，加一个自动启动和退出的功能咯！怎么做呢？\n我最开始的想法是将这个小程序软件化，也就是使用QT的可视化图形界面来改写，无奈，尝试了大半天，代码编译看着没问题了，但用不起来，这很大原因和自己没有系统学习有关。现在的chatGPT啊，写代码很厉害了，可能目前我的水平还比较低，用不好它，以至于说是让它辅助我改写，实际上我很多时候并不过脑子，直接复制粘贴，那哪行哦！这不就成了工具的奴隶了，连工具都不如了，这不更容易被食物链中的腐食者给吃了嘛。\n于是，我开始想，能不能通过一些技巧来实现我的需求呢？这些技巧背后依赖的功能应该是存在的，但是我不知道，此时我就是可以通过chatGPT协助了。\n现在是三个窗口（此前实现的时候，使用了多线程，因此同时展示的问题是解决的），我能不能把窗口数量减少，比如两个小窗口直接合成成一个？ 之前每次手动打开都需要手动调整窗口大小和位置，能不能直接在代码中实现预先的设置呢？ 自动打开，Linux上似乎有守护进程可以？但是没有在这里尝试过（这个也是很古老的知识了，至少六年前我就用过），想到过，但是没有行动起来！！ 自动关闭呢？之前设置了通过键盘输入q实现程序的退出，能不能让Linux自动模拟键入q呢？ 按照这个思路我就去做了～\n合并窗口：将思维打开，不要局限 一开始，我是用两个窗口来同时显示两个图像的，最简单也是最笨的操作。为啥之前我就没有想到将两个图像放在一个窗口里呢？\n可能是思维惯性，之前怎么做的，就跟着怎么做了。 也可能就是偷懒，从而导致的不动脑子，以及相应会产生的拖延。 认识到自己的思维存在僵化之后，开始改变：\n首先想到，直接拼接两张图像，上下拼接就能完成。但是在显示上不友好，上下拼接后变成一个长方形了，但是由于显示器很大，把窗口拉长之后上下图居中在一起，上下有空白的，显得很丑，从美观的角度来看的话，如果两个拼接的图像在上下位置能够保证对称，比如上方、两图中间、下方各自留出一块空间，这样就看着舒服了。按照这个思路，那就改～\n直接拼接不成，那就先考虑创建一个大的窗口，然后将两张图像分别搁进去，具体操作起来特别像前端的UI设计，要考虑padding的填充。这样的方法可行，然后还需要加入图像的标题，也采用往大窗口里搁置的思路，同样的，还是考虑了要设置padding的填充，使得标题能够局中。之后就是根据实际的情况，不断地调整窗口的尺寸，padding的大小，以达到自认为满意的比例了。至此，合并窗口完成了，现在的小程序只需要两个窗口就能满足了。\n代码备忘录📝 cv::Mat merged_image; if (left_image_color_global \u0026amp;\u0026amp; !left_image_color_global-\u0026gt;empty() \u0026amp;\u0026amp; disparity_color_global \u0026amp;\u0026amp; !disparity_color_global-\u0026gt;empty()) { int space = 25; // 标题和图像之间的空间 int test_height = 50; // 文本标题的高度（大致估计） cv::Scalar textColor(255, 255, 255); // 文本颜色 int font_face = cv::FONT_HERSHEY_SIMPLEX; double font_scale = 1; int thickness = 2; int top_padding = 20; int between_padding = 60; int bottom_padding = 20; int merged_height = left_image_color_global-\u0026gt;rows + disparity_color_global-\u0026gt;rows + 3 * space + 2 * test_height + top_padding + bottom_padding + between_padding; int merged_width = std::max(left_image_color_global-\u0026gt;cols, disparity_color_global-\u0026gt;cols); merged_image = cv::Mat::zeros(merged_height, merged_width, left_image_color_global-\u0026gt;type()); // 绘制第一个图像和标题 int title1_x = (merged_width - cv::getTextSize(\u0026#34;Left Image\u0026#34;, font_face, font_scale, thickness, nullptr).width) / 2; cv::putText(merged_image, \u0026#34;Left Image\u0026#34;, cv::Point(title1_x, test_height), font_face, font_scale, textColor, thickness); left_image_color_global-\u0026gt;copyTo(merged_image(cv::Rect(0, top_padding + test_height + space, left_image_color_global-\u0026gt;cols, left_image_color_global-\u0026gt;rows))); // 绘制第二个图像和标题 int title2_x = (merged_width - cv::getTextSize(\u0026#34;Dense Disparity\u0026#34;, font_face, font_scale, thickness, nullptr).width) / 2; int merged_mid = left_image_color_global-\u0026gt;rows + 2 * space + test_height + top_padding; cv::putText(merged_image, \u0026#34;Dense Disparity\u0026#34;, cv::Point(title2_x, merged_mid + test_height), font_face, font_scale, textColor, thickness); disparity_color_global-\u0026gt;copyTo(merged_image(cv::Rect(0, merged_mid + bottom_padding + test_height + space, disparity_color_global-\u0026gt;cols, disparity_color_global-\u0026gt;rows))); } 提前设置窗口位置：不知道的不代表没有，以前是搜索，现在是“问” 设置好窗口大小之后，还需要能够实现打开小程序后，两个窗口能够自动“站”到合适的位置。应该是有这样的方法的，只不过是我不知道，在没有chatGPT之前，可以用Google进行搜索，现在有了chatGPT，只要将需求描述清楚，一般互联网上已有的信息就能够获取到。因此我就直接“问”了有没有这样的方法，果然，有的，而且还很简洁。\n忽然想到一点，这个不就是信息差嘛！以前靠信息差吃某一种职位铁饭碗的想法应该在此之后自己消亡了吧？也许不会，因为好逸恶劳，因为懒惰，因为路径依赖？总之，现在自己意识到了还不算迟。\n所以，很可能以后还是很缺“产品经理、项目经理”这种明确知道需求是什么的，能够用精炼的语言将其描述清楚的总揽全局的人，而不缺重复的、低级的、复制粘贴的所谓“程序员”码农。\n代码备忘录📝 cv::namedWindow(\u0026#34;Color \u0026amp; Disparity\u0026#34;, cv::WINDOW_NORMAL); cv::resizeWindow(\u0026#34;Color \u0026amp; Disparity\u0026#34;, 1548, 2160); cv::moveWindow(\u0026#34;Color \u0026amp; Disparity\u0026#34;, 0, 0); // 将窗口移动到左上角 // ---------------------------------------------------------- // 创建点云可视化器 pcl::visualization::PCLVisualizer::Ptr viewer(new pcl::visualization::PCLVisualizer(\u0026#34;Dense PointCloud Viewer\u0026#34;)); viewer-\u0026gt;setBackgroundColor(0, 0, 0); viewer-\u0026gt;addPointCloud\u0026lt;pcl::PointXYZRGB\u0026gt;(point_cloud_ptr_global, \u0026#34;Dense PointCloud\u0026#34;); viewer-\u0026gt;setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, \u0026#34;Dense PointCloud\u0026#34;); viewer-\u0026gt;initCameraParameters(); viewer-\u0026gt;setCameraPosition( 0, 0, -1.5, // 控制相机的XYZ位置 0, 0.25, 1, 0, 1, 0 // 后面点云转了旋转，这里Y为1 ); viewer-\u0026gt;setSize(2220, 2160); // 因为使用了VTK的窗口 vtkSmartPointer\u0026lt;vtkRenderWindow\u0026gt; renderWindow = viewer-\u0026gt;getRenderWindow(); renderWindow-\u0026gt;SetPosition(1900, 0); 自启动：不懂的就多探究，不要是一个“半瓶水响叮当” 之前知道一种方法是用守护进程：通过crontab -e进行设置，我也用这个方法尝试了，发现不起作用。分析原因得到：\n因为，我启动的小程序需要调用显示窗口，OpenCV提供的简易窗口和VTK提供的可视化窗口，而守护进程启动命令时，是一种“文本”方式，无法唤起显示的窗口。\n**以前在服务器上用crontab自启动一些命令，因为只会有文本输出，比较简易，那会儿使用远程服务器，自然也不会涉及显示，也就忽略了这个问题。**所以，我此前对于守护进程的理解还只是皮毛，今天多了一些使用的经验。但更重要的是从这次的经历中学会一些“遇到问题、分析现象、思考解决”的思维。\n发现这条路走不通，于是，将自己的需求重新整理了一遍：\n“我希望在当前显示器下，当前的命令行终端下，定时地执行某一个命令”\n在这个思路下，找到了一个可行的方式：\n在终端中，持续运行一个判断：获取当前时间，判断是否等于设定的需要自动打开的时间，如果是就执行命令，然后之后一段时间里不再执行。\n在Linux环境下，这个判断可以比较直接的实现：通过Bash脚本的方式。（本质就是Bash脚本自动化）\n这里明白了一点，一条路走不通很可能是这路条本身就不对，因为很多时候对一项事物也是处于一种了解皮毛的状态，所以遇到问题了要学会打破“自以为是”，从整体的层面来进行分析，对于这里的问题就是：“守护进程不行，为啥不行，那我把运行的日志打印出来，然后分析一下错误信息，再考虑这种方法是不是本身就不支持。”\n代码备忘录📝 #!/bin/bash TARGET_TIME=\u0026#34;09:00\u0026#34; while true; do CURRENT_TIME=$(date +%H:%M) if [ \u0026#34;$CURRENT_TIME\u0026#34; == \u0026#34;$TARGET_TIME\u0026#34; ]; then /home/metoak/Projects/RealTimeDensePointCloud/C++/build/tensorrt_inference_one_camera /home/metoak/Projects/RealTimeDensePointCloud/C++/models/model_mobilev2_960_512.trt 960 512 sleep 60 # 避免在目标时间多次执行 fi sleep 30 # 每30秒检查一次时间 done 自关闭：脑子是越用越灵光的，多想想，不要固化，不要陷入路径依赖 在这里遇到的问题和自启动时差不多。在最开始实现时，也想到了要实现手动关闭，所以就设置了一个通过键盘关闭的方法。我在想能不能自动关闭时，也就顺着这个思路走下去了：“能不能用指令来模拟键盘输入，来达到跟手动按下键盘一样的效果呢？\n想法是好的，也通过chatGPT进行“询问”和尝试，是有这种方法的，但是无法应用在这个问题的解决上。原因简单分析如下：\n通过一个指令或者一个程序模拟键盘输入，它所生效的位置是这个指令或者程序运行的空间；而我通过键盘控制关闭时，实际上是做了两件事：一、先选中窗口，二、按下键盘上的q键；模拟键盘输入可以完成第二步，但是完成不了第一步，因此这种方法在这里不起作用。\n至少，我在思考问题上，会多想一步了。但也陷进了路径依赖中！\n想让程序自己关闭的最快捷方式难道不应该是在程序内部实现嘛？而且很方便的只需要一个判断就行了，不然要你编码做何用？\n是啊，我忘记了，整个演示程序的代码都是我写的，那我想控制什么时候关闭，不是很容易嘛！（什么时候开启不太行，但用了上面的持续运行判断是可以的，因为开启需要从外界开启。断电的电脑怎么自动开机呢？但开机的电脑可以设置定时关闭，如此常识，自己之前咋就忘了呢。。。）\n所以，有时候可以让自己适当放空，然后重新梳理，一步一步来分析解决。\n路径依赖，说到底也是因为懒，能不能打破懒，还得看自己够不够狠心和韧性了，愈挫愈勇，这个方法不行，大不了从头来，用新的思路来解决！\n代码备忘录📝 // 获取当前时间 auto now = std::chrono::system_clock::now(); std::time_t now_c = std::chrono::system_clock::to_time_t(now); std::tm now_tm = *std::localtime(\u0026amp;now_c); // 检查时间是否超过19:00 if (now_tm.tm_hour \u0026gt;= 19) { std::cout \u0026lt;\u0026lt; \u0026#34;Current time is \u0026#34; \u0026lt;\u0026lt; std::put_time(\u0026amp;now_tm, \u0026#34;%F %T\u0026#34;) \u0026lt;\u0026lt; \u0026#34;, the machine need to rest, See you tomorrow!\u0026#34; \u0026lt;\u0026lt; std::endl; running = false; } // 原来的手动关闭操作 int key = cv::waitKey(1); if (key == \u0026#39;q\u0026#39; || key == \u0026#39;Q\u0026#39;) { running = false; } 结束语：继续坚持，从1到2到3，到100，到一直能坚持 人类最可贵的，不就是会思考嘛，机器智能只会越来越强盛的今后，尤其显得珍贵！\n继续坚持，明天再继续～\n2024年2月19日\n","permalink":"https://ahaknow.com/posts/think/master-of-innovation-or-slave-of-repetition/","summary":"引子： 做了一个实时展示的小程序，一开始做的比较粗糙，每次呢，也就是每天的早上，都需要手动去执行，然后用鼠标去一点点调整展示窗口的大小和排列，","title":"创新的主人还是重复的奴隶？"},{"content":" 让自己不后悔的话，那就动起来！\n动起来就能转起来了！\n—— 2024年4月12日补充\n话说，重新拾起要再次记录的念头，应该是一年前！\n最早开始想要记录，应该是六年前！六年啊！一恍惚就过去了？并且最可怕的事情，对比现在的自己和六年前的自己，似乎，还不如了？！！！\n六年，2190天，每天退步一点点，0.99的2190次方： $$ 0.99^{6\\times365} = 2.7610621 \\times 10^{-10} = 0.00000000028 $$ 真的是，退步的不能再退步了，也真的太可怕了。\n时间无情的走了，而我呢，日复一日，年复一年，忙忙碌碌，重重复复，一路滑向深渊。\n能不能再做到，每天思考并记录呢？以前做到过，但是中断了，能不能在捡起来，再继续做下去！\n一直对自己说，自己是内驱的，自己是自律，结果事实却在打自己脸。\n一样会沉迷于电视剧，一样会沉沦在概率游戏中。\n总之，不知好歹！！\n","permalink":"https://ahaknow.com/posts/diary/2024_first/","summary":"让自己不后悔的话，那就动起来！ 动起来就能转起来了！ —— 2024年4月12日补充 话说，重新拾起要再次记录的念头，应该是一年前！ 最早开始想要记录","title":"2024年的第一篇记录"},{"content":"💊Linux药剂 command-not-found：遇见各种Command not found时服用\ngitmoji：Git提交表情包\n🌊艺术细胞 uhdpaper：当需要使用超高清壁纸时服用\n无聊了？：无聊的时候点看有惊喜！\n🥣日常服用 markdown权威指南：基础和拓展两部分语法\n","permalink":"https://ahaknow.com/toolkits/","summary":"💊Linux药剂 command-not-found：遇见各种Command not found时服用 gitmoji：Git提交表情包 🌊艺术细胞 uhd","title":"🧰 医疗箱"}]